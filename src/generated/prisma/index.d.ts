
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UniversityInfo
 * 
 */
export type UniversityInfo = $Result.DefaultSelection<Prisma.$UniversityInfoPayload>
/**
 * Model UserSetting
 * 
 */
export type UserSetting = $Result.DefaultSelection<Prisma.$UserSettingPayload>
/**
 * Model Divisions
 * 
 */
export type Divisions = $Result.DefaultSelection<Prisma.$DivisionsPayload>
/**
 * Model Groups
 * 
 */
export type Groups = $Result.DefaultSelection<Prisma.$GroupsPayload>
/**
 * Model socialLink
 * 
 */
export type socialLink = $Result.DefaultSelection<Prisma.$socialLinkPayload>
/**
 * Model EventTimeSlot
 * 
 */
export type EventTimeSlot = $Result.DefaultSelection<Prisma.$EventTimeSlotPayload>
/**
 * Model SessionTimeSlot
 * 
 */
export type SessionTimeSlot = $Result.DefaultSelection<Prisma.$SessionTimeSlotPayload>
/**
 * Model Events
 * 
 */
export type Events = $Result.DefaultSelection<Prisma.$EventsPayload>
/**
 * Model Sessions
 * 
 */
export type Sessions = $Result.DefaultSelection<Prisma.$SessionsPayload>
/**
 * Model Tasks
 * 
 */
export type Tasks = $Result.DefaultSelection<Prisma.$TasksPayload>
/**
 * Model EventParticipation
 * 
 */
export type EventParticipation = $Result.DefaultSelection<Prisma.$EventParticipationPayload>
/**
 * Model SessionParticipation
 * 
 */
export type SessionParticipation = $Result.DefaultSelection<Prisma.$SessionParticipationPayload>
/**
 * Model TaskParticipation
 * 
 */
export type TaskParticipation = $Result.DefaultSelection<Prisma.$TaskParticipationPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model AttendanceSummary
 * 
 */
export type AttendanceSummary = $Result.DefaultSelection<Prisma.$AttendanceSummaryPayload>
/**
 * Model HeadsUp
 * 
 */
export type HeadsUp = $Result.DefaultSelection<Prisma.$HeadsUpPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model FileCategories
 * 
 */
export type FileCategories = $Result.DefaultSelection<Prisma.$FileCategoriesPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model Badges
 * 
 */
export type Badges = $Result.DefaultSelection<Prisma.$BadgesPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  Male: 'Male',
  Female: 'Female'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ClubStatus: {
  Active: 'Active',
  Alumni: 'Alumni',
  Banned: 'Banned'
};

export type ClubStatus = (typeof ClubStatus)[keyof typeof ClubStatus]


export const RoleType: {
  SuperAdmin: 'SuperAdmin',
  President: 'President',
  VicePresident: 'VicePresident',
  DivisionHead: 'DivisionHead',
  Coordinator: 'Coordinator',
  Member: 'Member'
};

export type RoleType = (typeof RoleType)[keyof typeof RoleType]


export const UniversityStatus: {
  onCampus: 'onCampus',
  offCampus: 'offCampus',
  withdraw: 'withdraw',
  dropOut: 'dropOut'
};

export type UniversityStatus = (typeof UniversityStatus)[keyof typeof UniversityStatus]


export const Theme: {
  Light: 'Light',
  Dark: 'Dark',
  System: 'System'
};

export type Theme = (typeof Theme)[keyof typeof Theme]


export const EventVisibility: {
  PUBLIC: 'PUBLIC',
  MEMBERS_ONLY: 'MEMBERS_ONLY'
};

export type EventVisibility = (typeof EventVisibility)[keyof typeof EventVisibility]


export const Tag: {
  CPD: 'CPD',
  CBD: 'CBD',
  SEC: 'SEC',
  DEV: 'DEV',
  DS: 'DS',
  ENTIRE: 'ENTIRE'
};

export type Tag = (typeof Tag)[keyof typeof Tag]


export const state: {
  Planned: 'Planned',
  Ongoing: 'Ongoing',
  Completed: 'Completed',
  Canceled: 'Canceled',
  Postponed: 'Postponed'
};

export type state = (typeof state)[keyof typeof state]


export const TaskStatus: {
  Pending: 'Pending',
  InProgress: 'InProgress',
  Completed: 'Completed',
  Rejected: 'Rejected',
  CANCELED: 'CANCELED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const SessionRole: {
  Speaker: 'Speaker',
  Coordinator: 'Coordinator',
  Host: 'Host',
  Organizer: 'Organizer',
  Mentor: 'Mentor'
};

export type SessionRole = (typeof SessionRole)[keyof typeof SessionRole]


export const EventRole: {
  ORGANIZER: 'ORGANIZER',
  PARTICIPANT: 'PARTICIPANT',
  SPEAKER: 'SPEAKER',
  COORDINATOR: 'COORDINATOR',
  HOST: 'HOST',
  MENTOR: 'MENTOR'
};

export type EventRole = (typeof EventRole)[keyof typeof EventRole]


export const HeadsUpType: {
  SICK: 'SICK',
  TRAVEL: 'TRAVEL',
  PERSONAL: 'PERSONAL',
  OTHER: 'OTHER'
};

export type HeadsUpType = (typeof HeadsUpType)[keyof typeof HeadsUpType]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  EXCUSED: 'EXCUSED',
  UNMARKED: 'UNMARKED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const NotificationType: {
  Announcement: 'Announcement',
  Task: 'Task',
  Session: 'Session',
  Event: 'Event',
  Reminder: 'Reminder',
  Alert: 'Alert',
  Update: 'Update'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const AnnouncementVisibility: {
  PUBLIC: 'PUBLIC',
  Division_ONLY: 'Division_ONLY',
  GROUP_ONLY: 'GROUP_ONLY'
};

export type AnnouncementVisibility = (typeof AnnouncementVisibility)[keyof typeof AnnouncementVisibility]


export const AnnouncementType: {
  EVENT: 'EVENT',
  SESSION: 'SESSION',
  TASK: 'TASK',
  GENERAL: 'GENERAL'
};

export type AnnouncementType = (typeof AnnouncementType)[keyof typeof AnnouncementType]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ClubStatus = $Enums.ClubStatus

export const ClubStatus: typeof $Enums.ClubStatus

export type RoleType = $Enums.RoleType

export const RoleType: typeof $Enums.RoleType

export type UniversityStatus = $Enums.UniversityStatus

export const UniversityStatus: typeof $Enums.UniversityStatus

export type Theme = $Enums.Theme

export const Theme: typeof $Enums.Theme

export type EventVisibility = $Enums.EventVisibility

export const EventVisibility: typeof $Enums.EventVisibility

export type Tag = $Enums.Tag

export const Tag: typeof $Enums.Tag

export type state = $Enums.state

export const state: typeof $Enums.state

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type SessionRole = $Enums.SessionRole

export const SessionRole: typeof $Enums.SessionRole

export type EventRole = $Enums.EventRole

export const EventRole: typeof $Enums.EventRole

export type HeadsUpType = $Enums.HeadsUpType

export const HeadsUpType: typeof $Enums.HeadsUpType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type AnnouncementVisibility = $Enums.AnnouncementVisibility

export const AnnouncementVisibility: typeof $Enums.AnnouncementVisibility

export type AnnouncementType = $Enums.AnnouncementType

export const AnnouncementType: typeof $Enums.AnnouncementType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.universityInfo`: Exposes CRUD operations for the **UniversityInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UniversityInfos
    * const universityInfos = await prisma.universityInfo.findMany()
    * ```
    */
  get universityInfo(): Prisma.UniversityInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSetting`: Exposes CRUD operations for the **UserSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSetting.findMany()
    * ```
    */
  get userSetting(): Prisma.UserSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.divisions`: Exposes CRUD operations for the **Divisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisions
    * const divisions = await prisma.divisions.findMany()
    * ```
    */
  get divisions(): Prisma.DivisionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groups`: Exposes CRUD operations for the **Groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.GroupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialLink`: Exposes CRUD operations for the **socialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLink.findMany()
    * ```
    */
  get socialLink(): Prisma.socialLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventTimeSlot`: Exposes CRUD operations for the **EventTimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTimeSlots
    * const eventTimeSlots = await prisma.eventTimeSlot.findMany()
    * ```
    */
  get eventTimeSlot(): Prisma.EventTimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionTimeSlot`: Exposes CRUD operations for the **SessionTimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionTimeSlots
    * const sessionTimeSlots = await prisma.sessionTimeSlot.findMany()
    * ```
    */
  get sessionTimeSlot(): Prisma.SessionTimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **Sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.SessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tasks`: Exposes CRUD operations for the **Tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.tasks.findMany()
    * ```
    */
  get tasks(): Prisma.TasksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventParticipation`: Exposes CRUD operations for the **EventParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventParticipations
    * const eventParticipations = await prisma.eventParticipation.findMany()
    * ```
    */
  get eventParticipation(): Prisma.EventParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionParticipation`: Exposes CRUD operations for the **SessionParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionParticipations
    * const sessionParticipations = await prisma.sessionParticipation.findMany()
    * ```
    */
  get sessionParticipation(): Prisma.SessionParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskParticipation`: Exposes CRUD operations for the **TaskParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskParticipations
    * const taskParticipations = await prisma.taskParticipation.findMany()
    * ```
    */
  get taskParticipation(): Prisma.TaskParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceSummary`: Exposes CRUD operations for the **AttendanceSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceSummaries
    * const attendanceSummaries = await prisma.attendanceSummary.findMany()
    * ```
    */
  get attendanceSummary(): Prisma.AttendanceSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.headsUp`: Exposes CRUD operations for the **HeadsUp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeadsUps
    * const headsUps = await prisma.headsUp.findMany()
    * ```
    */
  get headsUp(): Prisma.HeadsUpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileCategories`: Exposes CRUD operations for the **FileCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileCategories
    * const fileCategories = await prisma.fileCategories.findMany()
    * ```
    */
  get fileCategories(): Prisma.FileCategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badges`: Exposes CRUD operations for the **Badges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badges.findMany()
    * ```
    */
  get badges(): Prisma.BadgesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UniversityInfo: 'UniversityInfo',
    UserSetting: 'UserSetting',
    Divisions: 'Divisions',
    Groups: 'Groups',
    socialLink: 'socialLink',
    EventTimeSlot: 'EventTimeSlot',
    SessionTimeSlot: 'SessionTimeSlot',
    Events: 'Events',
    Sessions: 'Sessions',
    Tasks: 'Tasks',
    EventParticipation: 'EventParticipation',
    SessionParticipation: 'SessionParticipation',
    TaskParticipation: 'TaskParticipation',
    Attendance: 'Attendance',
    AttendanceSummary: 'AttendanceSummary',
    HeadsUp: 'HeadsUp',
    Notification: 'Notification',
    Announcement: 'Announcement',
    FileCategories: 'FileCategories',
    File: 'File',
    Badges: 'Badges',
    Permission: 'Permission',
    RolePermission: 'RolePermission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "universityInfo" | "userSetting" | "divisions" | "groups" | "socialLink" | "eventTimeSlot" | "sessionTimeSlot" | "events" | "sessions" | "tasks" | "eventParticipation" | "sessionParticipation" | "taskParticipation" | "attendance" | "attendanceSummary" | "headsUp" | "notification" | "announcement" | "fileCategories" | "file" | "badges" | "permission" | "rolePermission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UniversityInfo: {
        payload: Prisma.$UniversityInfoPayload<ExtArgs>
        fields: Prisma.UniversityInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UniversityInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UniversityInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>
          }
          findFirst: {
            args: Prisma.UniversityInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UniversityInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>
          }
          findMany: {
            args: Prisma.UniversityInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>[]
          }
          create: {
            args: Prisma.UniversityInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>
          }
          createMany: {
            args: Prisma.UniversityInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UniversityInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>[]
          }
          delete: {
            args: Prisma.UniversityInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>
          }
          update: {
            args: Prisma.UniversityInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>
          }
          deleteMany: {
            args: Prisma.UniversityInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UniversityInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UniversityInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>[]
          }
          upsert: {
            args: Prisma.UniversityInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityInfoPayload>
          }
          aggregate: {
            args: Prisma.UniversityInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniversityInfo>
          }
          groupBy: {
            args: Prisma.UniversityInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UniversityInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UniversityInfoCountArgs<ExtArgs>
            result: $Utils.Optional<UniversityInfoCountAggregateOutputType> | number
          }
        }
      }
      UserSetting: {
        payload: Prisma.$UserSettingPayload<ExtArgs>
        fields: Prisma.UserSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findFirst: {
            args: Prisma.UserSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findMany: {
            args: Prisma.UserSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          create: {
            args: Prisma.UserSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          createMany: {
            args: Prisma.UserSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          delete: {
            args: Prisma.UserSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          update: {
            args: Prisma.UserSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          aggregate: {
            args: Prisma.UserSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSetting>
          }
          groupBy: {
            args: Prisma.UserSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingCountAggregateOutputType> | number
          }
        }
      }
      Divisions: {
        payload: Prisma.$DivisionsPayload<ExtArgs>
        fields: Prisma.DivisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DivisionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DivisionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>
          }
          findFirst: {
            args: Prisma.DivisionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DivisionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>
          }
          findMany: {
            args: Prisma.DivisionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>[]
          }
          create: {
            args: Prisma.DivisionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>
          }
          createMany: {
            args: Prisma.DivisionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DivisionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>[]
          }
          delete: {
            args: Prisma.DivisionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>
          }
          update: {
            args: Prisma.DivisionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>
          }
          deleteMany: {
            args: Prisma.DivisionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DivisionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DivisionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>[]
          }
          upsert: {
            args: Prisma.DivisionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionsPayload>
          }
          aggregate: {
            args: Prisma.DivisionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDivisions>
          }
          groupBy: {
            args: Prisma.DivisionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DivisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DivisionsCountArgs<ExtArgs>
            result: $Utils.Optional<DivisionsCountAggregateOutputType> | number
          }
        }
      }
      Groups: {
        payload: Prisma.$GroupsPayload<ExtArgs>
        fields: Prisma.GroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          findFirst: {
            args: Prisma.GroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          findMany: {
            args: Prisma.GroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          create: {
            args: Prisma.GroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          createMany: {
            args: Prisma.GroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          delete: {
            args: Prisma.GroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          update: {
            args: Prisma.GroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          deleteMany: {
            args: Prisma.GroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          upsert: {
            args: Prisma.GroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          aggregate: {
            args: Prisma.GroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroups>
          }
          groupBy: {
            args: Prisma.GroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupsCountArgs<ExtArgs>
            result: $Utils.Optional<GroupsCountAggregateOutputType> | number
          }
        }
      }
      socialLink: {
        payload: Prisma.$socialLinkPayload<ExtArgs>
        fields: Prisma.socialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.socialLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.socialLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>
          }
          findFirst: {
            args: Prisma.socialLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.socialLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>
          }
          findMany: {
            args: Prisma.socialLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>[]
          }
          create: {
            args: Prisma.socialLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>
          }
          createMany: {
            args: Prisma.socialLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.socialLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>[]
          }
          delete: {
            args: Prisma.socialLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>
          }
          update: {
            args: Prisma.socialLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>
          }
          deleteMany: {
            args: Prisma.socialLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.socialLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.socialLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>[]
          }
          upsert: {
            args: Prisma.socialLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialLinkPayload>
          }
          aggregate: {
            args: Prisma.SocialLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLink>
          }
          groupBy: {
            args: Prisma.socialLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.socialLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkCountAggregateOutputType> | number
          }
        }
      }
      EventTimeSlot: {
        payload: Prisma.$EventTimeSlotPayload<ExtArgs>
        fields: Prisma.EventTimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>
          }
          findFirst: {
            args: Prisma.EventTimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>
          }
          findMany: {
            args: Prisma.EventTimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>[]
          }
          create: {
            args: Prisma.EventTimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>
          }
          createMany: {
            args: Prisma.EventTimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventTimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>[]
          }
          delete: {
            args: Prisma.EventTimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>
          }
          update: {
            args: Prisma.EventTimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.EventTimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventTimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.EventTimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTimeSlotPayload>
          }
          aggregate: {
            args: Prisma.EventTimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventTimeSlot>
          }
          groupBy: {
            args: Prisma.EventTimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<EventTimeSlotCountAggregateOutputType> | number
          }
        }
      }
      SessionTimeSlot: {
        payload: Prisma.$SessionTimeSlotPayload<ExtArgs>
        fields: Prisma.SessionTimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionTimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionTimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>
          }
          findFirst: {
            args: Prisma.SessionTimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionTimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>
          }
          findMany: {
            args: Prisma.SessionTimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>[]
          }
          create: {
            args: Prisma.SessionTimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>
          }
          createMany: {
            args: Prisma.SessionTimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionTimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>[]
          }
          delete: {
            args: Prisma.SessionTimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>
          }
          update: {
            args: Prisma.SessionTimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.SessionTimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionTimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionTimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.SessionTimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTimeSlotPayload>
          }
          aggregate: {
            args: Prisma.SessionTimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionTimeSlot>
          }
          groupBy: {
            args: Prisma.SessionTimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionTimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionTimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<SessionTimeSlotCountAggregateOutputType> | number
          }
        }
      }
      Events: {
        payload: Prisma.$EventsPayload<ExtArgs>
        fields: Prisma.EventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findFirst: {
            args: Prisma.EventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findMany: {
            args: Prisma.EventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          create: {
            args: Prisma.EventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          createMany: {
            args: Prisma.EventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          delete: {
            args: Prisma.EventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          update: {
            args: Prisma.EventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          deleteMany: {
            args: Prisma.EventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          upsert: {
            args: Prisma.EventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      Sessions: {
        payload: Prisma.$SessionsPayload<ExtArgs>
        fields: Prisma.SessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>
          }
          findFirst: {
            args: Prisma.SessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>
          }
          findMany: {
            args: Prisma.SessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>[]
          }
          create: {
            args: Prisma.SessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>
          }
          createMany: {
            args: Prisma.SessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>[]
          }
          delete: {
            args: Prisma.SessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>
          }
          update: {
            args: Prisma.SessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>
          }
          deleteMany: {
            args: Prisma.SessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>[]
          }
          upsert: {
            args: Prisma.SessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.SessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      Tasks: {
        payload: Prisma.$TasksPayload<ExtArgs>
        fields: Prisma.TasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findFirst: {
            args: Prisma.TasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findMany: {
            args: Prisma.TasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          create: {
            args: Prisma.TasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          createMany: {
            args: Prisma.TasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TasksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          delete: {
            args: Prisma.TasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          update: {
            args: Prisma.TasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          deleteMany: {
            args: Prisma.TasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TasksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          upsert: {
            args: Prisma.TasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          aggregate: {
            args: Prisma.TasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasks>
          }
          groupBy: {
            args: Prisma.TasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.TasksCountArgs<ExtArgs>
            result: $Utils.Optional<TasksCountAggregateOutputType> | number
          }
        }
      }
      EventParticipation: {
        payload: Prisma.$EventParticipationPayload<ExtArgs>
        fields: Prisma.EventParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>
          }
          findFirst: {
            args: Prisma.EventParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>
          }
          findMany: {
            args: Prisma.EventParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>[]
          }
          create: {
            args: Prisma.EventParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>
          }
          createMany: {
            args: Prisma.EventParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>[]
          }
          delete: {
            args: Prisma.EventParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>
          }
          update: {
            args: Prisma.EventParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>
          }
          deleteMany: {
            args: Prisma.EventParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventParticipationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>[]
          }
          upsert: {
            args: Prisma.EventParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventParticipationPayload>
          }
          aggregate: {
            args: Prisma.EventParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventParticipation>
          }
          groupBy: {
            args: Prisma.EventParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<EventParticipationCountAggregateOutputType> | number
          }
        }
      }
      SessionParticipation: {
        payload: Prisma.$SessionParticipationPayload<ExtArgs>
        fields: Prisma.SessionParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>
          }
          findFirst: {
            args: Prisma.SessionParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>
          }
          findMany: {
            args: Prisma.SessionParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>[]
          }
          create: {
            args: Prisma.SessionParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>
          }
          createMany: {
            args: Prisma.SessionParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>[]
          }
          delete: {
            args: Prisma.SessionParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>
          }
          update: {
            args: Prisma.SessionParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>
          }
          deleteMany: {
            args: Prisma.SessionParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionParticipationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>[]
          }
          upsert: {
            args: Prisma.SessionParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipationPayload>
          }
          aggregate: {
            args: Prisma.SessionParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionParticipation>
          }
          groupBy: {
            args: Prisma.SessionParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<SessionParticipationCountAggregateOutputType> | number
          }
        }
      }
      TaskParticipation: {
        payload: Prisma.$TaskParticipationPayload<ExtArgs>
        fields: Prisma.TaskParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>
          }
          findFirst: {
            args: Prisma.TaskParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>
          }
          findMany: {
            args: Prisma.TaskParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>[]
          }
          create: {
            args: Prisma.TaskParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>
          }
          createMany: {
            args: Prisma.TaskParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>[]
          }
          delete: {
            args: Prisma.TaskParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>
          }
          update: {
            args: Prisma.TaskParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>
          }
          deleteMany: {
            args: Prisma.TaskParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskParticipationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>[]
          }
          upsert: {
            args: Prisma.TaskParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskParticipationPayload>
          }
          aggregate: {
            args: Prisma.TaskParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskParticipation>
          }
          groupBy: {
            args: Prisma.TaskParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<TaskParticipationCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      AttendanceSummary: {
        payload: Prisma.$AttendanceSummaryPayload<ExtArgs>
        fields: Prisma.AttendanceSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findFirst: {
            args: Prisma.AttendanceSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findMany: {
            args: Prisma.AttendanceSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          create: {
            args: Prisma.AttendanceSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          createMany: {
            args: Prisma.AttendanceSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          delete: {
            args: Prisma.AttendanceSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          update: {
            args: Prisma.AttendanceSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          aggregate: {
            args: Prisma.AttendanceSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceSummary>
          }
          groupBy: {
            args: Prisma.AttendanceSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryCountAggregateOutputType> | number
          }
        }
      }
      HeadsUp: {
        payload: Prisma.$HeadsUpPayload<ExtArgs>
        fields: Prisma.HeadsUpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeadsUpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeadsUpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>
          }
          findFirst: {
            args: Prisma.HeadsUpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeadsUpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>
          }
          findMany: {
            args: Prisma.HeadsUpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>[]
          }
          create: {
            args: Prisma.HeadsUpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>
          }
          createMany: {
            args: Prisma.HeadsUpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeadsUpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>[]
          }
          delete: {
            args: Prisma.HeadsUpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>
          }
          update: {
            args: Prisma.HeadsUpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>
          }
          deleteMany: {
            args: Prisma.HeadsUpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeadsUpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HeadsUpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>[]
          }
          upsert: {
            args: Prisma.HeadsUpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeadsUpPayload>
          }
          aggregate: {
            args: Prisma.HeadsUpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeadsUp>
          }
          groupBy: {
            args: Prisma.HeadsUpGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeadsUpGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeadsUpCountArgs<ExtArgs>
            result: $Utils.Optional<HeadsUpCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      FileCategories: {
        payload: Prisma.$FileCategoriesPayload<ExtArgs>
        fields: Prisma.FileCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>
          }
          findFirst: {
            args: Prisma.FileCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>
          }
          findMany: {
            args: Prisma.FileCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>[]
          }
          create: {
            args: Prisma.FileCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>
          }
          createMany: {
            args: Prisma.FileCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>[]
          }
          delete: {
            args: Prisma.FileCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>
          }
          update: {
            args: Prisma.FileCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.FileCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileCategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>[]
          }
          upsert: {
            args: Prisma.FileCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileCategoriesPayload>
          }
          aggregate: {
            args: Prisma.FileCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileCategories>
          }
          groupBy: {
            args: Prisma.FileCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<FileCategoriesCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      Badges: {
        payload: Prisma.$BadgesPayload<ExtArgs>
        fields: Prisma.BadgesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>
          }
          findFirst: {
            args: Prisma.BadgesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>
          }
          findMany: {
            args: Prisma.BadgesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>[]
          }
          create: {
            args: Prisma.BadgesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>
          }
          createMany: {
            args: Prisma.BadgesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>[]
          }
          delete: {
            args: Prisma.BadgesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>
          }
          update: {
            args: Prisma.BadgesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>
          }
          deleteMany: {
            args: Prisma.BadgesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>[]
          }
          upsert: {
            args: Prisma.BadgesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgesPayload>
          }
          aggregate: {
            args: Prisma.BadgesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadges>
          }
          groupBy: {
            args: Prisma.BadgesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgesCountArgs<ExtArgs>
            result: $Utils.Optional<BadgesCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    universityInfo?: UniversityInfoOmit
    userSetting?: UserSettingOmit
    divisions?: DivisionsOmit
    groups?: GroupsOmit
    socialLink?: socialLinkOmit
    eventTimeSlot?: EventTimeSlotOmit
    sessionTimeSlot?: SessionTimeSlotOmit
    events?: EventsOmit
    sessions?: SessionsOmit
    tasks?: TasksOmit
    eventParticipation?: EventParticipationOmit
    sessionParticipation?: SessionParticipationOmit
    taskParticipation?: TaskParticipationOmit
    attendance?: AttendanceOmit
    attendanceSummary?: AttendanceSummaryOmit
    headsUp?: HeadsUpOmit
    notification?: NotificationOmit
    announcement?: AnnouncementOmit
    fileCategories?: FileCategoriesOmit
    file?: FileOmit
    badges?: BadgesOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    socialLinks: number
    Badges: number
    events: number
    sessions: number
    groups: number
    TasksCreated: number
    AssignedTasks: number
    EventParticipation: number
    SessionParticipation: number
    TaskParticipation: number
    Attendance: number
    HeadsUp: number
    Notification: number
    Announcements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socialLinks?: boolean | UserCountOutputTypeCountSocialLinksArgs
    Badges?: boolean | UserCountOutputTypeCountBadgesArgs
    events?: boolean | UserCountOutputTypeCountEventsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
    TasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
    AssignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    EventParticipation?: boolean | UserCountOutputTypeCountEventParticipationArgs
    SessionParticipation?: boolean | UserCountOutputTypeCountSessionParticipationArgs
    TaskParticipation?: boolean | UserCountOutputTypeCountTaskParticipationArgs
    Attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
    HeadsUp?: boolean | UserCountOutputTypeCountHeadsUpArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
    Announcements?: boolean | UserCountOutputTypeCountAnnouncementsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: socialLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionParticipationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskParticipationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHeadsUpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeadsUpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }


  /**
   * Count Type DivisionsCountOutputType
   */

  export type DivisionsCountOutputType = {
    socialLinks: number
    sessions: number
    groups: number
  }

  export type DivisionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socialLinks?: boolean | DivisionsCountOutputTypeCountSocialLinksArgs
    sessions?: boolean | DivisionsCountOutputTypeCountSessionsArgs
    groups?: boolean | DivisionsCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * DivisionsCountOutputType without action
   */
  export type DivisionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DivisionsCountOutputType
     */
    select?: DivisionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DivisionsCountOutputType without action
   */
  export type DivisionsCountOutputTypeCountSocialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: socialLinkWhereInput
  }

  /**
   * DivisionsCountOutputType without action
   */
  export type DivisionsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionsWhereInput
  }

  /**
   * DivisionsCountOutputType without action
   */
  export type DivisionsCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
  }


  /**
   * Count Type GroupsCountOutputType
   */

  export type GroupsCountOutputType = {
    users: number
    sessions: number
    events: number
  }

  export type GroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | GroupsCountOutputTypeCountUsersArgs
    sessions?: boolean | GroupsCountOutputTypeCountSessionsArgs
    events?: boolean | GroupsCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsCountOutputType
     */
    select?: GroupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionsWhereInput
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }


  /**
   * Count Type EventsCountOutputType
   */

  export type EventsCountOutputType = {
    timeSlots: number
    groups: number
    tasks: number
    participants: number
    attendance: number
  }

  export type EventsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeSlots?: boolean | EventsCountOutputTypeCountTimeSlotsArgs
    groups?: boolean | EventsCountOutputTypeCountGroupsArgs
    tasks?: boolean | EventsCountOutputTypeCountTasksArgs
    participants?: boolean | EventsCountOutputTypeCountParticipantsArgs
    attendance?: boolean | EventsCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsCountOutputType
     */
    select?: EventsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTimeSlotWhereInput
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipationWhereInput
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type SessionsCountOutputType
   */

  export type SessionsCountOutputType = {
    division: number
    timeSlot: number
    targetGroups: number
    tasks: number
    participants: number
    attendance: number
  }

  export type SessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    division?: boolean | SessionsCountOutputTypeCountDivisionArgs
    timeSlot?: boolean | SessionsCountOutputTypeCountTimeSlotArgs
    targetGroups?: boolean | SessionsCountOutputTypeCountTargetGroupsArgs
    tasks?: boolean | SessionsCountOutputTypeCountTasksArgs
    participants?: boolean | SessionsCountOutputTypeCountParticipantsArgs
    attendance?: boolean | SessionsCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionsCountOutputType
     */
    select?: SessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountDivisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionsWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountTimeSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTimeSlotWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountTargetGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionParticipationWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type TasksCountOutputType
   */

  export type TasksCountOutputType = {
    assignedTo: number
    participants: number
  }

  export type TasksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | TasksCountOutputTypeCountAssignedToArgs
    participants?: boolean | TasksCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCountOutputType
     */
    select?: TasksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeCountAssignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskParticipationWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    user: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | NotificationCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AnnouncementCountOutputType
   */

  export type AnnouncementCountOutputType = {
    user: number
  }

  export type AnnouncementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AnnouncementCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementCountOutputType
     */
    select?: AnnouncementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type FileCategoriesCountOutputType
   */

  export type FileCategoriesCountOutputType = {
    files: number
  }

  export type FileCategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | FileCategoriesCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * FileCategoriesCountOutputType without action
   */
  export type FileCategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategoriesCountOutputType
     */
    select?: FileCategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCategoriesCountOutputType without action
   */
  export type FileCategoriesCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type BadgesCountOutputType
   */

  export type BadgesCountOutputType = {
    user: number
  }

  export type BadgesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BadgesCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * BadgesCountOutputType without action
   */
  export type BadgesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgesCountOutputType
     */
    select?: BadgesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgesCountOutputType without action
   */
  export type BadgesCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    password: string | null
    phone_number: string | null
    telegramUserName: string | null
    bio: string | null
    berthDate: Date | null
    profileImageUrl: string | null
    clubStatus: $Enums.ClubStatus | null
    specialty: string | null
    cvUrl: string | null
    lastSeen: Date | null
    role: $Enums.RoleType | null
    createdAt: Date | null
    updatedAt: Date | null
    DivisionId: string | null
    UserSettingId: string | null
    DivisionHeadID: string | null
    AttendanceSummaryId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    password: string | null
    phone_number: string | null
    telegramUserName: string | null
    bio: string | null
    berthDate: Date | null
    profileImageUrl: string | null
    clubStatus: $Enums.ClubStatus | null
    specialty: string | null
    cvUrl: string | null
    lastSeen: Date | null
    role: $Enums.RoleType | null
    createdAt: Date | null
    updatedAt: Date | null
    DivisionId: string | null
    UserSettingId: string | null
    DivisionHeadID: string | null
    AttendanceSummaryId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    email: number
    password: number
    phone_number: number
    telegramUserName: number
    bio: number
    berthDate: number
    profileImageUrl: number
    clubStatus: number
    specialty: number
    cvUrl: number
    lastSeen: number
    role: number
    createdAt: number
    updatedAt: number
    DivisionId: number
    UserSettingId: number
    DivisionHeadID: number
    AttendanceSummaryId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    password?: true
    phone_number?: true
    telegramUserName?: true
    bio?: true
    berthDate?: true
    profileImageUrl?: true
    clubStatus?: true
    specialty?: true
    cvUrl?: true
    lastSeen?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    DivisionId?: true
    UserSettingId?: true
    DivisionHeadID?: true
    AttendanceSummaryId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    password?: true
    phone_number?: true
    telegramUserName?: true
    bio?: true
    berthDate?: true
    profileImageUrl?: true
    clubStatus?: true
    specialty?: true
    cvUrl?: true
    lastSeen?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    DivisionId?: true
    UserSettingId?: true
    DivisionHeadID?: true
    AttendanceSummaryId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    password?: true
    phone_number?: true
    telegramUserName?: true
    bio?: true
    berthDate?: true
    profileImageUrl?: true
    clubStatus?: true
    specialty?: true
    cvUrl?: true
    lastSeen?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    DivisionId?: true
    UserSettingId?: true
    DivisionHeadID?: true
    AttendanceSummaryId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender
    email: string | null
    password: string | null
    phone_number: string | null
    telegramUserName: string | null
    bio: string | null
    berthDate: Date | null
    profileImageUrl: string | null
    clubStatus: $Enums.ClubStatus | null
    specialty: string | null
    cvUrl: string | null
    lastSeen: Date
    role: $Enums.RoleType
    createdAt: Date
    updatedAt: Date
    DivisionId: string | null
    UserSettingId: string | null
    DivisionHeadID: string | null
    AttendanceSummaryId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    telegramUserName?: boolean
    bio?: boolean
    berthDate?: boolean
    profileImageUrl?: boolean
    clubStatus?: boolean
    specialty?: boolean
    cvUrl?: boolean
    lastSeen?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DivisionId?: boolean
    UserSettingId?: boolean
    DivisionHeadID?: boolean
    AttendanceSummaryId?: boolean
    universityInfo?: boolean | User$universityInfoArgs<ExtArgs>
    Divisions?: boolean | User$DivisionsArgs<ExtArgs>
    socialLinks?: boolean | User$socialLinksArgs<ExtArgs>
    UserSetting?: boolean | User$UserSettingArgs<ExtArgs>
    Badges?: boolean | User$BadgesArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    DivisionHead?: boolean | User$DivisionHeadArgs<ExtArgs>
    TasksCreated?: boolean | User$TasksCreatedArgs<ExtArgs>
    AssignedTasks?: boolean | User$AssignedTasksArgs<ExtArgs>
    EventParticipation?: boolean | User$EventParticipationArgs<ExtArgs>
    SessionParticipation?: boolean | User$SessionParticipationArgs<ExtArgs>
    TaskParticipation?: boolean | User$TaskParticipationArgs<ExtArgs>
    Attendance?: boolean | User$AttendanceArgs<ExtArgs>
    AttendanceSummary?: boolean | User$AttendanceSummaryArgs<ExtArgs>
    HeadsUp?: boolean | User$HeadsUpArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    Announcements?: boolean | User$AnnouncementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    telegramUserName?: boolean
    bio?: boolean
    berthDate?: boolean
    profileImageUrl?: boolean
    clubStatus?: boolean
    specialty?: boolean
    cvUrl?: boolean
    lastSeen?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DivisionId?: boolean
    UserSettingId?: boolean
    DivisionHeadID?: boolean
    AttendanceSummaryId?: boolean
    Divisions?: boolean | User$DivisionsArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    telegramUserName?: boolean
    bio?: boolean
    berthDate?: boolean
    profileImageUrl?: boolean
    clubStatus?: boolean
    specialty?: boolean
    cvUrl?: boolean
    lastSeen?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DivisionId?: boolean
    UserSettingId?: boolean
    DivisionHeadID?: boolean
    AttendanceSummaryId?: boolean
    Divisions?: boolean | User$DivisionsArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    telegramUserName?: boolean
    bio?: boolean
    berthDate?: boolean
    profileImageUrl?: boolean
    clubStatus?: boolean
    specialty?: boolean
    cvUrl?: boolean
    lastSeen?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DivisionId?: boolean
    UserSettingId?: boolean
    DivisionHeadID?: boolean
    AttendanceSummaryId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "middleName" | "lastName" | "gender" | "email" | "password" | "phone_number" | "telegramUserName" | "bio" | "berthDate" | "profileImageUrl" | "clubStatus" | "specialty" | "cvUrl" | "lastSeen" | "role" | "createdAt" | "updatedAt" | "DivisionId" | "UserSettingId" | "DivisionHeadID" | "AttendanceSummaryId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    universityInfo?: boolean | User$universityInfoArgs<ExtArgs>
    Divisions?: boolean | User$DivisionsArgs<ExtArgs>
    socialLinks?: boolean | User$socialLinksArgs<ExtArgs>
    UserSetting?: boolean | User$UserSettingArgs<ExtArgs>
    Badges?: boolean | User$BadgesArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    DivisionHead?: boolean | User$DivisionHeadArgs<ExtArgs>
    TasksCreated?: boolean | User$TasksCreatedArgs<ExtArgs>
    AssignedTasks?: boolean | User$AssignedTasksArgs<ExtArgs>
    EventParticipation?: boolean | User$EventParticipationArgs<ExtArgs>
    SessionParticipation?: boolean | User$SessionParticipationArgs<ExtArgs>
    TaskParticipation?: boolean | User$TaskParticipationArgs<ExtArgs>
    Attendance?: boolean | User$AttendanceArgs<ExtArgs>
    AttendanceSummary?: boolean | User$AttendanceSummaryArgs<ExtArgs>
    HeadsUp?: boolean | User$HeadsUpArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    Announcements?: boolean | User$AnnouncementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Divisions?: boolean | User$DivisionsArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Divisions?: boolean | User$DivisionsArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      universityInfo: Prisma.$UniversityInfoPayload<ExtArgs> | null
      Divisions: Prisma.$DivisionsPayload<ExtArgs> | null
      socialLinks: Prisma.$socialLinkPayload<ExtArgs>[]
      UserSetting: Prisma.$UserSettingPayload<ExtArgs> | null
      Badges: Prisma.$BadgesPayload<ExtArgs>[]
      events: Prisma.$EventsPayload<ExtArgs>[]
      sessions: Prisma.$SessionsPayload<ExtArgs>[]
      groups: Prisma.$GroupsPayload<ExtArgs>[]
      DivisionHead: Prisma.$DivisionsPayload<ExtArgs> | null
      TasksCreated: Prisma.$TasksPayload<ExtArgs>[]
      AssignedTasks: Prisma.$TasksPayload<ExtArgs>[]
      EventParticipation: Prisma.$EventParticipationPayload<ExtArgs>[]
      SessionParticipation: Prisma.$SessionParticipationPayload<ExtArgs>[]
      TaskParticipation: Prisma.$TaskParticipationPayload<ExtArgs>[]
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
      AttendanceSummary: Prisma.$AttendanceSummaryPayload<ExtArgs> | null
      HeadsUp: Prisma.$HeadsUpPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      Announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      middleName: string | null
      lastName: string | null
      gender: $Enums.Gender
      email: string | null
      password: string | null
      phone_number: string | null
      telegramUserName: string | null
      bio: string | null
      berthDate: Date | null
      profileImageUrl: string | null
      clubStatus: $Enums.ClubStatus | null
      specialty: string | null
      cvUrl: string | null
      lastSeen: Date
      role: $Enums.RoleType
      createdAt: Date
      updatedAt: Date
      DivisionId: string | null
      UserSettingId: string | null
      DivisionHeadID: string | null
      AttendanceSummaryId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    universityInfo<T extends User$universityInfoArgs<ExtArgs> = {}>(args?: Subset<T, User$universityInfoArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Divisions<T extends User$DivisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$DivisionsArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    socialLinks<T extends User$socialLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$socialLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserSetting<T extends User$UserSettingArgs<ExtArgs> = {}>(args?: Subset<T, User$UserSettingArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Badges<T extends User$BadgesArgs<ExtArgs> = {}>(args?: Subset<T, User$BadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends User$groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DivisionHead<T extends User$DivisionHeadArgs<ExtArgs> = {}>(args?: Subset<T, User$DivisionHeadArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TasksCreated<T extends User$TasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$TasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AssignedTasks<T extends User$AssignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$AssignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EventParticipation<T extends User$EventParticipationArgs<ExtArgs> = {}>(args?: Subset<T, User$EventParticipationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SessionParticipation<T extends User$SessionParticipationArgs<ExtArgs> = {}>(args?: Subset<T, User$SessionParticipationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TaskParticipation<T extends User$TaskParticipationArgs<ExtArgs> = {}>(args?: Subset<T, User$TaskParticipationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Attendance<T extends User$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AttendanceSummary<T extends User$AttendanceSummaryArgs<ExtArgs> = {}>(args?: Subset<T, User$AttendanceSummaryArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    HeadsUp<T extends User$HeadsUpArgs<ExtArgs> = {}>(args?: Subset<T, User$HeadsUpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Announcements<T extends User$AnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, User$AnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly middleName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly telegramUserName: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly berthDate: FieldRef<"User", 'DateTime'>
    readonly profileImageUrl: FieldRef<"User", 'String'>
    readonly clubStatus: FieldRef<"User", 'ClubStatus'>
    readonly specialty: FieldRef<"User", 'String'>
    readonly cvUrl: FieldRef<"User", 'String'>
    readonly lastSeen: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'RoleType'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly DivisionId: FieldRef<"User", 'String'>
    readonly UserSettingId: FieldRef<"User", 'String'>
    readonly DivisionHeadID: FieldRef<"User", 'String'>
    readonly AttendanceSummaryId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.universityInfo
   */
  export type User$universityInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    where?: UniversityInfoWhereInput
  }

  /**
   * User.Divisions
   */
  export type User$DivisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    where?: DivisionsWhereInput
  }

  /**
   * User.socialLinks
   */
  export type User$socialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    where?: socialLinkWhereInput
    orderBy?: socialLinkOrderByWithRelationInput | socialLinkOrderByWithRelationInput[]
    cursor?: socialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * User.UserSetting
   */
  export type User$UserSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    where?: UserSettingWhereInput
  }

  /**
   * User.Badges
   */
  export type User$BadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    where?: BadgesWhereInput
    orderBy?: BadgesOrderByWithRelationInput | BadgesOrderByWithRelationInput[]
    cursor?: BadgesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    where?: SessionsWhereInput
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    cursor?: SessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * User.groups
   */
  export type User$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    cursor?: GroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * User.DivisionHead
   */
  export type User$DivisionHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    where?: DivisionsWhereInput
  }

  /**
   * User.TasksCreated
   */
  export type User$TasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    cursor?: TasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * User.AssignedTasks
   */
  export type User$AssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    cursor?: TasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * User.EventParticipation
   */
  export type User$EventParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    where?: EventParticipationWhereInput
    orderBy?: EventParticipationOrderByWithRelationInput | EventParticipationOrderByWithRelationInput[]
    cursor?: EventParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipationScalarFieldEnum | EventParticipationScalarFieldEnum[]
  }

  /**
   * User.SessionParticipation
   */
  export type User$SessionParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    where?: SessionParticipationWhereInput
    orderBy?: SessionParticipationOrderByWithRelationInput | SessionParticipationOrderByWithRelationInput[]
    cursor?: SessionParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionParticipationScalarFieldEnum | SessionParticipationScalarFieldEnum[]
  }

  /**
   * User.TaskParticipation
   */
  export type User$TaskParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    where?: TaskParticipationWhereInput
    orderBy?: TaskParticipationOrderByWithRelationInput | TaskParticipationOrderByWithRelationInput[]
    cursor?: TaskParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskParticipationScalarFieldEnum | TaskParticipationScalarFieldEnum[]
  }

  /**
   * User.Attendance
   */
  export type User$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.AttendanceSummary
   */
  export type User$AttendanceSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
  }

  /**
   * User.HeadsUp
   */
  export type User$HeadsUpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    where?: HeadsUpWhereInput
    orderBy?: HeadsUpOrderByWithRelationInput | HeadsUpOrderByWithRelationInput[]
    cursor?: HeadsUpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HeadsUpScalarFieldEnum | HeadsUpScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.Announcements
   */
  export type User$AnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UniversityInfo
   */

  export type AggregateUniversityInfo = {
    _count: UniversityInfoCountAggregateOutputType | null
    _avg: UniversityInfoAvgAggregateOutputType | null
    _sum: UniversityInfoSumAggregateOutputType | null
    _min: UniversityInfoMinAggregateOutputType | null
    _max: UniversityInfoMaxAggregateOutputType | null
  }

  export type UniversityInfoAvgAggregateOutputType = {
    currentYear: number | null
    expectedGraduationYear: number | null
  }

  export type UniversityInfoSumAggregateOutputType = {
    currentYear: number | null
    expectedGraduationYear: number | null
  }

  export type UniversityInfoMinAggregateOutputType = {
    id: string | null
    currentYear: number | null
    expectedGraduationYear: number | null
    major: string | null
    universityId: string | null
    status: $Enums.UniversityStatus | null
    department: string | null
    userId: string | null
  }

  export type UniversityInfoMaxAggregateOutputType = {
    id: string | null
    currentYear: number | null
    expectedGraduationYear: number | null
    major: string | null
    universityId: string | null
    status: $Enums.UniversityStatus | null
    department: string | null
    userId: string | null
  }

  export type UniversityInfoCountAggregateOutputType = {
    id: number
    currentYear: number
    expectedGraduationYear: number
    major: number
    universityId: number
    status: number
    department: number
    userId: number
    _all: number
  }


  export type UniversityInfoAvgAggregateInputType = {
    currentYear?: true
    expectedGraduationYear?: true
  }

  export type UniversityInfoSumAggregateInputType = {
    currentYear?: true
    expectedGraduationYear?: true
  }

  export type UniversityInfoMinAggregateInputType = {
    id?: true
    currentYear?: true
    expectedGraduationYear?: true
    major?: true
    universityId?: true
    status?: true
    department?: true
    userId?: true
  }

  export type UniversityInfoMaxAggregateInputType = {
    id?: true
    currentYear?: true
    expectedGraduationYear?: true
    major?: true
    universityId?: true
    status?: true
    department?: true
    userId?: true
  }

  export type UniversityInfoCountAggregateInputType = {
    id?: true
    currentYear?: true
    expectedGraduationYear?: true
    major?: true
    universityId?: true
    status?: true
    department?: true
    userId?: true
    _all?: true
  }

  export type UniversityInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityInfo to aggregate.
     */
    where?: UniversityInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityInfos to fetch.
     */
    orderBy?: UniversityInfoOrderByWithRelationInput | UniversityInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UniversityInfos
    **/
    _count?: true | UniversityInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversityInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityInfoMaxAggregateInputType
  }

  export type GetUniversityInfoAggregateType<T extends UniversityInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversityInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversityInfo[P]>
      : GetScalarType<T[P], AggregateUniversityInfo[P]>
  }




  export type UniversityInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityInfoWhereInput
    orderBy?: UniversityInfoOrderByWithAggregationInput | UniversityInfoOrderByWithAggregationInput[]
    by: UniversityInfoScalarFieldEnum[] | UniversityInfoScalarFieldEnum
    having?: UniversityInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityInfoCountAggregateInputType | true
    _avg?: UniversityInfoAvgAggregateInputType
    _sum?: UniversityInfoSumAggregateInputType
    _min?: UniversityInfoMinAggregateInputType
    _max?: UniversityInfoMaxAggregateInputType
  }

  export type UniversityInfoGroupByOutputType = {
    id: string
    currentYear: number | null
    expectedGraduationYear: number | null
    major: string | null
    universityId: string | null
    status: $Enums.UniversityStatus
    department: string | null
    userId: string | null
    _count: UniversityInfoCountAggregateOutputType | null
    _avg: UniversityInfoAvgAggregateOutputType | null
    _sum: UniversityInfoSumAggregateOutputType | null
    _min: UniversityInfoMinAggregateOutputType | null
    _max: UniversityInfoMaxAggregateOutputType | null
  }

  type GetUniversityInfoGroupByPayload<T extends UniversityInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniversityInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityInfoGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityInfoGroupByOutputType[P]>
        }
      >
    >


  export type UniversityInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentYear?: boolean
    expectedGraduationYear?: boolean
    major?: boolean
    universityId?: boolean
    status?: boolean
    department?: boolean
    userId?: boolean
    user?: boolean | UniversityInfo$userArgs<ExtArgs>
  }, ExtArgs["result"]["universityInfo"]>

  export type UniversityInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentYear?: boolean
    expectedGraduationYear?: boolean
    major?: boolean
    universityId?: boolean
    status?: boolean
    department?: boolean
    userId?: boolean
    user?: boolean | UniversityInfo$userArgs<ExtArgs>
  }, ExtArgs["result"]["universityInfo"]>

  export type UniversityInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentYear?: boolean
    expectedGraduationYear?: boolean
    major?: boolean
    universityId?: boolean
    status?: boolean
    department?: boolean
    userId?: boolean
    user?: boolean | UniversityInfo$userArgs<ExtArgs>
  }, ExtArgs["result"]["universityInfo"]>

  export type UniversityInfoSelectScalar = {
    id?: boolean
    currentYear?: boolean
    expectedGraduationYear?: boolean
    major?: boolean
    universityId?: boolean
    status?: boolean
    department?: boolean
    userId?: boolean
  }

  export type UniversityInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currentYear" | "expectedGraduationYear" | "major" | "universityId" | "status" | "department" | "userId", ExtArgs["result"]["universityInfo"]>
  export type UniversityInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UniversityInfo$userArgs<ExtArgs>
  }
  export type UniversityInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UniversityInfo$userArgs<ExtArgs>
  }
  export type UniversityInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UniversityInfo$userArgs<ExtArgs>
  }

  export type $UniversityInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UniversityInfo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currentYear: number | null
      expectedGraduationYear: number | null
      major: string | null
      universityId: string | null
      status: $Enums.UniversityStatus
      department: string | null
      userId: string | null
    }, ExtArgs["result"]["universityInfo"]>
    composites: {}
  }

  type UniversityInfoGetPayload<S extends boolean | null | undefined | UniversityInfoDefaultArgs> = $Result.GetResult<Prisma.$UniversityInfoPayload, S>

  type UniversityInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UniversityInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UniversityInfoCountAggregateInputType | true
    }

  export interface UniversityInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UniversityInfo'], meta: { name: 'UniversityInfo' } }
    /**
     * Find zero or one UniversityInfo that matches the filter.
     * @param {UniversityInfoFindUniqueArgs} args - Arguments to find a UniversityInfo
     * @example
     * // Get one UniversityInfo
     * const universityInfo = await prisma.universityInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UniversityInfoFindUniqueArgs>(args: SelectSubset<T, UniversityInfoFindUniqueArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UniversityInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UniversityInfoFindUniqueOrThrowArgs} args - Arguments to find a UniversityInfo
     * @example
     * // Get one UniversityInfo
     * const universityInfo = await prisma.universityInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UniversityInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, UniversityInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UniversityInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoFindFirstArgs} args - Arguments to find a UniversityInfo
     * @example
     * // Get one UniversityInfo
     * const universityInfo = await prisma.universityInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UniversityInfoFindFirstArgs>(args?: SelectSubset<T, UniversityInfoFindFirstArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UniversityInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoFindFirstOrThrowArgs} args - Arguments to find a UniversityInfo
     * @example
     * // Get one UniversityInfo
     * const universityInfo = await prisma.universityInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UniversityInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, UniversityInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UniversityInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UniversityInfos
     * const universityInfos = await prisma.universityInfo.findMany()
     * 
     * // Get first 10 UniversityInfos
     * const universityInfos = await prisma.universityInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityInfoWithIdOnly = await prisma.universityInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UniversityInfoFindManyArgs>(args?: SelectSubset<T, UniversityInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UniversityInfo.
     * @param {UniversityInfoCreateArgs} args - Arguments to create a UniversityInfo.
     * @example
     * // Create one UniversityInfo
     * const UniversityInfo = await prisma.universityInfo.create({
     *   data: {
     *     // ... data to create a UniversityInfo
     *   }
     * })
     * 
     */
    create<T extends UniversityInfoCreateArgs>(args: SelectSubset<T, UniversityInfoCreateArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UniversityInfos.
     * @param {UniversityInfoCreateManyArgs} args - Arguments to create many UniversityInfos.
     * @example
     * // Create many UniversityInfos
     * const universityInfo = await prisma.universityInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UniversityInfoCreateManyArgs>(args?: SelectSubset<T, UniversityInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UniversityInfos and returns the data saved in the database.
     * @param {UniversityInfoCreateManyAndReturnArgs} args - Arguments to create many UniversityInfos.
     * @example
     * // Create many UniversityInfos
     * const universityInfo = await prisma.universityInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UniversityInfos and only return the `id`
     * const universityInfoWithIdOnly = await prisma.universityInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UniversityInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, UniversityInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UniversityInfo.
     * @param {UniversityInfoDeleteArgs} args - Arguments to delete one UniversityInfo.
     * @example
     * // Delete one UniversityInfo
     * const UniversityInfo = await prisma.universityInfo.delete({
     *   where: {
     *     // ... filter to delete one UniversityInfo
     *   }
     * })
     * 
     */
    delete<T extends UniversityInfoDeleteArgs>(args: SelectSubset<T, UniversityInfoDeleteArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UniversityInfo.
     * @param {UniversityInfoUpdateArgs} args - Arguments to update one UniversityInfo.
     * @example
     * // Update one UniversityInfo
     * const universityInfo = await prisma.universityInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UniversityInfoUpdateArgs>(args: SelectSubset<T, UniversityInfoUpdateArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UniversityInfos.
     * @param {UniversityInfoDeleteManyArgs} args - Arguments to filter UniversityInfos to delete.
     * @example
     * // Delete a few UniversityInfos
     * const { count } = await prisma.universityInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UniversityInfoDeleteManyArgs>(args?: SelectSubset<T, UniversityInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UniversityInfos
     * const universityInfo = await prisma.universityInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UniversityInfoUpdateManyArgs>(args: SelectSubset<T, UniversityInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityInfos and returns the data updated in the database.
     * @param {UniversityInfoUpdateManyAndReturnArgs} args - Arguments to update many UniversityInfos.
     * @example
     * // Update many UniversityInfos
     * const universityInfo = await prisma.universityInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UniversityInfos and only return the `id`
     * const universityInfoWithIdOnly = await prisma.universityInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UniversityInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, UniversityInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UniversityInfo.
     * @param {UniversityInfoUpsertArgs} args - Arguments to update or create a UniversityInfo.
     * @example
     * // Update or create a UniversityInfo
     * const universityInfo = await prisma.universityInfo.upsert({
     *   create: {
     *     // ... data to create a UniversityInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UniversityInfo we want to update
     *   }
     * })
     */
    upsert<T extends UniversityInfoUpsertArgs>(args: SelectSubset<T, UniversityInfoUpsertArgs<ExtArgs>>): Prisma__UniversityInfoClient<$Result.GetResult<Prisma.$UniversityInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UniversityInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoCountArgs} args - Arguments to filter UniversityInfos to count.
     * @example
     * // Count the number of UniversityInfos
     * const count = await prisma.universityInfo.count({
     *   where: {
     *     // ... the filter for the UniversityInfos we want to count
     *   }
     * })
    **/
    count<T extends UniversityInfoCountArgs>(
      args?: Subset<T, UniversityInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UniversityInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityInfoAggregateArgs>(args: Subset<T, UniversityInfoAggregateArgs>): Prisma.PrismaPromise<GetUniversityInfoAggregateType<T>>

    /**
     * Group by UniversityInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityInfoGroupByArgs['orderBy'] }
        : { orderBy?: UniversityInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UniversityInfo model
   */
  readonly fields: UniversityInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UniversityInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UniversityInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UniversityInfo$userArgs<ExtArgs> = {}>(args?: Subset<T, UniversityInfo$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UniversityInfo model
   */
  interface UniversityInfoFieldRefs {
    readonly id: FieldRef<"UniversityInfo", 'String'>
    readonly currentYear: FieldRef<"UniversityInfo", 'Int'>
    readonly expectedGraduationYear: FieldRef<"UniversityInfo", 'Int'>
    readonly major: FieldRef<"UniversityInfo", 'String'>
    readonly universityId: FieldRef<"UniversityInfo", 'String'>
    readonly status: FieldRef<"UniversityInfo", 'UniversityStatus'>
    readonly department: FieldRef<"UniversityInfo", 'String'>
    readonly userId: FieldRef<"UniversityInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UniversityInfo findUnique
   */
  export type UniversityInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * Filter, which UniversityInfo to fetch.
     */
    where: UniversityInfoWhereUniqueInput
  }

  /**
   * UniversityInfo findUniqueOrThrow
   */
  export type UniversityInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * Filter, which UniversityInfo to fetch.
     */
    where: UniversityInfoWhereUniqueInput
  }

  /**
   * UniversityInfo findFirst
   */
  export type UniversityInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * Filter, which UniversityInfo to fetch.
     */
    where?: UniversityInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityInfos to fetch.
     */
    orderBy?: UniversityInfoOrderByWithRelationInput | UniversityInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityInfos.
     */
    cursor?: UniversityInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityInfos.
     */
    distinct?: UniversityInfoScalarFieldEnum | UniversityInfoScalarFieldEnum[]
  }

  /**
   * UniversityInfo findFirstOrThrow
   */
  export type UniversityInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * Filter, which UniversityInfo to fetch.
     */
    where?: UniversityInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityInfos to fetch.
     */
    orderBy?: UniversityInfoOrderByWithRelationInput | UniversityInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityInfos.
     */
    cursor?: UniversityInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityInfos.
     */
    distinct?: UniversityInfoScalarFieldEnum | UniversityInfoScalarFieldEnum[]
  }

  /**
   * UniversityInfo findMany
   */
  export type UniversityInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * Filter, which UniversityInfos to fetch.
     */
    where?: UniversityInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityInfos to fetch.
     */
    orderBy?: UniversityInfoOrderByWithRelationInput | UniversityInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UniversityInfos.
     */
    cursor?: UniversityInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityInfos.
     */
    skip?: number
    distinct?: UniversityInfoScalarFieldEnum | UniversityInfoScalarFieldEnum[]
  }

  /**
   * UniversityInfo create
   */
  export type UniversityInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a UniversityInfo.
     */
    data: XOR<UniversityInfoCreateInput, UniversityInfoUncheckedCreateInput>
  }

  /**
   * UniversityInfo createMany
   */
  export type UniversityInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UniversityInfos.
     */
    data: UniversityInfoCreateManyInput | UniversityInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UniversityInfo createManyAndReturn
   */
  export type UniversityInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * The data used to create many UniversityInfos.
     */
    data: UniversityInfoCreateManyInput | UniversityInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UniversityInfo update
   */
  export type UniversityInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a UniversityInfo.
     */
    data: XOR<UniversityInfoUpdateInput, UniversityInfoUncheckedUpdateInput>
    /**
     * Choose, which UniversityInfo to update.
     */
    where: UniversityInfoWhereUniqueInput
  }

  /**
   * UniversityInfo updateMany
   */
  export type UniversityInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UniversityInfos.
     */
    data: XOR<UniversityInfoUpdateManyMutationInput, UniversityInfoUncheckedUpdateManyInput>
    /**
     * Filter which UniversityInfos to update
     */
    where?: UniversityInfoWhereInput
    /**
     * Limit how many UniversityInfos to update.
     */
    limit?: number
  }

  /**
   * UniversityInfo updateManyAndReturn
   */
  export type UniversityInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * The data used to update UniversityInfos.
     */
    data: XOR<UniversityInfoUpdateManyMutationInput, UniversityInfoUncheckedUpdateManyInput>
    /**
     * Filter which UniversityInfos to update
     */
    where?: UniversityInfoWhereInput
    /**
     * Limit how many UniversityInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UniversityInfo upsert
   */
  export type UniversityInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the UniversityInfo to update in case it exists.
     */
    where: UniversityInfoWhereUniqueInput
    /**
     * In case the UniversityInfo found by the `where` argument doesn't exist, create a new UniversityInfo with this data.
     */
    create: XOR<UniversityInfoCreateInput, UniversityInfoUncheckedCreateInput>
    /**
     * In case the UniversityInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityInfoUpdateInput, UniversityInfoUncheckedUpdateInput>
  }

  /**
   * UniversityInfo delete
   */
  export type UniversityInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
    /**
     * Filter which UniversityInfo to delete.
     */
    where: UniversityInfoWhereUniqueInput
  }

  /**
   * UniversityInfo deleteMany
   */
  export type UniversityInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityInfos to delete
     */
    where?: UniversityInfoWhereInput
    /**
     * Limit how many UniversityInfos to delete.
     */
    limit?: number
  }

  /**
   * UniversityInfo.user
   */
  export type UniversityInfo$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UniversityInfo without action
   */
  export type UniversityInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityInfo
     */
    select?: UniversityInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityInfo
     */
    omit?: UniversityInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInfoInclude<ExtArgs> | null
  }


  /**
   * Model UserSetting
   */

  export type AggregateUserSetting = {
    _count: UserSettingCountAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  export type UserSettingMinAggregateOutputType = {
    id: string | null
    theme: $Enums.Theme | null
    phonePublic: boolean | null
    authUpdateCalendar: boolean | null
    userId: string | null
  }

  export type UserSettingMaxAggregateOutputType = {
    id: string | null
    theme: $Enums.Theme | null
    phonePublic: boolean | null
    authUpdateCalendar: boolean | null
    userId: string | null
  }

  export type UserSettingCountAggregateOutputType = {
    id: number
    theme: number
    phonePublic: number
    authUpdateCalendar: number
    userId: number
    _all: number
  }


  export type UserSettingMinAggregateInputType = {
    id?: true
    theme?: true
    phonePublic?: true
    authUpdateCalendar?: true
    userId?: true
  }

  export type UserSettingMaxAggregateInputType = {
    id?: true
    theme?: true
    phonePublic?: true
    authUpdateCalendar?: true
    userId?: true
  }

  export type UserSettingCountAggregateInputType = {
    id?: true
    theme?: true
    phonePublic?: true
    authUpdateCalendar?: true
    userId?: true
    _all?: true
  }

  export type UserSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSetting to aggregate.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingMaxAggregateInputType
  }

  export type GetUserSettingAggregateType<T extends UserSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSetting[P]>
      : GetScalarType<T[P], AggregateUserSetting[P]>
  }




  export type UserSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithAggregationInput | UserSettingOrderByWithAggregationInput[]
    by: UserSettingScalarFieldEnum[] | UserSettingScalarFieldEnum
    having?: UserSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingCountAggregateInputType | true
    _min?: UserSettingMinAggregateInputType
    _max?: UserSettingMaxAggregateInputType
  }

  export type UserSettingGroupByOutputType = {
    id: string
    theme: $Enums.Theme
    phonePublic: boolean
    authUpdateCalendar: boolean
    userId: string
    _count: UserSettingCountAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  type GetUserSettingGroupByPayload<T extends UserSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    theme?: boolean
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectScalar = {
    id?: boolean
    theme?: boolean
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    userId?: boolean
  }

  export type UserSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "theme" | "phonePublic" | "authUpdateCalendar" | "userId", ExtArgs["result"]["userSetting"]>
  export type UserSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSetting"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      theme: $Enums.Theme
      phonePublic: boolean
      authUpdateCalendar: boolean
      userId: string
    }, ExtArgs["result"]["userSetting"]>
    composites: {}
  }

  type UserSettingGetPayload<S extends boolean | null | undefined | UserSettingDefaultArgs> = $Result.GetResult<Prisma.$UserSettingPayload, S>

  type UserSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingCountAggregateInputType | true
    }

  export interface UserSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSetting'], meta: { name: 'UserSetting' } }
    /**
     * Find zero or one UserSetting that matches the filter.
     * @param {UserSettingFindUniqueArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingFindUniqueArgs>(args: SelectSubset<T, UserSettingFindUniqueArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingFindUniqueOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingFindFirstArgs>(args?: SelectSubset<T, UserSettingFindFirstArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSetting.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingFindManyArgs>(args?: SelectSubset<T, UserSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSetting.
     * @param {UserSettingCreateArgs} args - Arguments to create a UserSetting.
     * @example
     * // Create one UserSetting
     * const UserSetting = await prisma.userSetting.create({
     *   data: {
     *     // ... data to create a UserSetting
     *   }
     * })
     * 
     */
    create<T extends UserSettingCreateArgs>(args: SelectSubset<T, UserSettingCreateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingCreateManyArgs>(args?: SelectSubset<T, UserSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSetting.
     * @param {UserSettingDeleteArgs} args - Arguments to delete one UserSetting.
     * @example
     * // Delete one UserSetting
     * const UserSetting = await prisma.userSetting.delete({
     *   where: {
     *     // ... filter to delete one UserSetting
     *   }
     * })
     * 
     */
    delete<T extends UserSettingDeleteArgs>(args: SelectSubset<T, UserSettingDeleteArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSetting.
     * @param {UserSettingUpdateArgs} args - Arguments to update one UserSetting.
     * @example
     * // Update one UserSetting
     * const userSetting = await prisma.userSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingUpdateArgs>(args: SelectSubset<T, UserSettingUpdateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingDeleteManyArgs>(args?: SelectSubset<T, UserSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSetting = await prisma.userSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingUpdateManyArgs>(args: SelectSubset<T, UserSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSetting = await prisma.userSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSetting.
     * @param {UserSettingUpsertArgs} args - Arguments to update or create a UserSetting.
     * @example
     * // Update or create a UserSetting
     * const userSetting = await prisma.userSetting.upsert({
     *   create: {
     *     // ... data to create a UserSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSetting we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingUpsertArgs>(args: SelectSubset<T, UserSettingUpsertArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSetting.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingCountArgs>(
      args?: Subset<T, UserSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingAggregateArgs>(args: Subset<T, UserSettingAggregateArgs>): Prisma.PrismaPromise<GetUserSettingAggregateType<T>>

    /**
     * Group by UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSetting model
   */
  readonly fields: UserSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSetting model
   */
  interface UserSettingFieldRefs {
    readonly id: FieldRef<"UserSetting", 'String'>
    readonly theme: FieldRef<"UserSetting", 'Theme'>
    readonly phonePublic: FieldRef<"UserSetting", 'Boolean'>
    readonly authUpdateCalendar: FieldRef<"UserSetting", 'Boolean'>
    readonly userId: FieldRef<"UserSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSetting findUnique
   */
  export type UserSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findUniqueOrThrow
   */
  export type UserSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findFirst
   */
  export type UserSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findFirstOrThrow
   */
  export type UserSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findMany
   */
  export type UserSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting create
   */
  export type UserSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSetting.
     */
    data: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
  }

  /**
   * UserSetting createMany
   */
  export type UserSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSetting createManyAndReturn
   */
  export type UserSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSetting update
   */
  export type UserSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSetting.
     */
    data: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
    /**
     * Choose, which UserSetting to update.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting updateMany
   */
  export type UserSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSetting updateManyAndReturn
   */
  export type UserSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSetting upsert
   */
  export type UserSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSetting to update in case it exists.
     */
    where: UserSettingWhereUniqueInput
    /**
     * In case the UserSetting found by the `where` argument doesn't exist, create a new UserSetting with this data.
     */
    create: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
    /**
     * In case the UserSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
  }

  /**
   * UserSetting delete
   */
  export type UserSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter which UserSetting to delete.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting deleteMany
   */
  export type UserSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSetting without action
   */
  export type UserSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
  }


  /**
   * Model Divisions
   */

  export type AggregateDivisions = {
    _count: DivisionsCountAggregateOutputType | null
    _min: DivisionsMinAggregateOutputType | null
    _max: DivisionsMaxAggregateOutputType | null
  }

  export type DivisionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    establishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    currentHeadID: string | null
  }

  export type DivisionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    establishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    currentHeadID: string | null
  }

  export type DivisionsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    establishedAt: number
    createdAt: number
    updatedAt: number
    currentHeadID: number
    _all: number
  }


  export type DivisionsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    establishedAt?: true
    createdAt?: true
    updatedAt?: true
    currentHeadID?: true
  }

  export type DivisionsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    establishedAt?: true
    createdAt?: true
    updatedAt?: true
    currentHeadID?: true
  }

  export type DivisionsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    establishedAt?: true
    createdAt?: true
    updatedAt?: true
    currentHeadID?: true
    _all?: true
  }

  export type DivisionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Divisions to aggregate.
     */
    where?: DivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionsOrderByWithRelationInput | DivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Divisions
    **/
    _count?: true | DivisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisionsMaxAggregateInputType
  }

  export type GetDivisionsAggregateType<T extends DivisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDivisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivisions[P]>
      : GetScalarType<T[P], AggregateDivisions[P]>
  }




  export type DivisionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionsWhereInput
    orderBy?: DivisionsOrderByWithAggregationInput | DivisionsOrderByWithAggregationInput[]
    by: DivisionsScalarFieldEnum[] | DivisionsScalarFieldEnum
    having?: DivisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisionsCountAggregateInputType | true
    _min?: DivisionsMinAggregateInputType
    _max?: DivisionsMaxAggregateInputType
  }

  export type DivisionsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    establishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    currentHeadID: string | null
    _count: DivisionsCountAggregateOutputType | null
    _min: DivisionsMinAggregateOutputType | null
    _max: DivisionsMaxAggregateOutputType | null
  }

  type GetDivisionsGroupByPayload<T extends DivisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DivisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisionsGroupByOutputType[P]>
            : GetScalarType<T[P], DivisionsGroupByOutputType[P]>
        }
      >
    >


  export type DivisionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    establishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHeadID?: boolean
    currentHead?: boolean | Divisions$currentHeadArgs<ExtArgs>
    user?: boolean | Divisions$userArgs<ExtArgs>
    socialLinks?: boolean | Divisions$socialLinksArgs<ExtArgs>
    sessions?: boolean | Divisions$sessionsArgs<ExtArgs>
    groups?: boolean | Divisions$groupsArgs<ExtArgs>
    _count?: boolean | DivisionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["divisions"]>

  export type DivisionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    establishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHeadID?: boolean
    currentHead?: boolean | Divisions$currentHeadArgs<ExtArgs>
  }, ExtArgs["result"]["divisions"]>

  export type DivisionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    establishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHeadID?: boolean
    currentHead?: boolean | Divisions$currentHeadArgs<ExtArgs>
  }, ExtArgs["result"]["divisions"]>

  export type DivisionsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    establishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentHeadID?: boolean
  }

  export type DivisionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "establishedAt" | "createdAt" | "updatedAt" | "currentHeadID", ExtArgs["result"]["divisions"]>
  export type DivisionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentHead?: boolean | Divisions$currentHeadArgs<ExtArgs>
    user?: boolean | Divisions$userArgs<ExtArgs>
    socialLinks?: boolean | Divisions$socialLinksArgs<ExtArgs>
    sessions?: boolean | Divisions$sessionsArgs<ExtArgs>
    groups?: boolean | Divisions$groupsArgs<ExtArgs>
    _count?: boolean | DivisionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DivisionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentHead?: boolean | Divisions$currentHeadArgs<ExtArgs>
  }
  export type DivisionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentHead?: boolean | Divisions$currentHeadArgs<ExtArgs>
  }

  export type $DivisionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Divisions"
    objects: {
      currentHead: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      socialLinks: Prisma.$socialLinkPayload<ExtArgs>[]
      sessions: Prisma.$SessionsPayload<ExtArgs>[]
      groups: Prisma.$GroupsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      establishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      currentHeadID: string | null
    }, ExtArgs["result"]["divisions"]>
    composites: {}
  }

  type DivisionsGetPayload<S extends boolean | null | undefined | DivisionsDefaultArgs> = $Result.GetResult<Prisma.$DivisionsPayload, S>

  type DivisionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DivisionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DivisionsCountAggregateInputType | true
    }

  export interface DivisionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Divisions'], meta: { name: 'Divisions' } }
    /**
     * Find zero or one Divisions that matches the filter.
     * @param {DivisionsFindUniqueArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DivisionsFindUniqueArgs>(args: SelectSubset<T, DivisionsFindUniqueArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Divisions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DivisionsFindUniqueOrThrowArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DivisionsFindUniqueOrThrowArgs>(args: SelectSubset<T, DivisionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsFindFirstArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DivisionsFindFirstArgs>(args?: SelectSubset<T, DivisionsFindFirstArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Divisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsFindFirstOrThrowArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DivisionsFindFirstOrThrowArgs>(args?: SelectSubset<T, DivisionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisions
     * const divisions = await prisma.divisions.findMany()
     * 
     * // Get first 10 Divisions
     * const divisions = await prisma.divisions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const divisionsWithIdOnly = await prisma.divisions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DivisionsFindManyArgs>(args?: SelectSubset<T, DivisionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Divisions.
     * @param {DivisionsCreateArgs} args - Arguments to create a Divisions.
     * @example
     * // Create one Divisions
     * const Divisions = await prisma.divisions.create({
     *   data: {
     *     // ... data to create a Divisions
     *   }
     * })
     * 
     */
    create<T extends DivisionsCreateArgs>(args: SelectSubset<T, DivisionsCreateArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Divisions.
     * @param {DivisionsCreateManyArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const divisions = await prisma.divisions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DivisionsCreateManyArgs>(args?: SelectSubset<T, DivisionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Divisions and returns the data saved in the database.
     * @param {DivisionsCreateManyAndReturnArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const divisions = await prisma.divisions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Divisions and only return the `id`
     * const divisionsWithIdOnly = await prisma.divisions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DivisionsCreateManyAndReturnArgs>(args?: SelectSubset<T, DivisionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Divisions.
     * @param {DivisionsDeleteArgs} args - Arguments to delete one Divisions.
     * @example
     * // Delete one Divisions
     * const Divisions = await prisma.divisions.delete({
     *   where: {
     *     // ... filter to delete one Divisions
     *   }
     * })
     * 
     */
    delete<T extends DivisionsDeleteArgs>(args: SelectSubset<T, DivisionsDeleteArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Divisions.
     * @param {DivisionsUpdateArgs} args - Arguments to update one Divisions.
     * @example
     * // Update one Divisions
     * const divisions = await prisma.divisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DivisionsUpdateArgs>(args: SelectSubset<T, DivisionsUpdateArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Divisions.
     * @param {DivisionsDeleteManyArgs} args - Arguments to filter Divisions to delete.
     * @example
     * // Delete a few Divisions
     * const { count } = await prisma.divisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DivisionsDeleteManyArgs>(args?: SelectSubset<T, DivisionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisions
     * const divisions = await prisma.divisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DivisionsUpdateManyArgs>(args: SelectSubset<T, DivisionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions and returns the data updated in the database.
     * @param {DivisionsUpdateManyAndReturnArgs} args - Arguments to update many Divisions.
     * @example
     * // Update many Divisions
     * const divisions = await prisma.divisions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Divisions and only return the `id`
     * const divisionsWithIdOnly = await prisma.divisions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DivisionsUpdateManyAndReturnArgs>(args: SelectSubset<T, DivisionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Divisions.
     * @param {DivisionsUpsertArgs} args - Arguments to update or create a Divisions.
     * @example
     * // Update or create a Divisions
     * const divisions = await prisma.divisions.upsert({
     *   create: {
     *     // ... data to create a Divisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Divisions we want to update
     *   }
     * })
     */
    upsert<T extends DivisionsUpsertArgs>(args: SelectSubset<T, DivisionsUpsertArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsCountArgs} args - Arguments to filter Divisions to count.
     * @example
     * // Count the number of Divisions
     * const count = await prisma.divisions.count({
     *   where: {
     *     // ... the filter for the Divisions we want to count
     *   }
     * })
    **/
    count<T extends DivisionsCountArgs>(
      args?: Subset<T, DivisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisionsAggregateArgs>(args: Subset<T, DivisionsAggregateArgs>): Prisma.PrismaPromise<GetDivisionsAggregateType<T>>

    /**
     * Group by Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DivisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DivisionsGroupByArgs['orderBy'] }
        : { orderBy?: DivisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DivisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Divisions model
   */
  readonly fields: DivisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Divisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DivisionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentHead<T extends Divisions$currentHeadArgs<ExtArgs> = {}>(args?: Subset<T, Divisions$currentHeadArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Divisions$userArgs<ExtArgs> = {}>(args?: Subset<T, Divisions$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    socialLinks<T extends Divisions$socialLinksArgs<ExtArgs> = {}>(args?: Subset<T, Divisions$socialLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Divisions$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Divisions$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Divisions$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Divisions$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Divisions model
   */
  interface DivisionsFieldRefs {
    readonly id: FieldRef<"Divisions", 'String'>
    readonly name: FieldRef<"Divisions", 'String'>
    readonly description: FieldRef<"Divisions", 'String'>
    readonly imageUrl: FieldRef<"Divisions", 'String'>
    readonly establishedAt: FieldRef<"Divisions", 'DateTime'>
    readonly createdAt: FieldRef<"Divisions", 'DateTime'>
    readonly updatedAt: FieldRef<"Divisions", 'DateTime'>
    readonly currentHeadID: FieldRef<"Divisions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Divisions findUnique
   */
  export type DivisionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where: DivisionsWhereUniqueInput
  }

  /**
   * Divisions findUniqueOrThrow
   */
  export type DivisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where: DivisionsWhereUniqueInput
  }

  /**
   * Divisions findFirst
   */
  export type DivisionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where?: DivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionsOrderByWithRelationInput | DivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }

  /**
   * Divisions findFirstOrThrow
   */
  export type DivisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where?: DivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionsOrderByWithRelationInput | DivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }

  /**
   * Divisions findMany
   */
  export type DivisionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where?: DivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionsOrderByWithRelationInput | DivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Divisions.
     */
    cursor?: DivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }

  /**
   * Divisions create
   */
  export type DivisionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Divisions.
     */
    data: XOR<DivisionsCreateInput, DivisionsUncheckedCreateInput>
  }

  /**
   * Divisions createMany
   */
  export type DivisionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Divisions.
     */
    data: DivisionsCreateManyInput | DivisionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Divisions createManyAndReturn
   */
  export type DivisionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * The data used to create many Divisions.
     */
    data: DivisionsCreateManyInput | DivisionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Divisions update
   */
  export type DivisionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Divisions.
     */
    data: XOR<DivisionsUpdateInput, DivisionsUncheckedUpdateInput>
    /**
     * Choose, which Divisions to update.
     */
    where: DivisionsWhereUniqueInput
  }

  /**
   * Divisions updateMany
   */
  export type DivisionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionsUpdateManyMutationInput, DivisionsUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionsWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
  }

  /**
   * Divisions updateManyAndReturn
   */
  export type DivisionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionsUpdateManyMutationInput, DivisionsUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionsWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Divisions upsert
   */
  export type DivisionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Divisions to update in case it exists.
     */
    where: DivisionsWhereUniqueInput
    /**
     * In case the Divisions found by the `where` argument doesn't exist, create a new Divisions with this data.
     */
    create: XOR<DivisionsCreateInput, DivisionsUncheckedCreateInput>
    /**
     * In case the Divisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DivisionsUpdateInput, DivisionsUncheckedUpdateInput>
  }

  /**
   * Divisions delete
   */
  export type DivisionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    /**
     * Filter which Divisions to delete.
     */
    where: DivisionsWhereUniqueInput
  }

  /**
   * Divisions deleteMany
   */
  export type DivisionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Divisions to delete
     */
    where?: DivisionsWhereInput
    /**
     * Limit how many Divisions to delete.
     */
    limit?: number
  }

  /**
   * Divisions.currentHead
   */
  export type Divisions$currentHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Divisions.user
   */
  export type Divisions$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Divisions.socialLinks
   */
  export type Divisions$socialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    where?: socialLinkWhereInput
    orderBy?: socialLinkOrderByWithRelationInput | socialLinkOrderByWithRelationInput[]
    cursor?: socialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * Divisions.sessions
   */
  export type Divisions$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    where?: SessionsWhereInput
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    cursor?: SessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * Divisions.groups
   */
  export type Divisions$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    cursor?: GroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Divisions without action
   */
  export type DivisionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
  }


  /**
   * Model Groups
   */

  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    divisionId: string | null
  }

  export type GroupsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    divisionId: string | null
  }

  export type GroupsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    divisionId: number
    _all: number
  }


  export type GroupsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    divisionId?: true
  }

  export type GroupsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    divisionId?: true
  }

  export type GroupsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    divisionId?: true
    _all?: true
  }

  export type GroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to aggregate.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type GroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithAggregationInput | GroupsOrderByWithAggregationInput[]
    by: GroupsScalarFieldEnum[] | GroupsScalarFieldEnum
    having?: GroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }

  export type GroupsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    divisionId: string | null
    _count: GroupsCountAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends GroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type GroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    divisionId?: boolean
    users?: boolean | Groups$usersArgs<ExtArgs>
    division?: boolean | Groups$divisionArgs<ExtArgs>
    sessions?: boolean | Groups$sessionsArgs<ExtArgs>
    events?: boolean | Groups$eventsArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type GroupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    divisionId?: boolean
    division?: boolean | Groups$divisionArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type GroupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    divisionId?: boolean
    division?: boolean | Groups$divisionArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type GroupsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    divisionId?: boolean
  }

  export type GroupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "divisionId", ExtArgs["result"]["groups"]>
  export type GroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Groups$usersArgs<ExtArgs>
    division?: boolean | Groups$divisionArgs<ExtArgs>
    sessions?: boolean | Groups$sessionsArgs<ExtArgs>
    events?: boolean | Groups$eventsArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    division?: boolean | Groups$divisionArgs<ExtArgs>
  }
  export type GroupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    division?: boolean | Groups$divisionArgs<ExtArgs>
  }

  export type $GroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Groups"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      division: Prisma.$DivisionsPayload<ExtArgs> | null
      sessions: Prisma.$SessionsPayload<ExtArgs>[]
      events: Prisma.$EventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      divisionId: string | null
    }, ExtArgs["result"]["groups"]>
    composites: {}
  }

  type GroupsGetPayload<S extends boolean | null | undefined | GroupsDefaultArgs> = $Result.GetResult<Prisma.$GroupsPayload, S>

  type GroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupsCountAggregateInputType | true
    }

  export interface GroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Groups'], meta: { name: 'Groups' } }
    /**
     * Find zero or one Groups that matches the filter.
     * @param {GroupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupsFindUniqueArgs>(args: SelectSubset<T, GroupsFindUniqueArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupsFindFirstArgs>(args?: SelectSubset<T, GroupsFindFirstArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupsWithIdOnly = await prisma.groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupsFindManyArgs>(args?: SelectSubset<T, GroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Groups.
     * @param {GroupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
     */
    create<T extends GroupsCreateArgs>(args: SelectSubset<T, GroupsCreateArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupsCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupsCreateManyArgs>(args?: SelectSubset<T, GroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupsCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupsWithIdOnly = await prisma.groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupsCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Groups.
     * @param {GroupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
     */
    delete<T extends GroupsDeleteArgs>(args: SelectSubset<T, GroupsDeleteArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Groups.
     * @param {GroupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupsUpdateArgs>(args: SelectSubset<T, GroupsUpdateArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupsDeleteManyArgs>(args?: SelectSubset<T, GroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupsUpdateManyArgs>(args: SelectSubset<T, GroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupsUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupsWithIdOnly = await prisma.groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupsUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Groups.
     * @param {GroupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
     */
    upsert<T extends GroupsUpsertArgs>(args: SelectSubset<T, GroupsUpsertArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupsCountArgs>(
      args?: Subset<T, GroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): Prisma.PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupsGroupByArgs['orderBy'] }
        : { orderBy?: GroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Groups model
   */
  readonly fields: GroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Groups$usersArgs<ExtArgs> = {}>(args?: Subset<T, Groups$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    division<T extends Groups$divisionArgs<ExtArgs> = {}>(args?: Subset<T, Groups$divisionArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Groups$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Groups$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Groups$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Groups$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Groups model
   */
  interface GroupsFieldRefs {
    readonly id: FieldRef<"Groups", 'String'>
    readonly name: FieldRef<"Groups", 'String'>
    readonly description: FieldRef<"Groups", 'String'>
    readonly createdAt: FieldRef<"Groups", 'DateTime'>
    readonly updatedAt: FieldRef<"Groups", 'DateTime'>
    readonly divisionId: FieldRef<"Groups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Groups findUnique
   */
  export type GroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups findUniqueOrThrow
   */
  export type GroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups findFirst
   */
  export type GroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups findFirstOrThrow
   */
  export type GroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups findMany
   */
  export type GroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups create
   */
  export type GroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a Groups.
     */
    data: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
  }

  /**
   * Groups createMany
   */
  export type GroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupsCreateManyInput | GroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Groups createManyAndReturn
   */
  export type GroupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupsCreateManyInput | GroupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Groups update
   */
  export type GroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a Groups.
     */
    data: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
    /**
     * Choose, which Groups to update.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups updateMany
   */
  export type GroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupsWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Groups updateManyAndReturn
   */
  export type GroupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupsWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Groups upsert
   */
  export type GroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the Groups to update in case it exists.
     */
    where: GroupsWhereUniqueInput
    /**
     * In case the Groups found by the `where` argument doesn't exist, create a new Groups with this data.
     */
    create: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
    /**
     * In case the Groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
  }

  /**
   * Groups delete
   */
  export type GroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter which Groups to delete.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups deleteMany
   */
  export type GroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupsWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Groups.users
   */
  export type Groups$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Groups.division
   */
  export type Groups$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    where?: DivisionsWhereInput
  }

  /**
   * Groups.sessions
   */
  export type Groups$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    where?: SessionsWhereInput
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    cursor?: SessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * Groups.events
   */
  export type Groups$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Groups without action
   */
  export type GroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
  }


  /**
   * Model socialLink
   */

  export type AggregateSocialLink = {
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  export type SocialLinkMinAggregateOutputType = {
    id: string | null
    socialLinkName: string | null
    socialLinkUrl: string | null
    userId: string | null
    DivisionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialLinkMaxAggregateOutputType = {
    id: string | null
    socialLinkName: string | null
    socialLinkUrl: string | null
    userId: string | null
    DivisionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialLinkCountAggregateOutputType = {
    id: number
    socialLinkName: number
    socialLinkUrl: number
    userId: number
    DivisionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialLinkMinAggregateInputType = {
    id?: true
    socialLinkName?: true
    socialLinkUrl?: true
    userId?: true
    DivisionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialLinkMaxAggregateInputType = {
    id?: true
    socialLinkName?: true
    socialLinkUrl?: true
    userId?: true
    DivisionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialLinkCountAggregateInputType = {
    id?: true
    socialLinkName?: true
    socialLinkUrl?: true
    userId?: true
    DivisionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which socialLink to aggregate.
     */
    where?: socialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialLinks to fetch.
     */
    orderBy?: socialLinkOrderByWithRelationInput | socialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: socialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned socialLinks
    **/
    _count?: true | SocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinkMaxAggregateInputType
  }

  export type GetSocialLinkAggregateType<T extends SocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLink[P]>
      : GetScalarType<T[P], AggregateSocialLink[P]>
  }




  export type socialLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: socialLinkWhereInput
    orderBy?: socialLinkOrderByWithAggregationInput | socialLinkOrderByWithAggregationInput[]
    by: SocialLinkScalarFieldEnum[] | SocialLinkScalarFieldEnum
    having?: socialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinkCountAggregateInputType | true
    _min?: SocialLinkMinAggregateInputType
    _max?: SocialLinkMaxAggregateInputType
  }

  export type SocialLinkGroupByOutputType = {
    id: string
    socialLinkName: string
    socialLinkUrl: string
    userId: string | null
    DivisionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  type GetSocialLinkGroupByPayload<T extends socialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type socialLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    socialLinkName?: boolean
    socialLinkUrl?: boolean
    userId?: boolean
    DivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | socialLink$userArgs<ExtArgs>
    Division?: boolean | socialLink$DivisionArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type socialLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    socialLinkName?: boolean
    socialLinkUrl?: boolean
    userId?: boolean
    DivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | socialLink$userArgs<ExtArgs>
    Division?: boolean | socialLink$DivisionArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type socialLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    socialLinkName?: boolean
    socialLinkUrl?: boolean
    userId?: boolean
    DivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | socialLink$userArgs<ExtArgs>
    Division?: boolean | socialLink$DivisionArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type socialLinkSelectScalar = {
    id?: boolean
    socialLinkName?: boolean
    socialLinkUrl?: boolean
    userId?: boolean
    DivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type socialLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "socialLinkName" | "socialLinkUrl" | "userId" | "DivisionId" | "createdAt" | "updatedAt", ExtArgs["result"]["socialLink"]>
  export type socialLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | socialLink$userArgs<ExtArgs>
    Division?: boolean | socialLink$DivisionArgs<ExtArgs>
  }
  export type socialLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | socialLink$userArgs<ExtArgs>
    Division?: boolean | socialLink$DivisionArgs<ExtArgs>
  }
  export type socialLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | socialLink$userArgs<ExtArgs>
    Division?: boolean | socialLink$DivisionArgs<ExtArgs>
  }

  export type $socialLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "socialLink"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      Division: Prisma.$DivisionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      socialLinkName: string
      socialLinkUrl: string
      userId: string | null
      DivisionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialLink"]>
    composites: {}
  }

  type socialLinkGetPayload<S extends boolean | null | undefined | socialLinkDefaultArgs> = $Result.GetResult<Prisma.$socialLinkPayload, S>

  type socialLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<socialLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialLinkCountAggregateInputType | true
    }

  export interface socialLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['socialLink'], meta: { name: 'socialLink' } }
    /**
     * Find zero or one SocialLink that matches the filter.
     * @param {socialLinkFindUniqueArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends socialLinkFindUniqueArgs>(args: SelectSubset<T, socialLinkFindUniqueArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {socialLinkFindUniqueOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends socialLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, socialLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialLinkFindFirstArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends socialLinkFindFirstArgs>(args?: SelectSubset<T, socialLinkFindFirstArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialLinkFindFirstOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends socialLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, socialLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLink.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends socialLinkFindManyArgs>(args?: SelectSubset<T, socialLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialLink.
     * @param {socialLinkCreateArgs} args - Arguments to create a SocialLink.
     * @example
     * // Create one SocialLink
     * const SocialLink = await prisma.socialLink.create({
     *   data: {
     *     // ... data to create a SocialLink
     *   }
     * })
     * 
     */
    create<T extends socialLinkCreateArgs>(args: SelectSubset<T, socialLinkCreateArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialLinks.
     * @param {socialLinkCreateManyArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends socialLinkCreateManyArgs>(args?: SelectSubset<T, socialLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialLinks and returns the data saved in the database.
     * @param {socialLinkCreateManyAndReturnArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialLinks and only return the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends socialLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, socialLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialLink.
     * @param {socialLinkDeleteArgs} args - Arguments to delete one SocialLink.
     * @example
     * // Delete one SocialLink
     * const SocialLink = await prisma.socialLink.delete({
     *   where: {
     *     // ... filter to delete one SocialLink
     *   }
     * })
     * 
     */
    delete<T extends socialLinkDeleteArgs>(args: SelectSubset<T, socialLinkDeleteArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialLink.
     * @param {socialLinkUpdateArgs} args - Arguments to update one SocialLink.
     * @example
     * // Update one SocialLink
     * const socialLink = await prisma.socialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends socialLinkUpdateArgs>(args: SelectSubset<T, socialLinkUpdateArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialLinks.
     * @param {socialLinkDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends socialLinkDeleteManyArgs>(args?: SelectSubset<T, socialLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends socialLinkUpdateManyArgs>(args: SelectSubset<T, socialLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks and returns the data updated in the database.
     * @param {socialLinkUpdateManyAndReturnArgs} args - Arguments to update many SocialLinks.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialLinks and only return the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends socialLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, socialLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialLink.
     * @param {socialLinkUpsertArgs} args - Arguments to update or create a SocialLink.
     * @example
     * // Update or create a SocialLink
     * const socialLink = await prisma.socialLink.upsert({
     *   create: {
     *     // ... data to create a SocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLink we want to update
     *   }
     * })
     */
    upsert<T extends socialLinkUpsertArgs>(args: SelectSubset<T, socialLinkUpsertArgs<ExtArgs>>): Prisma__socialLinkClient<$Result.GetResult<Prisma.$socialLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialLinkCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLink.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends socialLinkCountArgs>(
      args?: Subset<T, socialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinkAggregateArgs>(args: Subset<T, SocialLinkAggregateArgs>): Prisma.PrismaPromise<GetSocialLinkAggregateType<T>>

    /**
     * Group by SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends socialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: socialLinkGroupByArgs['orderBy'] }
        : { orderBy?: socialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, socialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the socialLink model
   */
  readonly fields: socialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for socialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__socialLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends socialLink$userArgs<ExtArgs> = {}>(args?: Subset<T, socialLink$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Division<T extends socialLink$DivisionArgs<ExtArgs> = {}>(args?: Subset<T, socialLink$DivisionArgs<ExtArgs>>): Prisma__DivisionsClient<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the socialLink model
   */
  interface socialLinkFieldRefs {
    readonly id: FieldRef<"socialLink", 'String'>
    readonly socialLinkName: FieldRef<"socialLink", 'String'>
    readonly socialLinkUrl: FieldRef<"socialLink", 'String'>
    readonly userId: FieldRef<"socialLink", 'String'>
    readonly DivisionId: FieldRef<"socialLink", 'String'>
    readonly createdAt: FieldRef<"socialLink", 'DateTime'>
    readonly updatedAt: FieldRef<"socialLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * socialLink findUnique
   */
  export type socialLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * Filter, which socialLink to fetch.
     */
    where: socialLinkWhereUniqueInput
  }

  /**
   * socialLink findUniqueOrThrow
   */
  export type socialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * Filter, which socialLink to fetch.
     */
    where: socialLinkWhereUniqueInput
  }

  /**
   * socialLink findFirst
   */
  export type socialLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * Filter, which socialLink to fetch.
     */
    where?: socialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialLinks to fetch.
     */
    orderBy?: socialLinkOrderByWithRelationInput | socialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for socialLinks.
     */
    cursor?: socialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of socialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * socialLink findFirstOrThrow
   */
  export type socialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * Filter, which socialLink to fetch.
     */
    where?: socialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialLinks to fetch.
     */
    orderBy?: socialLinkOrderByWithRelationInput | socialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for socialLinks.
     */
    cursor?: socialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of socialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * socialLink findMany
   */
  export type socialLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * Filter, which socialLinks to fetch.
     */
    where?: socialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialLinks to fetch.
     */
    orderBy?: socialLinkOrderByWithRelationInput | socialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing socialLinks.
     */
    cursor?: socialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialLinks.
     */
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * socialLink create
   */
  export type socialLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a socialLink.
     */
    data: XOR<socialLinkCreateInput, socialLinkUncheckedCreateInput>
  }

  /**
   * socialLink createMany
   */
  export type socialLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many socialLinks.
     */
    data: socialLinkCreateManyInput | socialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * socialLink createManyAndReturn
   */
  export type socialLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * The data used to create many socialLinks.
     */
    data: socialLinkCreateManyInput | socialLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * socialLink update
   */
  export type socialLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a socialLink.
     */
    data: XOR<socialLinkUpdateInput, socialLinkUncheckedUpdateInput>
    /**
     * Choose, which socialLink to update.
     */
    where: socialLinkWhereUniqueInput
  }

  /**
   * socialLink updateMany
   */
  export type socialLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update socialLinks.
     */
    data: XOR<socialLinkUpdateManyMutationInput, socialLinkUncheckedUpdateManyInput>
    /**
     * Filter which socialLinks to update
     */
    where?: socialLinkWhereInput
    /**
     * Limit how many socialLinks to update.
     */
    limit?: number
  }

  /**
   * socialLink updateManyAndReturn
   */
  export type socialLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * The data used to update socialLinks.
     */
    data: XOR<socialLinkUpdateManyMutationInput, socialLinkUncheckedUpdateManyInput>
    /**
     * Filter which socialLinks to update
     */
    where?: socialLinkWhereInput
    /**
     * Limit how many socialLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * socialLink upsert
   */
  export type socialLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the socialLink to update in case it exists.
     */
    where: socialLinkWhereUniqueInput
    /**
     * In case the socialLink found by the `where` argument doesn't exist, create a new socialLink with this data.
     */
    create: XOR<socialLinkCreateInput, socialLinkUncheckedCreateInput>
    /**
     * In case the socialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<socialLinkUpdateInput, socialLinkUncheckedUpdateInput>
  }

  /**
   * socialLink delete
   */
  export type socialLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
    /**
     * Filter which socialLink to delete.
     */
    where: socialLinkWhereUniqueInput
  }

  /**
   * socialLink deleteMany
   */
  export type socialLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which socialLinks to delete
     */
    where?: socialLinkWhereInput
    /**
     * Limit how many socialLinks to delete.
     */
    limit?: number
  }

  /**
   * socialLink.user
   */
  export type socialLink$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * socialLink.Division
   */
  export type socialLink$DivisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    where?: DivisionsWhereInput
  }

  /**
   * socialLink without action
   */
  export type socialLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialLink
     */
    select?: socialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialLink
     */
    omit?: socialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: socialLinkInclude<ExtArgs> | null
  }


  /**
   * Model EventTimeSlot
   */

  export type AggregateEventTimeSlot = {
    _count: EventTimeSlotCountAggregateOutputType | null
    _min: EventTimeSlotMinAggregateOutputType | null
    _max: EventTimeSlotMaxAggregateOutputType | null
  }

  export type EventTimeSlotMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type EventTimeSlotMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type EventTimeSlotCountAggregateOutputType = {
    id: number
    eventId: number
    startTime: number
    endTime: number
    _all: number
  }


  export type EventTimeSlotMinAggregateInputType = {
    id?: true
    eventId?: true
    startTime?: true
    endTime?: true
  }

  export type EventTimeSlotMaxAggregateInputType = {
    id?: true
    eventId?: true
    startTime?: true
    endTime?: true
  }

  export type EventTimeSlotCountAggregateInputType = {
    id?: true
    eventId?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type EventTimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTimeSlot to aggregate.
     */
    where?: EventTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTimeSlots to fetch.
     */
    orderBy?: EventTimeSlotOrderByWithRelationInput | EventTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTimeSlots
    **/
    _count?: true | EventTimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTimeSlotMaxAggregateInputType
  }

  export type GetEventTimeSlotAggregateType<T extends EventTimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateEventTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventTimeSlot[P]>
      : GetScalarType<T[P], AggregateEventTimeSlot[P]>
  }




  export type EventTimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTimeSlotWhereInput
    orderBy?: EventTimeSlotOrderByWithAggregationInput | EventTimeSlotOrderByWithAggregationInput[]
    by: EventTimeSlotScalarFieldEnum[] | EventTimeSlotScalarFieldEnum
    having?: EventTimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTimeSlotCountAggregateInputType | true
    _min?: EventTimeSlotMinAggregateInputType
    _max?: EventTimeSlotMaxAggregateInputType
  }

  export type EventTimeSlotGroupByOutputType = {
    id: string
    eventId: string | null
    startTime: Date
    endTime: Date
    _count: EventTimeSlotCountAggregateOutputType | null
    _min: EventTimeSlotMinAggregateOutputType | null
    _max: EventTimeSlotMaxAggregateOutputType | null
  }

  type GetEventTimeSlotGroupByPayload<T extends EventTimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], EventTimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type EventTimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    startTime?: boolean
    endTime?: boolean
    event?: boolean | EventTimeSlot$eventArgs<ExtArgs>
  }, ExtArgs["result"]["eventTimeSlot"]>

  export type EventTimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    startTime?: boolean
    endTime?: boolean
    event?: boolean | EventTimeSlot$eventArgs<ExtArgs>
  }, ExtArgs["result"]["eventTimeSlot"]>

  export type EventTimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    startTime?: boolean
    endTime?: boolean
    event?: boolean | EventTimeSlot$eventArgs<ExtArgs>
  }, ExtArgs["result"]["eventTimeSlot"]>

  export type EventTimeSlotSelectScalar = {
    id?: boolean
    eventId?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type EventTimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "startTime" | "endTime", ExtArgs["result"]["eventTimeSlot"]>
  export type EventTimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventTimeSlot$eventArgs<ExtArgs>
  }
  export type EventTimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventTimeSlot$eventArgs<ExtArgs>
  }
  export type EventTimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventTimeSlot$eventArgs<ExtArgs>
  }

  export type $EventTimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventTimeSlot"
    objects: {
      event: Prisma.$EventsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string | null
      startTime: Date
      endTime: Date
    }, ExtArgs["result"]["eventTimeSlot"]>
    composites: {}
  }

  type EventTimeSlotGetPayload<S extends boolean | null | undefined | EventTimeSlotDefaultArgs> = $Result.GetResult<Prisma.$EventTimeSlotPayload, S>

  type EventTimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventTimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventTimeSlotCountAggregateInputType | true
    }

  export interface EventTimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventTimeSlot'], meta: { name: 'EventTimeSlot' } }
    /**
     * Find zero or one EventTimeSlot that matches the filter.
     * @param {EventTimeSlotFindUniqueArgs} args - Arguments to find a EventTimeSlot
     * @example
     * // Get one EventTimeSlot
     * const eventTimeSlot = await prisma.eventTimeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTimeSlotFindUniqueArgs>(args: SelectSubset<T, EventTimeSlotFindUniqueArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventTimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventTimeSlotFindUniqueOrThrowArgs} args - Arguments to find a EventTimeSlot
     * @example
     * // Get one EventTimeSlot
     * const eventTimeSlot = await prisma.eventTimeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventTimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotFindFirstArgs} args - Arguments to find a EventTimeSlot
     * @example
     * // Get one EventTimeSlot
     * const eventTimeSlot = await prisma.eventTimeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTimeSlotFindFirstArgs>(args?: SelectSubset<T, EventTimeSlotFindFirstArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventTimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotFindFirstOrThrowArgs} args - Arguments to find a EventTimeSlot
     * @example
     * // Get one EventTimeSlot
     * const eventTimeSlot = await prisma.eventTimeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventTimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTimeSlots
     * const eventTimeSlots = await prisma.eventTimeSlot.findMany()
     * 
     * // Get first 10 EventTimeSlots
     * const eventTimeSlots = await prisma.eventTimeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventTimeSlotWithIdOnly = await prisma.eventTimeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventTimeSlotFindManyArgs>(args?: SelectSubset<T, EventTimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventTimeSlot.
     * @param {EventTimeSlotCreateArgs} args - Arguments to create a EventTimeSlot.
     * @example
     * // Create one EventTimeSlot
     * const EventTimeSlot = await prisma.eventTimeSlot.create({
     *   data: {
     *     // ... data to create a EventTimeSlot
     *   }
     * })
     * 
     */
    create<T extends EventTimeSlotCreateArgs>(args: SelectSubset<T, EventTimeSlotCreateArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventTimeSlots.
     * @param {EventTimeSlotCreateManyArgs} args - Arguments to create many EventTimeSlots.
     * @example
     * // Create many EventTimeSlots
     * const eventTimeSlot = await prisma.eventTimeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTimeSlotCreateManyArgs>(args?: SelectSubset<T, EventTimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventTimeSlots and returns the data saved in the database.
     * @param {EventTimeSlotCreateManyAndReturnArgs} args - Arguments to create many EventTimeSlots.
     * @example
     * // Create many EventTimeSlots
     * const eventTimeSlot = await prisma.eventTimeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventTimeSlots and only return the `id`
     * const eventTimeSlotWithIdOnly = await prisma.eventTimeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventTimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, EventTimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventTimeSlot.
     * @param {EventTimeSlotDeleteArgs} args - Arguments to delete one EventTimeSlot.
     * @example
     * // Delete one EventTimeSlot
     * const EventTimeSlot = await prisma.eventTimeSlot.delete({
     *   where: {
     *     // ... filter to delete one EventTimeSlot
     *   }
     * })
     * 
     */
    delete<T extends EventTimeSlotDeleteArgs>(args: SelectSubset<T, EventTimeSlotDeleteArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventTimeSlot.
     * @param {EventTimeSlotUpdateArgs} args - Arguments to update one EventTimeSlot.
     * @example
     * // Update one EventTimeSlot
     * const eventTimeSlot = await prisma.eventTimeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTimeSlotUpdateArgs>(args: SelectSubset<T, EventTimeSlotUpdateArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventTimeSlots.
     * @param {EventTimeSlotDeleteManyArgs} args - Arguments to filter EventTimeSlots to delete.
     * @example
     * // Delete a few EventTimeSlots
     * const { count } = await prisma.eventTimeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTimeSlotDeleteManyArgs>(args?: SelectSubset<T, EventTimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTimeSlots
     * const eventTimeSlot = await prisma.eventTimeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTimeSlotUpdateManyArgs>(args: SelectSubset<T, EventTimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTimeSlots and returns the data updated in the database.
     * @param {EventTimeSlotUpdateManyAndReturnArgs} args - Arguments to update many EventTimeSlots.
     * @example
     * // Update many EventTimeSlots
     * const eventTimeSlot = await prisma.eventTimeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventTimeSlots and only return the `id`
     * const eventTimeSlotWithIdOnly = await prisma.eventTimeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventTimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, EventTimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventTimeSlot.
     * @param {EventTimeSlotUpsertArgs} args - Arguments to update or create a EventTimeSlot.
     * @example
     * // Update or create a EventTimeSlot
     * const eventTimeSlot = await prisma.eventTimeSlot.upsert({
     *   create: {
     *     // ... data to create a EventTimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventTimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends EventTimeSlotUpsertArgs>(args: SelectSubset<T, EventTimeSlotUpsertArgs<ExtArgs>>): Prisma__EventTimeSlotClient<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventTimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotCountArgs} args - Arguments to filter EventTimeSlots to count.
     * @example
     * // Count the number of EventTimeSlots
     * const count = await prisma.eventTimeSlot.count({
     *   where: {
     *     // ... the filter for the EventTimeSlots we want to count
     *   }
     * })
    **/
    count<T extends EventTimeSlotCountArgs>(
      args?: Subset<T, EventTimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventTimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTimeSlotAggregateArgs>(args: Subset<T, EventTimeSlotAggregateArgs>): Prisma.PrismaPromise<GetEventTimeSlotAggregateType<T>>

    /**
     * Group by EventTimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: EventTimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventTimeSlot model
   */
  readonly fields: EventTimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventTimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventTimeSlot$eventArgs<ExtArgs> = {}>(args?: Subset<T, EventTimeSlot$eventArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventTimeSlot model
   */
  interface EventTimeSlotFieldRefs {
    readonly id: FieldRef<"EventTimeSlot", 'String'>
    readonly eventId: FieldRef<"EventTimeSlot", 'String'>
    readonly startTime: FieldRef<"EventTimeSlot", 'DateTime'>
    readonly endTime: FieldRef<"EventTimeSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventTimeSlot findUnique
   */
  export type EventTimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which EventTimeSlot to fetch.
     */
    where: EventTimeSlotWhereUniqueInput
  }

  /**
   * EventTimeSlot findUniqueOrThrow
   */
  export type EventTimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which EventTimeSlot to fetch.
     */
    where: EventTimeSlotWhereUniqueInput
  }

  /**
   * EventTimeSlot findFirst
   */
  export type EventTimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which EventTimeSlot to fetch.
     */
    where?: EventTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTimeSlots to fetch.
     */
    orderBy?: EventTimeSlotOrderByWithRelationInput | EventTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTimeSlots.
     */
    cursor?: EventTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTimeSlots.
     */
    distinct?: EventTimeSlotScalarFieldEnum | EventTimeSlotScalarFieldEnum[]
  }

  /**
   * EventTimeSlot findFirstOrThrow
   */
  export type EventTimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which EventTimeSlot to fetch.
     */
    where?: EventTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTimeSlots to fetch.
     */
    orderBy?: EventTimeSlotOrderByWithRelationInput | EventTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTimeSlots.
     */
    cursor?: EventTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTimeSlots.
     */
    distinct?: EventTimeSlotScalarFieldEnum | EventTimeSlotScalarFieldEnum[]
  }

  /**
   * EventTimeSlot findMany
   */
  export type EventTimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which EventTimeSlots to fetch.
     */
    where?: EventTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTimeSlots to fetch.
     */
    orderBy?: EventTimeSlotOrderByWithRelationInput | EventTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTimeSlots.
     */
    cursor?: EventTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTimeSlots.
     */
    skip?: number
    distinct?: EventTimeSlotScalarFieldEnum | EventTimeSlotScalarFieldEnum[]
  }

  /**
   * EventTimeSlot create
   */
  export type EventTimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a EventTimeSlot.
     */
    data: XOR<EventTimeSlotCreateInput, EventTimeSlotUncheckedCreateInput>
  }

  /**
   * EventTimeSlot createMany
   */
  export type EventTimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTimeSlots.
     */
    data: EventTimeSlotCreateManyInput | EventTimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventTimeSlot createManyAndReturn
   */
  export type EventTimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many EventTimeSlots.
     */
    data: EventTimeSlotCreateManyInput | EventTimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventTimeSlot update
   */
  export type EventTimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a EventTimeSlot.
     */
    data: XOR<EventTimeSlotUpdateInput, EventTimeSlotUncheckedUpdateInput>
    /**
     * Choose, which EventTimeSlot to update.
     */
    where: EventTimeSlotWhereUniqueInput
  }

  /**
   * EventTimeSlot updateMany
   */
  export type EventTimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTimeSlots.
     */
    data: XOR<EventTimeSlotUpdateManyMutationInput, EventTimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which EventTimeSlots to update
     */
    where?: EventTimeSlotWhereInput
    /**
     * Limit how many EventTimeSlots to update.
     */
    limit?: number
  }

  /**
   * EventTimeSlot updateManyAndReturn
   */
  export type EventTimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update EventTimeSlots.
     */
    data: XOR<EventTimeSlotUpdateManyMutationInput, EventTimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which EventTimeSlots to update
     */
    where?: EventTimeSlotWhereInput
    /**
     * Limit how many EventTimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventTimeSlot upsert
   */
  export type EventTimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the EventTimeSlot to update in case it exists.
     */
    where: EventTimeSlotWhereUniqueInput
    /**
     * In case the EventTimeSlot found by the `where` argument doesn't exist, create a new EventTimeSlot with this data.
     */
    create: XOR<EventTimeSlotCreateInput, EventTimeSlotUncheckedCreateInput>
    /**
     * In case the EventTimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTimeSlotUpdateInput, EventTimeSlotUncheckedUpdateInput>
  }

  /**
   * EventTimeSlot delete
   */
  export type EventTimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    /**
     * Filter which EventTimeSlot to delete.
     */
    where: EventTimeSlotWhereUniqueInput
  }

  /**
   * EventTimeSlot deleteMany
   */
  export type EventTimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTimeSlots to delete
     */
    where?: EventTimeSlotWhereInput
    /**
     * Limit how many EventTimeSlots to delete.
     */
    limit?: number
  }

  /**
   * EventTimeSlot.event
   */
  export type EventTimeSlot$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
  }

  /**
   * EventTimeSlot without action
   */
  export type EventTimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model SessionTimeSlot
   */

  export type AggregateSessionTimeSlot = {
    _count: SessionTimeSlotCountAggregateOutputType | null
    _min: SessionTimeSlotMinAggregateOutputType | null
    _max: SessionTimeSlotMaxAggregateOutputType | null
  }

  export type SessionTimeSlotMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type SessionTimeSlotMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    startTime: Date | null
    endTime: Date | null
  }

  export type SessionTimeSlotCountAggregateOutputType = {
    id: number
    sessionId: number
    startTime: number
    endTime: number
    _all: number
  }


  export type SessionTimeSlotMinAggregateInputType = {
    id?: true
    sessionId?: true
    startTime?: true
    endTime?: true
  }

  export type SessionTimeSlotMaxAggregateInputType = {
    id?: true
    sessionId?: true
    startTime?: true
    endTime?: true
  }

  export type SessionTimeSlotCountAggregateInputType = {
    id?: true
    sessionId?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type SessionTimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTimeSlot to aggregate.
     */
    where?: SessionTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTimeSlots to fetch.
     */
    orderBy?: SessionTimeSlotOrderByWithRelationInput | SessionTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionTimeSlots
    **/
    _count?: true | SessionTimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionTimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionTimeSlotMaxAggregateInputType
  }

  export type GetSessionTimeSlotAggregateType<T extends SessionTimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionTimeSlot[P]>
      : GetScalarType<T[P], AggregateSessionTimeSlot[P]>
  }




  export type SessionTimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTimeSlotWhereInput
    orderBy?: SessionTimeSlotOrderByWithAggregationInput | SessionTimeSlotOrderByWithAggregationInput[]
    by: SessionTimeSlotScalarFieldEnum[] | SessionTimeSlotScalarFieldEnum
    having?: SessionTimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionTimeSlotCountAggregateInputType | true
    _min?: SessionTimeSlotMinAggregateInputType
    _max?: SessionTimeSlotMaxAggregateInputType
  }

  export type SessionTimeSlotGroupByOutputType = {
    id: string
    sessionId: string | null
    startTime: Date
    endTime: Date
    _count: SessionTimeSlotCountAggregateOutputType | null
    _min: SessionTimeSlotMinAggregateOutputType | null
    _max: SessionTimeSlotMaxAggregateOutputType | null
  }

  type GetSessionTimeSlotGroupByPayload<T extends SessionTimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionTimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionTimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionTimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], SessionTimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type SessionTimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean | SessionTimeSlot$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTimeSlot"]>

  export type SessionTimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean | SessionTimeSlot$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTimeSlot"]>

  export type SessionTimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean | SessionTimeSlot$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTimeSlot"]>

  export type SessionTimeSlotSelectScalar = {
    id?: boolean
    sessionId?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type SessionTimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "startTime" | "endTime", ExtArgs["result"]["sessionTimeSlot"]>
  export type SessionTimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionTimeSlot$sessionArgs<ExtArgs>
  }
  export type SessionTimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionTimeSlot$sessionArgs<ExtArgs>
  }
  export type SessionTimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionTimeSlot$sessionArgs<ExtArgs>
  }

  export type $SessionTimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionTimeSlot"
    objects: {
      session: Prisma.$SessionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      startTime: Date
      endTime: Date
    }, ExtArgs["result"]["sessionTimeSlot"]>
    composites: {}
  }

  type SessionTimeSlotGetPayload<S extends boolean | null | undefined | SessionTimeSlotDefaultArgs> = $Result.GetResult<Prisma.$SessionTimeSlotPayload, S>

  type SessionTimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionTimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionTimeSlotCountAggregateInputType | true
    }

  export interface SessionTimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionTimeSlot'], meta: { name: 'SessionTimeSlot' } }
    /**
     * Find zero or one SessionTimeSlot that matches the filter.
     * @param {SessionTimeSlotFindUniqueArgs} args - Arguments to find a SessionTimeSlot
     * @example
     * // Get one SessionTimeSlot
     * const sessionTimeSlot = await prisma.sessionTimeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionTimeSlotFindUniqueArgs>(args: SelectSubset<T, SessionTimeSlotFindUniqueArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionTimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionTimeSlotFindUniqueOrThrowArgs} args - Arguments to find a SessionTimeSlot
     * @example
     * // Get one SessionTimeSlot
     * const sessionTimeSlot = await prisma.sessionTimeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionTimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionTimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotFindFirstArgs} args - Arguments to find a SessionTimeSlot
     * @example
     * // Get one SessionTimeSlot
     * const sessionTimeSlot = await prisma.sessionTimeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionTimeSlotFindFirstArgs>(args?: SelectSubset<T, SessionTimeSlotFindFirstArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotFindFirstOrThrowArgs} args - Arguments to find a SessionTimeSlot
     * @example
     * // Get one SessionTimeSlot
     * const sessionTimeSlot = await prisma.sessionTimeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionTimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionTimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionTimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionTimeSlots
     * const sessionTimeSlots = await prisma.sessionTimeSlot.findMany()
     * 
     * // Get first 10 SessionTimeSlots
     * const sessionTimeSlots = await prisma.sessionTimeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionTimeSlotWithIdOnly = await prisma.sessionTimeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionTimeSlotFindManyArgs>(args?: SelectSubset<T, SessionTimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionTimeSlot.
     * @param {SessionTimeSlotCreateArgs} args - Arguments to create a SessionTimeSlot.
     * @example
     * // Create one SessionTimeSlot
     * const SessionTimeSlot = await prisma.sessionTimeSlot.create({
     *   data: {
     *     // ... data to create a SessionTimeSlot
     *   }
     * })
     * 
     */
    create<T extends SessionTimeSlotCreateArgs>(args: SelectSubset<T, SessionTimeSlotCreateArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionTimeSlots.
     * @param {SessionTimeSlotCreateManyArgs} args - Arguments to create many SessionTimeSlots.
     * @example
     * // Create many SessionTimeSlots
     * const sessionTimeSlot = await prisma.sessionTimeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionTimeSlotCreateManyArgs>(args?: SelectSubset<T, SessionTimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionTimeSlots and returns the data saved in the database.
     * @param {SessionTimeSlotCreateManyAndReturnArgs} args - Arguments to create many SessionTimeSlots.
     * @example
     * // Create many SessionTimeSlots
     * const sessionTimeSlot = await prisma.sessionTimeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionTimeSlots and only return the `id`
     * const sessionTimeSlotWithIdOnly = await prisma.sessionTimeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionTimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionTimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionTimeSlot.
     * @param {SessionTimeSlotDeleteArgs} args - Arguments to delete one SessionTimeSlot.
     * @example
     * // Delete one SessionTimeSlot
     * const SessionTimeSlot = await prisma.sessionTimeSlot.delete({
     *   where: {
     *     // ... filter to delete one SessionTimeSlot
     *   }
     * })
     * 
     */
    delete<T extends SessionTimeSlotDeleteArgs>(args: SelectSubset<T, SessionTimeSlotDeleteArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionTimeSlot.
     * @param {SessionTimeSlotUpdateArgs} args - Arguments to update one SessionTimeSlot.
     * @example
     * // Update one SessionTimeSlot
     * const sessionTimeSlot = await prisma.sessionTimeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionTimeSlotUpdateArgs>(args: SelectSubset<T, SessionTimeSlotUpdateArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionTimeSlots.
     * @param {SessionTimeSlotDeleteManyArgs} args - Arguments to filter SessionTimeSlots to delete.
     * @example
     * // Delete a few SessionTimeSlots
     * const { count } = await prisma.sessionTimeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionTimeSlotDeleteManyArgs>(args?: SelectSubset<T, SessionTimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionTimeSlots
     * const sessionTimeSlot = await prisma.sessionTimeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionTimeSlotUpdateManyArgs>(args: SelectSubset<T, SessionTimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTimeSlots and returns the data updated in the database.
     * @param {SessionTimeSlotUpdateManyAndReturnArgs} args - Arguments to update many SessionTimeSlots.
     * @example
     * // Update many SessionTimeSlots
     * const sessionTimeSlot = await prisma.sessionTimeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionTimeSlots and only return the `id`
     * const sessionTimeSlotWithIdOnly = await prisma.sessionTimeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionTimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionTimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionTimeSlot.
     * @param {SessionTimeSlotUpsertArgs} args - Arguments to update or create a SessionTimeSlot.
     * @example
     * // Update or create a SessionTimeSlot
     * const sessionTimeSlot = await prisma.sessionTimeSlot.upsert({
     *   create: {
     *     // ... data to create a SessionTimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionTimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends SessionTimeSlotUpsertArgs>(args: SelectSubset<T, SessionTimeSlotUpsertArgs<ExtArgs>>): Prisma__SessionTimeSlotClient<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionTimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotCountArgs} args - Arguments to filter SessionTimeSlots to count.
     * @example
     * // Count the number of SessionTimeSlots
     * const count = await prisma.sessionTimeSlot.count({
     *   where: {
     *     // ... the filter for the SessionTimeSlots we want to count
     *   }
     * })
    **/
    count<T extends SessionTimeSlotCountArgs>(
      args?: Subset<T, SessionTimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionTimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionTimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionTimeSlotAggregateArgs>(args: Subset<T, SessionTimeSlotAggregateArgs>): Prisma.PrismaPromise<GetSessionTimeSlotAggregateType<T>>

    /**
     * Group by SessionTimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionTimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionTimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: SessionTimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionTimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionTimeSlot model
   */
  readonly fields: SessionTimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionTimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionTimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionTimeSlot$sessionArgs<ExtArgs> = {}>(args?: Subset<T, SessionTimeSlot$sessionArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionTimeSlot model
   */
  interface SessionTimeSlotFieldRefs {
    readonly id: FieldRef<"SessionTimeSlot", 'String'>
    readonly sessionId: FieldRef<"SessionTimeSlot", 'String'>
    readonly startTime: FieldRef<"SessionTimeSlot", 'DateTime'>
    readonly endTime: FieldRef<"SessionTimeSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionTimeSlot findUnique
   */
  export type SessionTimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which SessionTimeSlot to fetch.
     */
    where: SessionTimeSlotWhereUniqueInput
  }

  /**
   * SessionTimeSlot findUniqueOrThrow
   */
  export type SessionTimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which SessionTimeSlot to fetch.
     */
    where: SessionTimeSlotWhereUniqueInput
  }

  /**
   * SessionTimeSlot findFirst
   */
  export type SessionTimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which SessionTimeSlot to fetch.
     */
    where?: SessionTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTimeSlots to fetch.
     */
    orderBy?: SessionTimeSlotOrderByWithRelationInput | SessionTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTimeSlots.
     */
    cursor?: SessionTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTimeSlots.
     */
    distinct?: SessionTimeSlotScalarFieldEnum | SessionTimeSlotScalarFieldEnum[]
  }

  /**
   * SessionTimeSlot findFirstOrThrow
   */
  export type SessionTimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which SessionTimeSlot to fetch.
     */
    where?: SessionTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTimeSlots to fetch.
     */
    orderBy?: SessionTimeSlotOrderByWithRelationInput | SessionTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTimeSlots.
     */
    cursor?: SessionTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTimeSlots.
     */
    distinct?: SessionTimeSlotScalarFieldEnum | SessionTimeSlotScalarFieldEnum[]
  }

  /**
   * SessionTimeSlot findMany
   */
  export type SessionTimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which SessionTimeSlots to fetch.
     */
    where?: SessionTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTimeSlots to fetch.
     */
    orderBy?: SessionTimeSlotOrderByWithRelationInput | SessionTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionTimeSlots.
     */
    cursor?: SessionTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTimeSlots.
     */
    skip?: number
    distinct?: SessionTimeSlotScalarFieldEnum | SessionTimeSlotScalarFieldEnum[]
  }

  /**
   * SessionTimeSlot create
   */
  export type SessionTimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionTimeSlot.
     */
    data: XOR<SessionTimeSlotCreateInput, SessionTimeSlotUncheckedCreateInput>
  }

  /**
   * SessionTimeSlot createMany
   */
  export type SessionTimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionTimeSlots.
     */
    data: SessionTimeSlotCreateManyInput | SessionTimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionTimeSlot createManyAndReturn
   */
  export type SessionTimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many SessionTimeSlots.
     */
    data: SessionTimeSlotCreateManyInput | SessionTimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTimeSlot update
   */
  export type SessionTimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionTimeSlot.
     */
    data: XOR<SessionTimeSlotUpdateInput, SessionTimeSlotUncheckedUpdateInput>
    /**
     * Choose, which SessionTimeSlot to update.
     */
    where: SessionTimeSlotWhereUniqueInput
  }

  /**
   * SessionTimeSlot updateMany
   */
  export type SessionTimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionTimeSlots.
     */
    data: XOR<SessionTimeSlotUpdateManyMutationInput, SessionTimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which SessionTimeSlots to update
     */
    where?: SessionTimeSlotWhereInput
    /**
     * Limit how many SessionTimeSlots to update.
     */
    limit?: number
  }

  /**
   * SessionTimeSlot updateManyAndReturn
   */
  export type SessionTimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update SessionTimeSlots.
     */
    data: XOR<SessionTimeSlotUpdateManyMutationInput, SessionTimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which SessionTimeSlots to update
     */
    where?: SessionTimeSlotWhereInput
    /**
     * Limit how many SessionTimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTimeSlot upsert
   */
  export type SessionTimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionTimeSlot to update in case it exists.
     */
    where: SessionTimeSlotWhereUniqueInput
    /**
     * In case the SessionTimeSlot found by the `where` argument doesn't exist, create a new SessionTimeSlot with this data.
     */
    create: XOR<SessionTimeSlotCreateInput, SessionTimeSlotUncheckedCreateInput>
    /**
     * In case the SessionTimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionTimeSlotUpdateInput, SessionTimeSlotUncheckedUpdateInput>
  }

  /**
   * SessionTimeSlot delete
   */
  export type SessionTimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    /**
     * Filter which SessionTimeSlot to delete.
     */
    where: SessionTimeSlotWhereUniqueInput
  }

  /**
   * SessionTimeSlot deleteMany
   */
  export type SessionTimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTimeSlots to delete
     */
    where?: SessionTimeSlotWhereInput
    /**
     * Limit how many SessionTimeSlots to delete.
     */
    limit?: number
  }

  /**
   * SessionTimeSlot.session
   */
  export type SessionTimeSlot$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    where?: SessionsWhereInput
  }

  /**
   * SessionTimeSlot without action
   */
  export type SessionTimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model Events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    visibility: $Enums.EventVisibility | null
    state: $Enums.state | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type EventsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    visibility: $Enums.EventVisibility | null
    state: $Enums.state | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    startTime: number
    endTime: number
    location: number
    tags: number
    visibility: number
    state: number
    createdAt: number
    updatedAt: number
    creatorId: number
    _all: number
  }


  export type EventsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    startTime?: true
    endTime?: true
    location?: true
    visibility?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    startTime?: true
    endTime?: true
    location?: true
    visibility?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    startTime?: true
    endTime?: true
    location?: true
    tags?: true
    visibility?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to aggregate.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithAggregationInput | EventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date
    startTime: Date
    endTime: Date
    location: string | null
    tags: $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt: Date
    updatedAt: Date
    creatorId: string
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    tags?: boolean
    visibility?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    timeSlots?: boolean | Events$timeSlotsArgs<ExtArgs>
    groups?: boolean | Events$groupsArgs<ExtArgs>
    tasks?: boolean | Events$tasksArgs<ExtArgs>
    participants?: boolean | Events$participantsArgs<ExtArgs>
    attendance?: boolean | Events$attendanceArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    tags?: boolean
    visibility?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    tags?: boolean
    visibility?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    tags?: boolean
    visibility?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
  }

  export type EventsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "startTime" | "endTime" | "location" | "tags" | "visibility" | "state" | "createdAt" | "updatedAt" | "creatorId", ExtArgs["result"]["events"]>
  export type EventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    timeSlots?: boolean | Events$timeSlotsArgs<ExtArgs>
    groups?: boolean | Events$groupsArgs<ExtArgs>
    tasks?: boolean | Events$tasksArgs<ExtArgs>
    participants?: boolean | Events$participantsArgs<ExtArgs>
    attendance?: boolean | Events$attendanceArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Events"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      timeSlots: Prisma.$EventTimeSlotPayload<ExtArgs>[]
      groups: Prisma.$GroupsPayload<ExtArgs>[]
      tasks: Prisma.$TasksPayload<ExtArgs>[]
      participants: Prisma.$EventParticipationPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date
      startTime: Date
      endTime: Date
      location: string | null
      tags: $Enums.Tag[]
      visibility: $Enums.EventVisibility
      state: $Enums.state
      createdAt: Date
      updatedAt: Date
      creatorId: string
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type EventsGetPayload<S extends boolean | null | undefined | EventsDefaultArgs> = $Result.GetResult<Prisma.$EventsPayload, S>

  type EventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface EventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Events'], meta: { name: 'Events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsFindUniqueArgs>(args: SelectSubset<T, EventsFindUniqueArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsFindFirstArgs>(args?: SelectSubset<T, EventsFindFirstArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventsFindManyArgs>(args?: SelectSubset<T, EventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends EventsCreateArgs>(args: SelectSubset<T, EventsCreateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsCreateManyArgs>(args?: SelectSubset<T, EventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventsCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends EventsDeleteArgs>(args: SelectSubset<T, EventsDeleteArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsUpdateArgs>(args: SelectSubset<T, EventsUpdateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsDeleteManyArgs>(args?: SelectSubset<T, EventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsUpdateManyArgs>(args: SelectSubset<T, EventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventsUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventsUpdateManyAndReturnArgs>(args: SelectSubset<T, EventsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends EventsUpsertArgs>(args: SelectSubset<T, EventsUpsertArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Events model
   */
  readonly fields: EventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timeSlots<T extends Events$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Events$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Events$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Events$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Events$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Events$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participants<T extends Events$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Events$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Events$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Events$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Events model
   */
  interface EventsFieldRefs {
    readonly id: FieldRef<"Events", 'String'>
    readonly title: FieldRef<"Events", 'String'>
    readonly description: FieldRef<"Events", 'String'>
    readonly startDate: FieldRef<"Events", 'DateTime'>
    readonly startTime: FieldRef<"Events", 'DateTime'>
    readonly endTime: FieldRef<"Events", 'DateTime'>
    readonly location: FieldRef<"Events", 'String'>
    readonly tags: FieldRef<"Events", 'Tag[]'>
    readonly visibility: FieldRef<"Events", 'EventVisibility'>
    readonly state: FieldRef<"Events", 'state'>
    readonly createdAt: FieldRef<"Events", 'DateTime'>
    readonly updatedAt: FieldRef<"Events", 'DateTime'>
    readonly creatorId: FieldRef<"Events", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findMany
   */
  export type EventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events create
   */
  export type EventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to create a Events.
     */
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }

  /**
   * Events createMany
   */
  export type EventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Events createManyAndReturn
   */
  export type EventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Events update
   */
  export type EventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to update a Events.
     */
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Events updateManyAndReturn
   */
  export type EventsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Events upsert
   */
  export type EventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The filter to search for the Events to update in case it exists.
     */
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     */
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }

  /**
   * Events delete
   */
  export type EventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter which Events to delete.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Events.timeSlots
   */
  export type Events$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTimeSlot
     */
    select?: EventTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTimeSlot
     */
    omit?: EventTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTimeSlotInclude<ExtArgs> | null
    where?: EventTimeSlotWhereInput
    orderBy?: EventTimeSlotOrderByWithRelationInput | EventTimeSlotOrderByWithRelationInput[]
    cursor?: EventTimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventTimeSlotScalarFieldEnum | EventTimeSlotScalarFieldEnum[]
  }

  /**
   * Events.groups
   */
  export type Events$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    cursor?: GroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Events.tasks
   */
  export type Events$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    cursor?: TasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Events.participants
   */
  export type Events$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    where?: EventParticipationWhereInput
    orderBy?: EventParticipationOrderByWithRelationInput | EventParticipationOrderByWithRelationInput[]
    cursor?: EventParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventParticipationScalarFieldEnum | EventParticipationScalarFieldEnum[]
  }

  /**
   * Events.attendance
   */
  export type Events$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Events without action
   */
  export type EventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
  }


  /**
   * Model Sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startMonth: Date | null
    endTMonth: Date | null
    location: string | null
    state: $Enums.state | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startMonth: Date | null
    endTMonth: Date | null
    location: string | null
    state: $Enums.state | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startMonth: number
    endTMonth: number
    location: number
    tags: number
    state: number
    createdAt: number
    updatedAt: number
    creatorId: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startMonth?: true
    endTMonth?: true
    location?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startMonth?: true
    endTMonth?: true
    location?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startMonth?: true
    endTMonth?: true
    location?: true
    tags?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to aggregate.
     */
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type SessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionsWhereInput
    orderBy?: SessionsOrderByWithAggregationInput | SessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: SessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startMonth: Date
    endTMonth: Date
    location: string | null
    tags: $Enums.Tag[]
    state: $Enums.state
    createdAt: Date
    updatedAt: Date
    creatorId: string
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends SessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type SessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startMonth?: boolean
    endTMonth?: boolean
    location?: boolean
    tags?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    division?: boolean | Sessions$divisionArgs<ExtArgs>
    timeSlot?: boolean | Sessions$timeSlotArgs<ExtArgs>
    targetGroups?: boolean | Sessions$targetGroupsArgs<ExtArgs>
    tasks?: boolean | Sessions$tasksArgs<ExtArgs>
    participants?: boolean | Sessions$participantsArgs<ExtArgs>
    attendance?: boolean | Sessions$attendanceArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type SessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startMonth?: boolean
    endTMonth?: boolean
    location?: boolean
    tags?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type SessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startMonth?: boolean
    endTMonth?: boolean
    location?: boolean
    tags?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type SessionsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startMonth?: boolean
    endTMonth?: boolean
    location?: boolean
    tags?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
  }

  export type SessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startMonth" | "endTMonth" | "location" | "tags" | "state" | "createdAt" | "updatedAt" | "creatorId", ExtArgs["result"]["sessions"]>
  export type SessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    division?: boolean | Sessions$divisionArgs<ExtArgs>
    timeSlot?: boolean | Sessions$timeSlotArgs<ExtArgs>
    targetGroups?: boolean | Sessions$targetGroupsArgs<ExtArgs>
    tasks?: boolean | Sessions$tasksArgs<ExtArgs>
    participants?: boolean | Sessions$participantsArgs<ExtArgs>
    attendance?: boolean | Sessions$attendanceArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sessions"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      division: Prisma.$DivisionsPayload<ExtArgs>[]
      timeSlot: Prisma.$SessionTimeSlotPayload<ExtArgs>[]
      targetGroups: Prisma.$GroupsPayload<ExtArgs>[]
      tasks: Prisma.$TasksPayload<ExtArgs>[]
      participants: Prisma.$SessionParticipationPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startMonth: Date
      endTMonth: Date
      location: string | null
      tags: $Enums.Tag[]
      state: $Enums.state
      createdAt: Date
      updatedAt: Date
      creatorId: string
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type SessionsGetPayload<S extends boolean | null | undefined | SessionsDefaultArgs> = $Result.GetResult<Prisma.$SessionsPayload, S>

  type SessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface SessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sessions'], meta: { name: 'Sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {SessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionsFindUniqueArgs>(args: SelectSubset<T, SessionsFindUniqueArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionsFindFirstArgs>(args?: SelectSubset<T, SessionsFindFirstArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionsFindManyArgs>(args?: SelectSubset<T, SessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {SessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends SessionsCreateArgs>(args: SelectSubset<T, SessionsCreateArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionsCreateManyArgs>(args?: SelectSubset<T, SessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionsCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessions.
     * @param {SessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends SessionsDeleteArgs>(args: SelectSubset<T, SessionsDeleteArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {SessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionsUpdateArgs>(args: SelectSubset<T, SessionsUpdateArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionsDeleteManyArgs>(args?: SelectSubset<T, SessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionsUpdateManyArgs>(args: SelectSubset<T, SessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionsUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessions.
     * @param {SessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends SessionsUpsertArgs>(args: SelectSubset<T, SessionsUpsertArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionsCountArgs>(
      args?: Subset<T, SessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionsGroupByArgs['orderBy'] }
        : { orderBy?: SessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sessions model
   */
  readonly fields: SessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    division<T extends Sessions$divisionArgs<ExtArgs> = {}>(args?: Subset<T, Sessions$divisionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeSlot<T extends Sessions$timeSlotArgs<ExtArgs> = {}>(args?: Subset<T, Sessions$timeSlotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetGroups<T extends Sessions$targetGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Sessions$targetGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Sessions$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Sessions$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participants<T extends Sessions$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Sessions$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Sessions$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Sessions$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sessions model
   */
  interface SessionsFieldRefs {
    readonly id: FieldRef<"Sessions", 'String'>
    readonly title: FieldRef<"Sessions", 'String'>
    readonly description: FieldRef<"Sessions", 'String'>
    readonly startMonth: FieldRef<"Sessions", 'DateTime'>
    readonly endTMonth: FieldRef<"Sessions", 'DateTime'>
    readonly location: FieldRef<"Sessions", 'String'>
    readonly tags: FieldRef<"Sessions", 'Tag[]'>
    readonly state: FieldRef<"Sessions", 'state'>
    readonly createdAt: FieldRef<"Sessions", 'DateTime'>
    readonly updatedAt: FieldRef<"Sessions", 'DateTime'>
    readonly creatorId: FieldRef<"Sessions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sessions findUnique
   */
  export type SessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where: SessionsWhereUniqueInput
  }

  /**
   * Sessions findUniqueOrThrow
   */
  export type SessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where: SessionsWhereUniqueInput
  }

  /**
   * Sessions findFirst
   */
  export type SessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * Sessions findFirstOrThrow
   */
  export type SessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * Sessions findMany
   */
  export type SessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionsOrderByWithRelationInput | SessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * Sessions create
   */
  export type SessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Sessions.
     */
    data: XOR<SessionsCreateInput, SessionsUncheckedCreateInput>
  }

  /**
   * Sessions createMany
   */
  export type SessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionsCreateManyInput | SessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sessions createManyAndReturn
   */
  export type SessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionsCreateManyInput | SessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sessions update
   */
  export type SessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Sessions.
     */
    data: XOR<SessionsUpdateInput, SessionsUncheckedUpdateInput>
    /**
     * Choose, which Sessions to update.
     */
    where: SessionsWhereUniqueInput
  }

  /**
   * Sessions updateMany
   */
  export type SessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionsWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Sessions updateManyAndReturn
   */
  export type SessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionsWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sessions upsert
   */
  export type SessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Sessions to update in case it exists.
     */
    where: SessionsWhereUniqueInput
    /**
     * In case the Sessions found by the `where` argument doesn't exist, create a new Sessions with this data.
     */
    create: XOR<SessionsCreateInput, SessionsUncheckedCreateInput>
    /**
     * In case the Sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionsUpdateInput, SessionsUncheckedUpdateInput>
  }

  /**
   * Sessions delete
   */
  export type SessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    /**
     * Filter which Sessions to delete.
     */
    where: SessionsWhereUniqueInput
  }

  /**
   * Sessions deleteMany
   */
  export type SessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionsWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Sessions.division
   */
  export type Sessions$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Divisions
     */
    select?: DivisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Divisions
     */
    omit?: DivisionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionsInclude<ExtArgs> | null
    where?: DivisionsWhereInput
    orderBy?: DivisionsOrderByWithRelationInput | DivisionsOrderByWithRelationInput[]
    cursor?: DivisionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }

  /**
   * Sessions.timeSlot
   */
  export type Sessions$timeSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTimeSlot
     */
    select?: SessionTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTimeSlot
     */
    omit?: SessionTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTimeSlotInclude<ExtArgs> | null
    where?: SessionTimeSlotWhereInput
    orderBy?: SessionTimeSlotOrderByWithRelationInput | SessionTimeSlotOrderByWithRelationInput[]
    cursor?: SessionTimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionTimeSlotScalarFieldEnum | SessionTimeSlotScalarFieldEnum[]
  }

  /**
   * Sessions.targetGroups
   */
  export type Sessions$targetGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    cursor?: GroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Sessions.tasks
   */
  export type Sessions$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    cursor?: TasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Sessions.participants
   */
  export type Sessions$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    where?: SessionParticipationWhereInput
    orderBy?: SessionParticipationOrderByWithRelationInput | SessionParticipationOrderByWithRelationInput[]
    cursor?: SessionParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionParticipationScalarFieldEnum | SessionParticipationScalarFieldEnum[]
  }

  /**
   * Sessions.attendance
   */
  export type Sessions$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Sessions without action
   */
  export type SessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
  }


  /**
   * Model Tasks
   */

  export type AggregateTasks = {
    _count: TasksCountAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  export type TasksMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    status: $Enums.TaskStatus | null
    completedNotes: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    eventId: string | null
    sessionId: string | null
  }

  export type TasksMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    status: $Enums.TaskStatus | null
    completedNotes: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    eventId: string | null
    sessionId: string | null
  }

  export type TasksCountAggregateOutputType = {
    id: number
    title: number
    description: number
    dueDate: number
    status: number
    completedNotes: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    creatorId: number
    eventId: number
    sessionId: number
    _all: number
  }


  export type TasksMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    dueDate?: true
    status?: true
    completedNotes?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    eventId?: true
    sessionId?: true
  }

  export type TasksMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    dueDate?: true
    status?: true
    completedNotes?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    eventId?: true
    sessionId?: true
  }

  export type TasksCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    dueDate?: true
    status?: true
    completedNotes?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    eventId?: true
    sessionId?: true
    _all?: true
  }

  export type TasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to aggregate.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksMaxAggregateInputType
  }

  export type GetTasksAggregateType<T extends TasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasks[P]>
      : GetScalarType<T[P], AggregateTasks[P]>
  }




  export type TasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithAggregationInput | TasksOrderByWithAggregationInput[]
    by: TasksScalarFieldEnum[] | TasksScalarFieldEnum
    having?: TasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCountAggregateInputType | true
    _min?: TasksMinAggregateInputType
    _max?: TasksMaxAggregateInputType
  }

  export type TasksGroupByOutputType = {
    id: string
    title: string
    description: string | null
    dueDate: Date
    status: $Enums.TaskStatus
    completedNotes: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    creatorId: string
    eventId: string | null
    sessionId: string | null
    _count: TasksCountAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  type GetTasksGroupByPayload<T extends TasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksGroupByOutputType[P]>
            : GetScalarType<T[P], TasksGroupByOutputType[P]>
        }
      >
    >


  export type TasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    completedNotes?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    eventId?: boolean
    sessionId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Tasks$assignedToArgs<ExtArgs>
    event?: boolean | Tasks$eventArgs<ExtArgs>
    session?: boolean | Tasks$sessionArgs<ExtArgs>
    participants?: boolean | Tasks$participantsArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    completedNotes?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    eventId?: boolean
    sessionId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | Tasks$eventArgs<ExtArgs>
    session?: boolean | Tasks$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    completedNotes?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    eventId?: boolean
    sessionId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | Tasks$eventArgs<ExtArgs>
    session?: boolean | Tasks$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    completedNotes?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    eventId?: boolean
    sessionId?: boolean
  }

  export type TasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "dueDate" | "status" | "completedNotes" | "approvedAt" | "createdAt" | "updatedAt" | "creatorId" | "eventId" | "sessionId", ExtArgs["result"]["tasks"]>
  export type TasksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Tasks$assignedToArgs<ExtArgs>
    event?: boolean | Tasks$eventArgs<ExtArgs>
    session?: boolean | Tasks$sessionArgs<ExtArgs>
    participants?: boolean | Tasks$participantsArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TasksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | Tasks$eventArgs<ExtArgs>
    session?: boolean | Tasks$sessionArgs<ExtArgs>
  }
  export type TasksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | Tasks$eventArgs<ExtArgs>
    session?: boolean | Tasks$sessionArgs<ExtArgs>
  }

  export type $TasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tasks"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs>[]
      event: Prisma.$EventsPayload<ExtArgs> | null
      session: Prisma.$SessionsPayload<ExtArgs> | null
      participants: Prisma.$TaskParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      dueDate: Date
      status: $Enums.TaskStatus
      completedNotes: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
      creatorId: string
      eventId: string | null
      sessionId: string | null
    }, ExtArgs["result"]["tasks"]>
    composites: {}
  }

  type TasksGetPayload<S extends boolean | null | undefined | TasksDefaultArgs> = $Result.GetResult<Prisma.$TasksPayload, S>

  type TasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TasksCountAggregateInputType | true
    }

  export interface TasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tasks'], meta: { name: 'Tasks' } }
    /**
     * Find zero or one Tasks that matches the filter.
     * @param {TasksFindUniqueArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksFindUniqueArgs>(args: SelectSubset<T, TasksFindUniqueArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TasksFindUniqueOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksFindFirstArgs>(args?: SelectSubset<T, TasksFindFirstArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.tasks.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksWithIdOnly = await prisma.tasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TasksFindManyArgs>(args?: SelectSubset<T, TasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tasks.
     * @param {TasksCreateArgs} args - Arguments to create a Tasks.
     * @example
     * // Create one Tasks
     * const Tasks = await prisma.tasks.create({
     *   data: {
     *     // ... data to create a Tasks
     *   }
     * })
     * 
     */
    create<T extends TasksCreateArgs>(args: SelectSubset<T, TasksCreateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TasksCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksCreateManyArgs>(args?: SelectSubset<T, TasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TasksCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const tasksWithIdOnly = await prisma.tasks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TasksCreateManyAndReturnArgs>(args?: SelectSubset<T, TasksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tasks.
     * @param {TasksDeleteArgs} args - Arguments to delete one Tasks.
     * @example
     * // Delete one Tasks
     * const Tasks = await prisma.tasks.delete({
     *   where: {
     *     // ... filter to delete one Tasks
     *   }
     * })
     * 
     */
    delete<T extends TasksDeleteArgs>(args: SelectSubset<T, TasksDeleteArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tasks.
     * @param {TasksUpdateArgs} args - Arguments to update one Tasks.
     * @example
     * // Update one Tasks
     * const tasks = await prisma.tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksUpdateArgs>(args: SelectSubset<T, TasksUpdateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TasksDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksDeleteManyArgs>(args?: SelectSubset<T, TasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksUpdateManyArgs>(args: SelectSubset<T, TasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TasksUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const tasksWithIdOnly = await prisma.tasks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TasksUpdateManyAndReturnArgs>(args: SelectSubset<T, TasksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tasks.
     * @param {TasksUpsertArgs} args - Arguments to update or create a Tasks.
     * @example
     * // Update or create a Tasks
     * const tasks = await prisma.tasks.upsert({
     *   create: {
     *     // ... data to create a Tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tasks we want to update
     *   }
     * })
     */
    upsert<T extends TasksUpsertArgs>(args: SelectSubset<T, TasksUpsertArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.tasks.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TasksCountArgs>(
      args?: Subset<T, TasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksAggregateArgs>(args: Subset<T, TasksAggregateArgs>): Prisma.PrismaPromise<GetTasksAggregateType<T>>

    /**
     * Group by Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksGroupByArgs['orderBy'] }
        : { orderBy?: TasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tasks model
   */
  readonly fields: TasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Tasks$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$assignedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    event<T extends Tasks$eventArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$eventArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session<T extends Tasks$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$sessionArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends Tasks$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tasks model
   */
  interface TasksFieldRefs {
    readonly id: FieldRef<"Tasks", 'String'>
    readonly title: FieldRef<"Tasks", 'String'>
    readonly description: FieldRef<"Tasks", 'String'>
    readonly dueDate: FieldRef<"Tasks", 'DateTime'>
    readonly status: FieldRef<"Tasks", 'TaskStatus'>
    readonly completedNotes: FieldRef<"Tasks", 'String'>
    readonly approvedAt: FieldRef<"Tasks", 'DateTime'>
    readonly createdAt: FieldRef<"Tasks", 'DateTime'>
    readonly updatedAt: FieldRef<"Tasks", 'DateTime'>
    readonly creatorId: FieldRef<"Tasks", 'String'>
    readonly eventId: FieldRef<"Tasks", 'String'>
    readonly sessionId: FieldRef<"Tasks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tasks findUnique
   */
  export type TasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findUniqueOrThrow
   */
  export type TasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findFirst
   */
  export type TasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findFirstOrThrow
   */
  export type TasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findMany
   */
  export type TasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks create
   */
  export type TasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to create a Tasks.
     */
    data: XOR<TasksCreateInput, TasksUncheckedCreateInput>
  }

  /**
   * Tasks createMany
   */
  export type TasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tasks createManyAndReturn
   */
  export type TasksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tasks update
   */
  export type TasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to update a Tasks.
     */
    data: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
    /**
     * Choose, which Tasks to update.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks updateMany
   */
  export type TasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Tasks updateManyAndReturn
   */
  export type TasksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tasks upsert
   */
  export type TasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The filter to search for the Tasks to update in case it exists.
     */
    where: TasksWhereUniqueInput
    /**
     * In case the Tasks found by the `where` argument doesn't exist, create a new Tasks with this data.
     */
    create: XOR<TasksCreateInput, TasksUncheckedCreateInput>
    /**
     * In case the Tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
  }

  /**
   * Tasks delete
   */
  export type TasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter which Tasks to delete.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks deleteMany
   */
  export type TasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Tasks.assignedTo
   */
  export type Tasks$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tasks.event
   */
  export type Tasks$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
  }

  /**
   * Tasks.session
   */
  export type Tasks$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    where?: SessionsWhereInput
  }

  /**
   * Tasks.participants
   */
  export type Tasks$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    where?: TaskParticipationWhereInput
    orderBy?: TaskParticipationOrderByWithRelationInput | TaskParticipationOrderByWithRelationInput[]
    cursor?: TaskParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskParticipationScalarFieldEnum | TaskParticipationScalarFieldEnum[]
  }

  /**
   * Tasks without action
   */
  export type TasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
  }


  /**
   * Model EventParticipation
   */

  export type AggregateEventParticipation = {
    _count: EventParticipationCountAggregateOutputType | null
    _avg: EventParticipationAvgAggregateOutputType | null
    _sum: EventParticipationSumAggregateOutputType | null
    _min: EventParticipationMinAggregateOutputType | null
    _max: EventParticipationMaxAggregateOutputType | null
  }

  export type EventParticipationAvgAggregateOutputType = {
    score: number | null
    feedbackScore: number | null
  }

  export type EventParticipationSumAggregateOutputType = {
    score: number | null
    feedbackScore: number | null
  }

  export type EventParticipationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    role: $Enums.EventRole | null
    score: number | null
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type EventParticipationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    role: $Enums.EventRole | null
    score: number | null
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type EventParticipationCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    role: number
    score: number
    feedback: number
    feedbackScore: number
    createdAt: number
    _all: number
  }


  export type EventParticipationAvgAggregateInputType = {
    score?: true
    feedbackScore?: true
  }

  export type EventParticipationSumAggregateInputType = {
    score?: true
    feedbackScore?: true
  }

  export type EventParticipationMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type EventParticipationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type EventParticipationCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
    _all?: true
  }

  export type EventParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventParticipation to aggregate.
     */
    where?: EventParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipations to fetch.
     */
    orderBy?: EventParticipationOrderByWithRelationInput | EventParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventParticipations
    **/
    _count?: true | EventParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventParticipationMaxAggregateInputType
  }

  export type GetEventParticipationAggregateType<T extends EventParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventParticipation[P]>
      : GetScalarType<T[P], AggregateEventParticipation[P]>
  }




  export type EventParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventParticipationWhereInput
    orderBy?: EventParticipationOrderByWithAggregationInput | EventParticipationOrderByWithAggregationInput[]
    by: EventParticipationScalarFieldEnum[] | EventParticipationScalarFieldEnum
    having?: EventParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventParticipationCountAggregateInputType | true
    _avg?: EventParticipationAvgAggregateInputType
    _sum?: EventParticipationSumAggregateInputType
    _min?: EventParticipationMinAggregateInputType
    _max?: EventParticipationMaxAggregateInputType
  }

  export type EventParticipationGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    role: $Enums.EventRole
    score: number
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date
    _count: EventParticipationCountAggregateOutputType | null
    _avg: EventParticipationAvgAggregateOutputType | null
    _sum: EventParticipationSumAggregateOutputType | null
    _min: EventParticipationMinAggregateOutputType | null
    _max: EventParticipationMaxAggregateOutputType | null
  }

  type GetEventParticipationGroupByPayload<T extends EventParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], EventParticipationGroupByOutputType[P]>
        }
      >
    >


  export type EventParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    event?: boolean | EventsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipation"]>

  export type EventParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    event?: boolean | EventsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipation"]>

  export type EventParticipationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    event?: boolean | EventsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventParticipation"]>

  export type EventParticipationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
  }

  export type EventParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "role" | "score" | "feedback" | "feedbackScore" | "createdAt", ExtArgs["result"]["eventParticipation"]>
  export type EventParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventParticipationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventParticipation"
    objects: {
      event: Prisma.$EventsPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      role: $Enums.EventRole
      score: number
      feedback: string | null
      feedbackScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["eventParticipation"]>
    composites: {}
  }

  type EventParticipationGetPayload<S extends boolean | null | undefined | EventParticipationDefaultArgs> = $Result.GetResult<Prisma.$EventParticipationPayload, S>

  type EventParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventParticipationCountAggregateInputType | true
    }

  export interface EventParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventParticipation'], meta: { name: 'EventParticipation' } }
    /**
     * Find zero or one EventParticipation that matches the filter.
     * @param {EventParticipationFindUniqueArgs} args - Arguments to find a EventParticipation
     * @example
     * // Get one EventParticipation
     * const eventParticipation = await prisma.eventParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventParticipationFindUniqueArgs>(args: SelectSubset<T, EventParticipationFindUniqueArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventParticipationFindUniqueOrThrowArgs} args - Arguments to find a EventParticipation
     * @example
     * // Get one EventParticipation
     * const eventParticipation = await prisma.eventParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationFindFirstArgs} args - Arguments to find a EventParticipation
     * @example
     * // Get one EventParticipation
     * const eventParticipation = await prisma.eventParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventParticipationFindFirstArgs>(args?: SelectSubset<T, EventParticipationFindFirstArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationFindFirstOrThrowArgs} args - Arguments to find a EventParticipation
     * @example
     * // Get one EventParticipation
     * const eventParticipation = await prisma.eventParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventParticipations
     * const eventParticipations = await prisma.eventParticipation.findMany()
     * 
     * // Get first 10 EventParticipations
     * const eventParticipations = await prisma.eventParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventParticipationWithIdOnly = await prisma.eventParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventParticipationFindManyArgs>(args?: SelectSubset<T, EventParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventParticipation.
     * @param {EventParticipationCreateArgs} args - Arguments to create a EventParticipation.
     * @example
     * // Create one EventParticipation
     * const EventParticipation = await prisma.eventParticipation.create({
     *   data: {
     *     // ... data to create a EventParticipation
     *   }
     * })
     * 
     */
    create<T extends EventParticipationCreateArgs>(args: SelectSubset<T, EventParticipationCreateArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventParticipations.
     * @param {EventParticipationCreateManyArgs} args - Arguments to create many EventParticipations.
     * @example
     * // Create many EventParticipations
     * const eventParticipation = await prisma.eventParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventParticipationCreateManyArgs>(args?: SelectSubset<T, EventParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventParticipations and returns the data saved in the database.
     * @param {EventParticipationCreateManyAndReturnArgs} args - Arguments to create many EventParticipations.
     * @example
     * // Create many EventParticipations
     * const eventParticipation = await prisma.eventParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventParticipations and only return the `id`
     * const eventParticipationWithIdOnly = await prisma.eventParticipation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, EventParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventParticipation.
     * @param {EventParticipationDeleteArgs} args - Arguments to delete one EventParticipation.
     * @example
     * // Delete one EventParticipation
     * const EventParticipation = await prisma.eventParticipation.delete({
     *   where: {
     *     // ... filter to delete one EventParticipation
     *   }
     * })
     * 
     */
    delete<T extends EventParticipationDeleteArgs>(args: SelectSubset<T, EventParticipationDeleteArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventParticipation.
     * @param {EventParticipationUpdateArgs} args - Arguments to update one EventParticipation.
     * @example
     * // Update one EventParticipation
     * const eventParticipation = await prisma.eventParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventParticipationUpdateArgs>(args: SelectSubset<T, EventParticipationUpdateArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventParticipations.
     * @param {EventParticipationDeleteManyArgs} args - Arguments to filter EventParticipations to delete.
     * @example
     * // Delete a few EventParticipations
     * const { count } = await prisma.eventParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventParticipationDeleteManyArgs>(args?: SelectSubset<T, EventParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventParticipations
     * const eventParticipation = await prisma.eventParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventParticipationUpdateManyArgs>(args: SelectSubset<T, EventParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventParticipations and returns the data updated in the database.
     * @param {EventParticipationUpdateManyAndReturnArgs} args - Arguments to update many EventParticipations.
     * @example
     * // Update many EventParticipations
     * const eventParticipation = await prisma.eventParticipation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventParticipations and only return the `id`
     * const eventParticipationWithIdOnly = await prisma.eventParticipation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventParticipationUpdateManyAndReturnArgs>(args: SelectSubset<T, EventParticipationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventParticipation.
     * @param {EventParticipationUpsertArgs} args - Arguments to update or create a EventParticipation.
     * @example
     * // Update or create a EventParticipation
     * const eventParticipation = await prisma.eventParticipation.upsert({
     *   create: {
     *     // ... data to create a EventParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventParticipation we want to update
     *   }
     * })
     */
    upsert<T extends EventParticipationUpsertArgs>(args: SelectSubset<T, EventParticipationUpsertArgs<ExtArgs>>): Prisma__EventParticipationClient<$Result.GetResult<Prisma.$EventParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationCountArgs} args - Arguments to filter EventParticipations to count.
     * @example
     * // Count the number of EventParticipations
     * const count = await prisma.eventParticipation.count({
     *   where: {
     *     // ... the filter for the EventParticipations we want to count
     *   }
     * })
    **/
    count<T extends EventParticipationCountArgs>(
      args?: Subset<T, EventParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventParticipationAggregateArgs>(args: Subset<T, EventParticipationAggregateArgs>): Prisma.PrismaPromise<GetEventParticipationAggregateType<T>>

    /**
     * Group by EventParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventParticipationGroupByArgs['orderBy'] }
        : { orderBy?: EventParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventParticipation model
   */
  readonly fields: EventParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventsDefaultArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventParticipation model
   */
  interface EventParticipationFieldRefs {
    readonly id: FieldRef<"EventParticipation", 'String'>
    readonly eventId: FieldRef<"EventParticipation", 'String'>
    readonly userId: FieldRef<"EventParticipation", 'String'>
    readonly role: FieldRef<"EventParticipation", 'EventRole'>
    readonly score: FieldRef<"EventParticipation", 'Int'>
    readonly feedback: FieldRef<"EventParticipation", 'String'>
    readonly feedbackScore: FieldRef<"EventParticipation", 'Int'>
    readonly createdAt: FieldRef<"EventParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventParticipation findUnique
   */
  export type EventParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipation to fetch.
     */
    where: EventParticipationWhereUniqueInput
  }

  /**
   * EventParticipation findUniqueOrThrow
   */
  export type EventParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipation to fetch.
     */
    where: EventParticipationWhereUniqueInput
  }

  /**
   * EventParticipation findFirst
   */
  export type EventParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipation to fetch.
     */
    where?: EventParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipations to fetch.
     */
    orderBy?: EventParticipationOrderByWithRelationInput | EventParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventParticipations.
     */
    cursor?: EventParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventParticipations.
     */
    distinct?: EventParticipationScalarFieldEnum | EventParticipationScalarFieldEnum[]
  }

  /**
   * EventParticipation findFirstOrThrow
   */
  export type EventParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipation to fetch.
     */
    where?: EventParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipations to fetch.
     */
    orderBy?: EventParticipationOrderByWithRelationInput | EventParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventParticipations.
     */
    cursor?: EventParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventParticipations.
     */
    distinct?: EventParticipationScalarFieldEnum | EventParticipationScalarFieldEnum[]
  }

  /**
   * EventParticipation findMany
   */
  export type EventParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * Filter, which EventParticipations to fetch.
     */
    where?: EventParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventParticipations to fetch.
     */
    orderBy?: EventParticipationOrderByWithRelationInput | EventParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventParticipations.
     */
    cursor?: EventParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventParticipations.
     */
    skip?: number
    distinct?: EventParticipationScalarFieldEnum | EventParticipationScalarFieldEnum[]
  }

  /**
   * EventParticipation create
   */
  export type EventParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventParticipation.
     */
    data: XOR<EventParticipationCreateInput, EventParticipationUncheckedCreateInput>
  }

  /**
   * EventParticipation createMany
   */
  export type EventParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventParticipations.
     */
    data: EventParticipationCreateManyInput | EventParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventParticipation createManyAndReturn
   */
  export type EventParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * The data used to create many EventParticipations.
     */
    data: EventParticipationCreateManyInput | EventParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventParticipation update
   */
  export type EventParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventParticipation.
     */
    data: XOR<EventParticipationUpdateInput, EventParticipationUncheckedUpdateInput>
    /**
     * Choose, which EventParticipation to update.
     */
    where: EventParticipationWhereUniqueInput
  }

  /**
   * EventParticipation updateMany
   */
  export type EventParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventParticipations.
     */
    data: XOR<EventParticipationUpdateManyMutationInput, EventParticipationUncheckedUpdateManyInput>
    /**
     * Filter which EventParticipations to update
     */
    where?: EventParticipationWhereInput
    /**
     * Limit how many EventParticipations to update.
     */
    limit?: number
  }

  /**
   * EventParticipation updateManyAndReturn
   */
  export type EventParticipationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * The data used to update EventParticipations.
     */
    data: XOR<EventParticipationUpdateManyMutationInput, EventParticipationUncheckedUpdateManyInput>
    /**
     * Filter which EventParticipations to update
     */
    where?: EventParticipationWhereInput
    /**
     * Limit how many EventParticipations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventParticipation upsert
   */
  export type EventParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventParticipation to update in case it exists.
     */
    where: EventParticipationWhereUniqueInput
    /**
     * In case the EventParticipation found by the `where` argument doesn't exist, create a new EventParticipation with this data.
     */
    create: XOR<EventParticipationCreateInput, EventParticipationUncheckedCreateInput>
    /**
     * In case the EventParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventParticipationUpdateInput, EventParticipationUncheckedUpdateInput>
  }

  /**
   * EventParticipation delete
   */
  export type EventParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
    /**
     * Filter which EventParticipation to delete.
     */
    where: EventParticipationWhereUniqueInput
  }

  /**
   * EventParticipation deleteMany
   */
  export type EventParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventParticipations to delete
     */
    where?: EventParticipationWhereInput
    /**
     * Limit how many EventParticipations to delete.
     */
    limit?: number
  }

  /**
   * EventParticipation without action
   */
  export type EventParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventParticipation
     */
    select?: EventParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventParticipation
     */
    omit?: EventParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipationInclude<ExtArgs> | null
  }


  /**
   * Model SessionParticipation
   */

  export type AggregateSessionParticipation = {
    _count: SessionParticipationCountAggregateOutputType | null
    _avg: SessionParticipationAvgAggregateOutputType | null
    _sum: SessionParticipationSumAggregateOutputType | null
    _min: SessionParticipationMinAggregateOutputType | null
    _max: SessionParticipationMaxAggregateOutputType | null
  }

  export type SessionParticipationAvgAggregateOutputType = {
    score: number | null
    feedbackScore: number | null
  }

  export type SessionParticipationSumAggregateOutputType = {
    score: number | null
    feedbackScore: number | null
  }

  export type SessionParticipationMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    role: $Enums.SessionRole | null
    score: number | null
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type SessionParticipationMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    role: $Enums.SessionRole | null
    score: number | null
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type SessionParticipationCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    role: number
    score: number
    feedback: number
    feedbackScore: number
    createdAt: number
    _all: number
  }


  export type SessionParticipationAvgAggregateInputType = {
    score?: true
    feedbackScore?: true
  }

  export type SessionParticipationSumAggregateInputType = {
    score?: true
    feedbackScore?: true
  }

  export type SessionParticipationMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type SessionParticipationMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type SessionParticipationCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
    _all?: true
  }

  export type SessionParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionParticipation to aggregate.
     */
    where?: SessionParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipations to fetch.
     */
    orderBy?: SessionParticipationOrderByWithRelationInput | SessionParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionParticipations
    **/
    _count?: true | SessionParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionParticipationMaxAggregateInputType
  }

  export type GetSessionParticipationAggregateType<T extends SessionParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionParticipation[P]>
      : GetScalarType<T[P], AggregateSessionParticipation[P]>
  }




  export type SessionParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionParticipationWhereInput
    orderBy?: SessionParticipationOrderByWithAggregationInput | SessionParticipationOrderByWithAggregationInput[]
    by: SessionParticipationScalarFieldEnum[] | SessionParticipationScalarFieldEnum
    having?: SessionParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionParticipationCountAggregateInputType | true
    _avg?: SessionParticipationAvgAggregateInputType
    _sum?: SessionParticipationSumAggregateInputType
    _min?: SessionParticipationMinAggregateInputType
    _max?: SessionParticipationMaxAggregateInputType
  }

  export type SessionParticipationGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    role: $Enums.SessionRole
    score: number
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date
    _count: SessionParticipationCountAggregateOutputType | null
    _avg: SessionParticipationAvgAggregateOutputType | null
    _sum: SessionParticipationSumAggregateOutputType | null
    _min: SessionParticipationMinAggregateOutputType | null
    _max: SessionParticipationMaxAggregateOutputType | null
  }

  type GetSessionParticipationGroupByPayload<T extends SessionParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], SessionParticipationGroupByOutputType[P]>
        }
      >
    >


  export type SessionParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    session?: boolean | SessionsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionParticipation"]>

  export type SessionParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    session?: boolean | SessionsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionParticipation"]>

  export type SessionParticipationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    session?: boolean | SessionsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionParticipation"]>

  export type SessionParticipationSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
  }

  export type SessionParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "role" | "score" | "feedback" | "feedbackScore" | "createdAt", ExtArgs["result"]["sessionParticipation"]>
  export type SessionParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionParticipationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionsDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionParticipation"
    objects: {
      session: Prisma.$SessionsPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      role: $Enums.SessionRole
      score: number
      feedback: string | null
      feedbackScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["sessionParticipation"]>
    composites: {}
  }

  type SessionParticipationGetPayload<S extends boolean | null | undefined | SessionParticipationDefaultArgs> = $Result.GetResult<Prisma.$SessionParticipationPayload, S>

  type SessionParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionParticipationCountAggregateInputType | true
    }

  export interface SessionParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionParticipation'], meta: { name: 'SessionParticipation' } }
    /**
     * Find zero or one SessionParticipation that matches the filter.
     * @param {SessionParticipationFindUniqueArgs} args - Arguments to find a SessionParticipation
     * @example
     * // Get one SessionParticipation
     * const sessionParticipation = await prisma.sessionParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionParticipationFindUniqueArgs>(args: SelectSubset<T, SessionParticipationFindUniqueArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionParticipationFindUniqueOrThrowArgs} args - Arguments to find a SessionParticipation
     * @example
     * // Get one SessionParticipation
     * const sessionParticipation = await prisma.sessionParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationFindFirstArgs} args - Arguments to find a SessionParticipation
     * @example
     * // Get one SessionParticipation
     * const sessionParticipation = await prisma.sessionParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionParticipationFindFirstArgs>(args?: SelectSubset<T, SessionParticipationFindFirstArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationFindFirstOrThrowArgs} args - Arguments to find a SessionParticipation
     * @example
     * // Get one SessionParticipation
     * const sessionParticipation = await prisma.sessionParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionParticipations
     * const sessionParticipations = await prisma.sessionParticipation.findMany()
     * 
     * // Get first 10 SessionParticipations
     * const sessionParticipations = await prisma.sessionParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionParticipationWithIdOnly = await prisma.sessionParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionParticipationFindManyArgs>(args?: SelectSubset<T, SessionParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionParticipation.
     * @param {SessionParticipationCreateArgs} args - Arguments to create a SessionParticipation.
     * @example
     * // Create one SessionParticipation
     * const SessionParticipation = await prisma.sessionParticipation.create({
     *   data: {
     *     // ... data to create a SessionParticipation
     *   }
     * })
     * 
     */
    create<T extends SessionParticipationCreateArgs>(args: SelectSubset<T, SessionParticipationCreateArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionParticipations.
     * @param {SessionParticipationCreateManyArgs} args - Arguments to create many SessionParticipations.
     * @example
     * // Create many SessionParticipations
     * const sessionParticipation = await prisma.sessionParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionParticipationCreateManyArgs>(args?: SelectSubset<T, SessionParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionParticipations and returns the data saved in the database.
     * @param {SessionParticipationCreateManyAndReturnArgs} args - Arguments to create many SessionParticipations.
     * @example
     * // Create many SessionParticipations
     * const sessionParticipation = await prisma.sessionParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionParticipations and only return the `id`
     * const sessionParticipationWithIdOnly = await prisma.sessionParticipation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionParticipation.
     * @param {SessionParticipationDeleteArgs} args - Arguments to delete one SessionParticipation.
     * @example
     * // Delete one SessionParticipation
     * const SessionParticipation = await prisma.sessionParticipation.delete({
     *   where: {
     *     // ... filter to delete one SessionParticipation
     *   }
     * })
     * 
     */
    delete<T extends SessionParticipationDeleteArgs>(args: SelectSubset<T, SessionParticipationDeleteArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionParticipation.
     * @param {SessionParticipationUpdateArgs} args - Arguments to update one SessionParticipation.
     * @example
     * // Update one SessionParticipation
     * const sessionParticipation = await prisma.sessionParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionParticipationUpdateArgs>(args: SelectSubset<T, SessionParticipationUpdateArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionParticipations.
     * @param {SessionParticipationDeleteManyArgs} args - Arguments to filter SessionParticipations to delete.
     * @example
     * // Delete a few SessionParticipations
     * const { count } = await prisma.sessionParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionParticipationDeleteManyArgs>(args?: SelectSubset<T, SessionParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionParticipations
     * const sessionParticipation = await prisma.sessionParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionParticipationUpdateManyArgs>(args: SelectSubset<T, SessionParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionParticipations and returns the data updated in the database.
     * @param {SessionParticipationUpdateManyAndReturnArgs} args - Arguments to update many SessionParticipations.
     * @example
     * // Update many SessionParticipations
     * const sessionParticipation = await prisma.sessionParticipation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionParticipations and only return the `id`
     * const sessionParticipationWithIdOnly = await prisma.sessionParticipation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionParticipationUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionParticipationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionParticipation.
     * @param {SessionParticipationUpsertArgs} args - Arguments to update or create a SessionParticipation.
     * @example
     * // Update or create a SessionParticipation
     * const sessionParticipation = await prisma.sessionParticipation.upsert({
     *   create: {
     *     // ... data to create a SessionParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionParticipation we want to update
     *   }
     * })
     */
    upsert<T extends SessionParticipationUpsertArgs>(args: SelectSubset<T, SessionParticipationUpsertArgs<ExtArgs>>): Prisma__SessionParticipationClient<$Result.GetResult<Prisma.$SessionParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationCountArgs} args - Arguments to filter SessionParticipations to count.
     * @example
     * // Count the number of SessionParticipations
     * const count = await prisma.sessionParticipation.count({
     *   where: {
     *     // ... the filter for the SessionParticipations we want to count
     *   }
     * })
    **/
    count<T extends SessionParticipationCountArgs>(
      args?: Subset<T, SessionParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionParticipationAggregateArgs>(args: Subset<T, SessionParticipationAggregateArgs>): Prisma.PrismaPromise<GetSessionParticipationAggregateType<T>>

    /**
     * Group by SessionParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionParticipationGroupByArgs['orderBy'] }
        : { orderBy?: SessionParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionParticipation model
   */
  readonly fields: SessionParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionsDefaultArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionParticipation model
   */
  interface SessionParticipationFieldRefs {
    readonly id: FieldRef<"SessionParticipation", 'String'>
    readonly sessionId: FieldRef<"SessionParticipation", 'String'>
    readonly userId: FieldRef<"SessionParticipation", 'String'>
    readonly role: FieldRef<"SessionParticipation", 'SessionRole'>
    readonly score: FieldRef<"SessionParticipation", 'Int'>
    readonly feedback: FieldRef<"SessionParticipation", 'String'>
    readonly feedbackScore: FieldRef<"SessionParticipation", 'Int'>
    readonly createdAt: FieldRef<"SessionParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionParticipation findUnique
   */
  export type SessionParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipation to fetch.
     */
    where: SessionParticipationWhereUniqueInput
  }

  /**
   * SessionParticipation findUniqueOrThrow
   */
  export type SessionParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipation to fetch.
     */
    where: SessionParticipationWhereUniqueInput
  }

  /**
   * SessionParticipation findFirst
   */
  export type SessionParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipation to fetch.
     */
    where?: SessionParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipations to fetch.
     */
    orderBy?: SessionParticipationOrderByWithRelationInput | SessionParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionParticipations.
     */
    cursor?: SessionParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionParticipations.
     */
    distinct?: SessionParticipationScalarFieldEnum | SessionParticipationScalarFieldEnum[]
  }

  /**
   * SessionParticipation findFirstOrThrow
   */
  export type SessionParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipation to fetch.
     */
    where?: SessionParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipations to fetch.
     */
    orderBy?: SessionParticipationOrderByWithRelationInput | SessionParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionParticipations.
     */
    cursor?: SessionParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionParticipations.
     */
    distinct?: SessionParticipationScalarFieldEnum | SessionParticipationScalarFieldEnum[]
  }

  /**
   * SessionParticipation findMany
   */
  export type SessionParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipations to fetch.
     */
    where?: SessionParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipations to fetch.
     */
    orderBy?: SessionParticipationOrderByWithRelationInput | SessionParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionParticipations.
     */
    cursor?: SessionParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipations.
     */
    skip?: number
    distinct?: SessionParticipationScalarFieldEnum | SessionParticipationScalarFieldEnum[]
  }

  /**
   * SessionParticipation create
   */
  export type SessionParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionParticipation.
     */
    data: XOR<SessionParticipationCreateInput, SessionParticipationUncheckedCreateInput>
  }

  /**
   * SessionParticipation createMany
   */
  export type SessionParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionParticipations.
     */
    data: SessionParticipationCreateManyInput | SessionParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionParticipation createManyAndReturn
   */
  export type SessionParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * The data used to create many SessionParticipations.
     */
    data: SessionParticipationCreateManyInput | SessionParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionParticipation update
   */
  export type SessionParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionParticipation.
     */
    data: XOR<SessionParticipationUpdateInput, SessionParticipationUncheckedUpdateInput>
    /**
     * Choose, which SessionParticipation to update.
     */
    where: SessionParticipationWhereUniqueInput
  }

  /**
   * SessionParticipation updateMany
   */
  export type SessionParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionParticipations.
     */
    data: XOR<SessionParticipationUpdateManyMutationInput, SessionParticipationUncheckedUpdateManyInput>
    /**
     * Filter which SessionParticipations to update
     */
    where?: SessionParticipationWhereInput
    /**
     * Limit how many SessionParticipations to update.
     */
    limit?: number
  }

  /**
   * SessionParticipation updateManyAndReturn
   */
  export type SessionParticipationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * The data used to update SessionParticipations.
     */
    data: XOR<SessionParticipationUpdateManyMutationInput, SessionParticipationUncheckedUpdateManyInput>
    /**
     * Filter which SessionParticipations to update
     */
    where?: SessionParticipationWhereInput
    /**
     * Limit how many SessionParticipations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionParticipation upsert
   */
  export type SessionParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionParticipation to update in case it exists.
     */
    where: SessionParticipationWhereUniqueInput
    /**
     * In case the SessionParticipation found by the `where` argument doesn't exist, create a new SessionParticipation with this data.
     */
    create: XOR<SessionParticipationCreateInput, SessionParticipationUncheckedCreateInput>
    /**
     * In case the SessionParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionParticipationUpdateInput, SessionParticipationUncheckedUpdateInput>
  }

  /**
   * SessionParticipation delete
   */
  export type SessionParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
    /**
     * Filter which SessionParticipation to delete.
     */
    where: SessionParticipationWhereUniqueInput
  }

  /**
   * SessionParticipation deleteMany
   */
  export type SessionParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionParticipations to delete
     */
    where?: SessionParticipationWhereInput
    /**
     * Limit how many SessionParticipations to delete.
     */
    limit?: number
  }

  /**
   * SessionParticipation without action
   */
  export type SessionParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipation
     */
    select?: SessionParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionParticipation
     */
    omit?: SessionParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipationInclude<ExtArgs> | null
  }


  /**
   * Model TaskParticipation
   */

  export type AggregateTaskParticipation = {
    _count: TaskParticipationCountAggregateOutputType | null
    _avg: TaskParticipationAvgAggregateOutputType | null
    _sum: TaskParticipationSumAggregateOutputType | null
    _min: TaskParticipationMinAggregateOutputType | null
    _max: TaskParticipationMaxAggregateOutputType | null
  }

  export type TaskParticipationAvgAggregateOutputType = {
    score: number | null
    feedbackScore: number | null
  }

  export type TaskParticipationSumAggregateOutputType = {
    score: number | null
    feedbackScore: number | null
  }

  export type TaskParticipationMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    role: string | null
    score: number | null
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type TaskParticipationMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    role: string | null
    score: number | null
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type TaskParticipationCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    role: number
    score: number
    feedback: number
    feedbackScore: number
    createdAt: number
    _all: number
  }


  export type TaskParticipationAvgAggregateInputType = {
    score?: true
    feedbackScore?: true
  }

  export type TaskParticipationSumAggregateInputType = {
    score?: true
    feedbackScore?: true
  }

  export type TaskParticipationMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type TaskParticipationMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type TaskParticipationCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    role?: true
    score?: true
    feedback?: true
    feedbackScore?: true
    createdAt?: true
    _all?: true
  }

  export type TaskParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskParticipation to aggregate.
     */
    where?: TaskParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskParticipations to fetch.
     */
    orderBy?: TaskParticipationOrderByWithRelationInput | TaskParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskParticipations
    **/
    _count?: true | TaskParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskParticipationMaxAggregateInputType
  }

  export type GetTaskParticipationAggregateType<T extends TaskParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskParticipation[P]>
      : GetScalarType<T[P], AggregateTaskParticipation[P]>
  }




  export type TaskParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskParticipationWhereInput
    orderBy?: TaskParticipationOrderByWithAggregationInput | TaskParticipationOrderByWithAggregationInput[]
    by: TaskParticipationScalarFieldEnum[] | TaskParticipationScalarFieldEnum
    having?: TaskParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskParticipationCountAggregateInputType | true
    _avg?: TaskParticipationAvgAggregateInputType
    _sum?: TaskParticipationSumAggregateInputType
    _min?: TaskParticipationMinAggregateInputType
    _max?: TaskParticipationMaxAggregateInputType
  }

  export type TaskParticipationGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    role: string
    score: number
    feedback: string | null
    feedbackScore: number | null
    createdAt: Date
    _count: TaskParticipationCountAggregateOutputType | null
    _avg: TaskParticipationAvgAggregateOutputType | null
    _sum: TaskParticipationSumAggregateOutputType | null
    _min: TaskParticipationMinAggregateOutputType | null
    _max: TaskParticipationMaxAggregateOutputType | null
  }

  type GetTaskParticipationGroupByPayload<T extends TaskParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], TaskParticipationGroupByOutputType[P]>
        }
      >
    >


  export type TaskParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskParticipation"]>

  export type TaskParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskParticipation"]>

  export type TaskParticipationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskParticipation"]>

  export type TaskParticipationSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    role?: boolean
    score?: boolean
    feedback?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
  }

  export type TaskParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "role" | "score" | "feedback" | "feedbackScore" | "createdAt", ExtArgs["result"]["taskParticipation"]>
  export type TaskParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskParticipationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskParticipation"
    objects: {
      task: Prisma.$TasksPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      role: string
      score: number
      feedback: string | null
      feedbackScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["taskParticipation"]>
    composites: {}
  }

  type TaskParticipationGetPayload<S extends boolean | null | undefined | TaskParticipationDefaultArgs> = $Result.GetResult<Prisma.$TaskParticipationPayload, S>

  type TaskParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskParticipationCountAggregateInputType | true
    }

  export interface TaskParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskParticipation'], meta: { name: 'TaskParticipation' } }
    /**
     * Find zero or one TaskParticipation that matches the filter.
     * @param {TaskParticipationFindUniqueArgs} args - Arguments to find a TaskParticipation
     * @example
     * // Get one TaskParticipation
     * const taskParticipation = await prisma.taskParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskParticipationFindUniqueArgs>(args: SelectSubset<T, TaskParticipationFindUniqueArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskParticipationFindUniqueOrThrowArgs} args - Arguments to find a TaskParticipation
     * @example
     * // Get one TaskParticipation
     * const taskParticipation = await prisma.taskParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationFindFirstArgs} args - Arguments to find a TaskParticipation
     * @example
     * // Get one TaskParticipation
     * const taskParticipation = await prisma.taskParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskParticipationFindFirstArgs>(args?: SelectSubset<T, TaskParticipationFindFirstArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationFindFirstOrThrowArgs} args - Arguments to find a TaskParticipation
     * @example
     * // Get one TaskParticipation
     * const taskParticipation = await prisma.taskParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskParticipations
     * const taskParticipations = await prisma.taskParticipation.findMany()
     * 
     * // Get first 10 TaskParticipations
     * const taskParticipations = await prisma.taskParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskParticipationWithIdOnly = await prisma.taskParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskParticipationFindManyArgs>(args?: SelectSubset<T, TaskParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskParticipation.
     * @param {TaskParticipationCreateArgs} args - Arguments to create a TaskParticipation.
     * @example
     * // Create one TaskParticipation
     * const TaskParticipation = await prisma.taskParticipation.create({
     *   data: {
     *     // ... data to create a TaskParticipation
     *   }
     * })
     * 
     */
    create<T extends TaskParticipationCreateArgs>(args: SelectSubset<T, TaskParticipationCreateArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskParticipations.
     * @param {TaskParticipationCreateManyArgs} args - Arguments to create many TaskParticipations.
     * @example
     * // Create many TaskParticipations
     * const taskParticipation = await prisma.taskParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskParticipationCreateManyArgs>(args?: SelectSubset<T, TaskParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskParticipations and returns the data saved in the database.
     * @param {TaskParticipationCreateManyAndReturnArgs} args - Arguments to create many TaskParticipations.
     * @example
     * // Create many TaskParticipations
     * const taskParticipation = await prisma.taskParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskParticipations and only return the `id`
     * const taskParticipationWithIdOnly = await prisma.taskParticipation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskParticipation.
     * @param {TaskParticipationDeleteArgs} args - Arguments to delete one TaskParticipation.
     * @example
     * // Delete one TaskParticipation
     * const TaskParticipation = await prisma.taskParticipation.delete({
     *   where: {
     *     // ... filter to delete one TaskParticipation
     *   }
     * })
     * 
     */
    delete<T extends TaskParticipationDeleteArgs>(args: SelectSubset<T, TaskParticipationDeleteArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskParticipation.
     * @param {TaskParticipationUpdateArgs} args - Arguments to update one TaskParticipation.
     * @example
     * // Update one TaskParticipation
     * const taskParticipation = await prisma.taskParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskParticipationUpdateArgs>(args: SelectSubset<T, TaskParticipationUpdateArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskParticipations.
     * @param {TaskParticipationDeleteManyArgs} args - Arguments to filter TaskParticipations to delete.
     * @example
     * // Delete a few TaskParticipations
     * const { count } = await prisma.taskParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskParticipationDeleteManyArgs>(args?: SelectSubset<T, TaskParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskParticipations
     * const taskParticipation = await prisma.taskParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskParticipationUpdateManyArgs>(args: SelectSubset<T, TaskParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskParticipations and returns the data updated in the database.
     * @param {TaskParticipationUpdateManyAndReturnArgs} args - Arguments to update many TaskParticipations.
     * @example
     * // Update many TaskParticipations
     * const taskParticipation = await prisma.taskParticipation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskParticipations and only return the `id`
     * const taskParticipationWithIdOnly = await prisma.taskParticipation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskParticipationUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskParticipationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskParticipation.
     * @param {TaskParticipationUpsertArgs} args - Arguments to update or create a TaskParticipation.
     * @example
     * // Update or create a TaskParticipation
     * const taskParticipation = await prisma.taskParticipation.upsert({
     *   create: {
     *     // ... data to create a TaskParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskParticipation we want to update
     *   }
     * })
     */
    upsert<T extends TaskParticipationUpsertArgs>(args: SelectSubset<T, TaskParticipationUpsertArgs<ExtArgs>>): Prisma__TaskParticipationClient<$Result.GetResult<Prisma.$TaskParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationCountArgs} args - Arguments to filter TaskParticipations to count.
     * @example
     * // Count the number of TaskParticipations
     * const count = await prisma.taskParticipation.count({
     *   where: {
     *     // ... the filter for the TaskParticipations we want to count
     *   }
     * })
    **/
    count<T extends TaskParticipationCountArgs>(
      args?: Subset<T, TaskParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskParticipationAggregateArgs>(args: Subset<T, TaskParticipationAggregateArgs>): Prisma.PrismaPromise<GetTaskParticipationAggregateType<T>>

    /**
     * Group by TaskParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskParticipationGroupByArgs['orderBy'] }
        : { orderBy?: TaskParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskParticipation model
   */
  readonly fields: TaskParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TasksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TasksDefaultArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskParticipation model
   */
  interface TaskParticipationFieldRefs {
    readonly id: FieldRef<"TaskParticipation", 'String'>
    readonly taskId: FieldRef<"TaskParticipation", 'String'>
    readonly userId: FieldRef<"TaskParticipation", 'String'>
    readonly role: FieldRef<"TaskParticipation", 'String'>
    readonly score: FieldRef<"TaskParticipation", 'Int'>
    readonly feedback: FieldRef<"TaskParticipation", 'String'>
    readonly feedbackScore: FieldRef<"TaskParticipation", 'Int'>
    readonly createdAt: FieldRef<"TaskParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskParticipation findUnique
   */
  export type TaskParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TaskParticipation to fetch.
     */
    where: TaskParticipationWhereUniqueInput
  }

  /**
   * TaskParticipation findUniqueOrThrow
   */
  export type TaskParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TaskParticipation to fetch.
     */
    where: TaskParticipationWhereUniqueInput
  }

  /**
   * TaskParticipation findFirst
   */
  export type TaskParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TaskParticipation to fetch.
     */
    where?: TaskParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskParticipations to fetch.
     */
    orderBy?: TaskParticipationOrderByWithRelationInput | TaskParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskParticipations.
     */
    cursor?: TaskParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskParticipations.
     */
    distinct?: TaskParticipationScalarFieldEnum | TaskParticipationScalarFieldEnum[]
  }

  /**
   * TaskParticipation findFirstOrThrow
   */
  export type TaskParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TaskParticipation to fetch.
     */
    where?: TaskParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskParticipations to fetch.
     */
    orderBy?: TaskParticipationOrderByWithRelationInput | TaskParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskParticipations.
     */
    cursor?: TaskParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskParticipations.
     */
    distinct?: TaskParticipationScalarFieldEnum | TaskParticipationScalarFieldEnum[]
  }

  /**
   * TaskParticipation findMany
   */
  export type TaskParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TaskParticipations to fetch.
     */
    where?: TaskParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskParticipations to fetch.
     */
    orderBy?: TaskParticipationOrderByWithRelationInput | TaskParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskParticipations.
     */
    cursor?: TaskParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskParticipations.
     */
    skip?: number
    distinct?: TaskParticipationScalarFieldEnum | TaskParticipationScalarFieldEnum[]
  }

  /**
   * TaskParticipation create
   */
  export type TaskParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskParticipation.
     */
    data: XOR<TaskParticipationCreateInput, TaskParticipationUncheckedCreateInput>
  }

  /**
   * TaskParticipation createMany
   */
  export type TaskParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskParticipations.
     */
    data: TaskParticipationCreateManyInput | TaskParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskParticipation createManyAndReturn
   */
  export type TaskParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * The data used to create many TaskParticipations.
     */
    data: TaskParticipationCreateManyInput | TaskParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskParticipation update
   */
  export type TaskParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskParticipation.
     */
    data: XOR<TaskParticipationUpdateInput, TaskParticipationUncheckedUpdateInput>
    /**
     * Choose, which TaskParticipation to update.
     */
    where: TaskParticipationWhereUniqueInput
  }

  /**
   * TaskParticipation updateMany
   */
  export type TaskParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskParticipations.
     */
    data: XOR<TaskParticipationUpdateManyMutationInput, TaskParticipationUncheckedUpdateManyInput>
    /**
     * Filter which TaskParticipations to update
     */
    where?: TaskParticipationWhereInput
    /**
     * Limit how many TaskParticipations to update.
     */
    limit?: number
  }

  /**
   * TaskParticipation updateManyAndReturn
   */
  export type TaskParticipationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * The data used to update TaskParticipations.
     */
    data: XOR<TaskParticipationUpdateManyMutationInput, TaskParticipationUncheckedUpdateManyInput>
    /**
     * Filter which TaskParticipations to update
     */
    where?: TaskParticipationWhereInput
    /**
     * Limit how many TaskParticipations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskParticipation upsert
   */
  export type TaskParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskParticipation to update in case it exists.
     */
    where: TaskParticipationWhereUniqueInput
    /**
     * In case the TaskParticipation found by the `where` argument doesn't exist, create a new TaskParticipation with this data.
     */
    create: XOR<TaskParticipationCreateInput, TaskParticipationUncheckedCreateInput>
    /**
     * In case the TaskParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskParticipationUpdateInput, TaskParticipationUncheckedUpdateInput>
  }

  /**
   * TaskParticipation delete
   */
  export type TaskParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
    /**
     * Filter which TaskParticipation to delete.
     */
    where: TaskParticipationWhereUniqueInput
  }

  /**
   * TaskParticipation deleteMany
   */
  export type TaskParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskParticipations to delete
     */
    where?: TaskParticipationWhereInput
    /**
     * Limit how many TaskParticipations to delete.
     */
    limit?: number
  }

  /**
   * TaskParticipation without action
   */
  export type TaskParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskParticipation
     */
    select?: TaskParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskParticipation
     */
    omit?: TaskParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskParticipationInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    eventId: string | null
    status: $Enums.AttendanceStatus | null
    timestamp: Date | null
    headsUpId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    eventId: string | null
    status: $Enums.AttendanceStatus | null
    timestamp: Date | null
    headsUpId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    eventId: number
    status: number
    timestamp: number
    headsUpId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    eventId?: true
    status?: true
    timestamp?: true
    headsUpId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    eventId?: true
    status?: true
    timestamp?: true
    headsUpId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    eventId?: true
    status?: true
    timestamp?: true
    headsUpId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    userId: string
    sessionId: string | null
    eventId: string | null
    status: $Enums.AttendanceStatus
    timestamp: Date
    headsUpId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventId?: boolean
    status?: boolean
    timestamp?: boolean
    headsUpId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | Attendance$sessionArgs<ExtArgs>
    event?: boolean | Attendance$eventArgs<ExtArgs>
    headsUp?: boolean | Attendance$headsUpArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventId?: boolean
    status?: boolean
    timestamp?: boolean
    headsUpId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | Attendance$sessionArgs<ExtArgs>
    event?: boolean | Attendance$eventArgs<ExtArgs>
    headsUp?: boolean | Attendance$headsUpArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventId?: boolean
    status?: boolean
    timestamp?: boolean
    headsUpId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | Attendance$sessionArgs<ExtArgs>
    event?: boolean | Attendance$eventArgs<ExtArgs>
    headsUp?: boolean | Attendance$headsUpArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventId?: boolean
    status?: boolean
    timestamp?: boolean
    headsUpId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "eventId" | "status" | "timestamp" | "headsUpId" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | Attendance$sessionArgs<ExtArgs>
    event?: boolean | Attendance$eventArgs<ExtArgs>
    headsUp?: boolean | Attendance$headsUpArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | Attendance$sessionArgs<ExtArgs>
    event?: boolean | Attendance$eventArgs<ExtArgs>
    headsUp?: boolean | Attendance$headsUpArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | Attendance$sessionArgs<ExtArgs>
    event?: boolean | Attendance$eventArgs<ExtArgs>
    headsUp?: boolean | Attendance$headsUpArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      session: Prisma.$SessionsPayload<ExtArgs> | null
      event: Prisma.$EventsPayload<ExtArgs> | null
      headsUp: Prisma.$HeadsUpPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string | null
      eventId: string | null
      status: $Enums.AttendanceStatus
      timestamp: Date
      headsUpId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends Attendance$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$sessionArgs<ExtArgs>>): Prisma__SessionsClient<$Result.GetResult<Prisma.$SessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends Attendance$eventArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$eventArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    headsUp<T extends Attendance$headsUpArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$headsUpArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly sessionId: FieldRef<"Attendance", 'String'>
    readonly eventId: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly timestamp: FieldRef<"Attendance", 'DateTime'>
    readonly headsUpId: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.session
   */
  export type Attendance$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessions
     */
    select?: SessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessions
     */
    omit?: SessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionsInclude<ExtArgs> | null
    where?: SessionsWhereInput
  }

  /**
   * Attendance.event
   */
  export type Attendance$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
  }

  /**
   * Attendance.headsUp
   */
  export type Attendance$headsUpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    where?: HeadsUpWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceSummary
   */

  export type AggregateAttendanceSummary = {
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  export type AttendanceSummaryAvgAggregateOutputType = {
    totalEvents: number | null
    totalSessions: number | null
    totalTasks: number | null
    totalAttendance: number | null
    totalHeadsUps: number | null
    totalPresent: number | null
  }

  export type AttendanceSummarySumAggregateOutputType = {
    totalEvents: number | null
    totalSessions: number | null
    totalTasks: number | null
    totalAttendance: number | null
    totalHeadsUps: number | null
    totalPresent: number | null
  }

  export type AttendanceSummaryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalEvents: number | null
    totalSessions: number | null
    totalTasks: number | null
    totalAttendance: number | null
    totalHeadsUps: number | null
    totalPresent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceSummaryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalEvents: number | null
    totalSessions: number | null
    totalTasks: number | null
    totalAttendance: number | null
    totalHeadsUps: number | null
    totalPresent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceSummaryCountAggregateOutputType = {
    id: number
    userId: number
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceSummaryAvgAggregateInputType = {
    totalEvents?: true
    totalSessions?: true
    totalTasks?: true
    totalAttendance?: true
    totalHeadsUps?: true
    totalPresent?: true
  }

  export type AttendanceSummarySumAggregateInputType = {
    totalEvents?: true
    totalSessions?: true
    totalTasks?: true
    totalAttendance?: true
    totalHeadsUps?: true
    totalPresent?: true
  }

  export type AttendanceSummaryMinAggregateInputType = {
    id?: true
    userId?: true
    totalEvents?: true
    totalSessions?: true
    totalTasks?: true
    totalAttendance?: true
    totalHeadsUps?: true
    totalPresent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceSummaryMaxAggregateInputType = {
    id?: true
    userId?: true
    totalEvents?: true
    totalSessions?: true
    totalTasks?: true
    totalAttendance?: true
    totalHeadsUps?: true
    totalPresent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceSummaryCountAggregateInputType = {
    id?: true
    userId?: true
    totalEvents?: true
    totalSessions?: true
    totalTasks?: true
    totalAttendance?: true
    totalHeadsUps?: true
    totalPresent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummary to aggregate.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceSummaries
    **/
    _count?: true | AttendanceSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type GetAttendanceSummaryAggregateType<T extends AttendanceSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceSummary[P]>
      : GetScalarType<T[P], AggregateAttendanceSummary[P]>
  }




  export type AttendanceSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithAggregationInput | AttendanceSummaryOrderByWithAggregationInput[]
    by: AttendanceSummaryScalarFieldEnum[] | AttendanceSummaryScalarFieldEnum
    having?: AttendanceSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceSummaryCountAggregateInputType | true
    _avg?: AttendanceSummaryAvgAggregateInputType
    _sum?: AttendanceSummarySumAggregateInputType
    _min?: AttendanceSummaryMinAggregateInputType
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type AttendanceSummaryGroupByOutputType = {
    id: string
    userId: string
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt: Date
    updatedAt: Date
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  type GetAttendanceSummaryGroupByPayload<T extends AttendanceSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalEvents?: boolean
    totalSessions?: boolean
    totalTasks?: boolean
    totalAttendance?: boolean
    totalHeadsUps?: boolean
    totalPresent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalEvents?: boolean
    totalSessions?: boolean
    totalTasks?: boolean
    totalAttendance?: boolean
    totalHeadsUps?: boolean
    totalPresent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalEvents?: boolean
    totalSessions?: boolean
    totalTasks?: boolean
    totalAttendance?: boolean
    totalHeadsUps?: boolean
    totalPresent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectScalar = {
    id?: boolean
    userId?: boolean
    totalEvents?: boolean
    totalSessions?: boolean
    totalTasks?: boolean
    totalAttendance?: boolean
    totalHeadsUps?: boolean
    totalPresent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalEvents" | "totalSessions" | "totalTasks" | "totalAttendance" | "totalHeadsUps" | "totalPresent" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceSummary"]>
  export type AttendanceSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceSummary"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalEvents: number
      totalSessions: number
      totalTasks: number
      totalAttendance: number
      totalHeadsUps: number
      totalPresent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceSummary"]>
    composites: {}
  }

  type AttendanceSummaryGetPayload<S extends boolean | null | undefined | AttendanceSummaryDefaultArgs> = $Result.GetResult<Prisma.$AttendanceSummaryPayload, S>

  type AttendanceSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceSummaryCountAggregateInputType | true
    }

  export interface AttendanceSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceSummary'], meta: { name: 'AttendanceSummary' } }
    /**
     * Find zero or one AttendanceSummary that matches the filter.
     * @param {AttendanceSummaryFindUniqueArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceSummaryFindUniqueArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceSummaryFindUniqueOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceSummaryFindFirstArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany()
     * 
     * // Get first 10 AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceSummaryFindManyArgs>(args?: SelectSubset<T, AttendanceSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceSummary.
     * @param {AttendanceSummaryCreateArgs} args - Arguments to create a AttendanceSummary.
     * @example
     * // Create one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.create({
     *   data: {
     *     // ... data to create a AttendanceSummary
     *   }
     * })
     * 
     */
    create<T extends AttendanceSummaryCreateArgs>(args: SelectSubset<T, AttendanceSummaryCreateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceSummaries.
     * @param {AttendanceSummaryCreateManyArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceSummaryCreateManyArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceSummaries and returns the data saved in the database.
     * @param {AttendanceSummaryCreateManyAndReturnArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceSummaries and only return the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceSummary.
     * @param {AttendanceSummaryDeleteArgs} args - Arguments to delete one AttendanceSummary.
     * @example
     * // Delete one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.delete({
     *   where: {
     *     // ... filter to delete one AttendanceSummary
     *   }
     * })
     * 
     */
    delete<T extends AttendanceSummaryDeleteArgs>(args: SelectSubset<T, AttendanceSummaryDeleteArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceSummary.
     * @param {AttendanceSummaryUpdateArgs} args - Arguments to update one AttendanceSummary.
     * @example
     * // Update one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceSummaryUpdateArgs>(args: SelectSubset<T, AttendanceSummaryUpdateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceSummaries.
     * @param {AttendanceSummaryDeleteManyArgs} args - Arguments to filter AttendanceSummaries to delete.
     * @example
     * // Delete a few AttendanceSummaries
     * const { count } = await prisma.attendanceSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceSummaryDeleteManyArgs>(args?: SelectSubset<T, AttendanceSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceSummaryUpdateManyArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries and returns the data updated in the database.
     * @param {AttendanceSummaryUpdateManyAndReturnArgs} args - Arguments to update many AttendanceSummaries.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceSummaries and only return the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceSummary.
     * @param {AttendanceSummaryUpsertArgs} args - Arguments to update or create a AttendanceSummary.
     * @example
     * // Update or create a AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.upsert({
     *   create: {
     *     // ... data to create a AttendanceSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceSummary we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceSummaryUpsertArgs>(args: SelectSubset<T, AttendanceSummaryUpsertArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryCountArgs} args - Arguments to filter AttendanceSummaries to count.
     * @example
     * // Count the number of AttendanceSummaries
     * const count = await prisma.attendanceSummary.count({
     *   where: {
     *     // ... the filter for the AttendanceSummaries we want to count
     *   }
     * })
    **/
    count<T extends AttendanceSummaryCountArgs>(
      args?: Subset<T, AttendanceSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceSummaryAggregateArgs>(args: Subset<T, AttendanceSummaryAggregateArgs>): Prisma.PrismaPromise<GetAttendanceSummaryAggregateType<T>>

    /**
     * Group by AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceSummaryGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceSummary model
   */
  readonly fields: AttendanceSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceSummary model
   */
  interface AttendanceSummaryFieldRefs {
    readonly id: FieldRef<"AttendanceSummary", 'String'>
    readonly userId: FieldRef<"AttendanceSummary", 'String'>
    readonly totalEvents: FieldRef<"AttendanceSummary", 'Int'>
    readonly totalSessions: FieldRef<"AttendanceSummary", 'Int'>
    readonly totalTasks: FieldRef<"AttendanceSummary", 'Int'>
    readonly totalAttendance: FieldRef<"AttendanceSummary", 'Int'>
    readonly totalHeadsUps: FieldRef<"AttendanceSummary", 'Int'>
    readonly totalPresent: FieldRef<"AttendanceSummary", 'Int'>
    readonly createdAt: FieldRef<"AttendanceSummary", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceSummary findUnique
   */
  export type AttendanceSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findUniqueOrThrow
   */
  export type AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findFirst
   */
  export type AttendanceSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findFirstOrThrow
   */
  export type AttendanceSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findMany
   */
  export type AttendanceSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummaries to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary create
   */
  export type AttendanceSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
  }

  /**
   * AttendanceSummary createMany
   */
  export type AttendanceSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceSummary createManyAndReturn
   */
  export type AttendanceSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSummary update
   */
  export type AttendanceSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
    /**
     * Choose, which AttendanceSummary to update.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary updateMany
   */
  export type AttendanceSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
  }

  /**
   * AttendanceSummary updateManyAndReturn
   */
  export type AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSummary upsert
   */
  export type AttendanceSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceSummary to update in case it exists.
     */
    where: AttendanceSummaryWhereUniqueInput
    /**
     * In case the AttendanceSummary found by the `where` argument doesn't exist, create a new AttendanceSummary with this data.
     */
    create: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
    /**
     * In case the AttendanceSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
  }

  /**
   * AttendanceSummary delete
   */
  export type AttendanceSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter which AttendanceSummary to delete.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary deleteMany
   */
  export type AttendanceSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummaries to delete
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to delete.
     */
    limit?: number
  }

  /**
   * AttendanceSummary without action
   */
  export type AttendanceSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
  }


  /**
   * Model HeadsUp
   */

  export type AggregateHeadsUp = {
    _count: HeadsUpCountAggregateOutputType | null
    _min: HeadsUpMinAggregateOutputType | null
    _max: HeadsUpMaxAggregateOutputType | null
  }

  export type HeadsUpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.HeadsUpType | null
    body: string | null
    sentAt: Date | null
  }

  export type HeadsUpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.HeadsUpType | null
    body: string | null
    sentAt: Date | null
  }

  export type HeadsUpCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    body: number
    sentAt: number
    _all: number
  }


  export type HeadsUpMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    body?: true
    sentAt?: true
  }

  export type HeadsUpMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    body?: true
    sentAt?: true
  }

  export type HeadsUpCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    body?: true
    sentAt?: true
    _all?: true
  }

  export type HeadsUpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeadsUp to aggregate.
     */
    where?: HeadsUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeadsUps to fetch.
     */
    orderBy?: HeadsUpOrderByWithRelationInput | HeadsUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeadsUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeadsUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeadsUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeadsUps
    **/
    _count?: true | HeadsUpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeadsUpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeadsUpMaxAggregateInputType
  }

  export type GetHeadsUpAggregateType<T extends HeadsUpAggregateArgs> = {
        [P in keyof T & keyof AggregateHeadsUp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeadsUp[P]>
      : GetScalarType<T[P], AggregateHeadsUp[P]>
  }




  export type HeadsUpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeadsUpWhereInput
    orderBy?: HeadsUpOrderByWithAggregationInput | HeadsUpOrderByWithAggregationInput[]
    by: HeadsUpScalarFieldEnum[] | HeadsUpScalarFieldEnum
    having?: HeadsUpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeadsUpCountAggregateInputType | true
    _min?: HeadsUpMinAggregateInputType
    _max?: HeadsUpMaxAggregateInputType
  }

  export type HeadsUpGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.HeadsUpType
    body: string
    sentAt: Date
    _count: HeadsUpCountAggregateOutputType | null
    _min: HeadsUpMinAggregateOutputType | null
    _max: HeadsUpMaxAggregateOutputType | null
  }

  type GetHeadsUpGroupByPayload<T extends HeadsUpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeadsUpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeadsUpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeadsUpGroupByOutputType[P]>
            : GetScalarType<T[P], HeadsUpGroupByOutputType[P]>
        }
      >
    >


  export type HeadsUpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    body?: boolean
    sentAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attendance?: boolean | HeadsUp$attendanceArgs<ExtArgs>
  }, ExtArgs["result"]["headsUp"]>

  export type HeadsUpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    body?: boolean
    sentAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["headsUp"]>

  export type HeadsUpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    body?: boolean
    sentAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["headsUp"]>

  export type HeadsUpSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    body?: boolean
    sentAt?: boolean
  }

  export type HeadsUpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "body" | "sentAt", ExtArgs["result"]["headsUp"]>
  export type HeadsUpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attendance?: boolean | HeadsUp$attendanceArgs<ExtArgs>
  }
  export type HeadsUpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HeadsUpIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HeadsUpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeadsUp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      attendance: Prisma.$AttendancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.HeadsUpType
      body: string
      sentAt: Date
    }, ExtArgs["result"]["headsUp"]>
    composites: {}
  }

  type HeadsUpGetPayload<S extends boolean | null | undefined | HeadsUpDefaultArgs> = $Result.GetResult<Prisma.$HeadsUpPayload, S>

  type HeadsUpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeadsUpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeadsUpCountAggregateInputType | true
    }

  export interface HeadsUpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeadsUp'], meta: { name: 'HeadsUp' } }
    /**
     * Find zero or one HeadsUp that matches the filter.
     * @param {HeadsUpFindUniqueArgs} args - Arguments to find a HeadsUp
     * @example
     * // Get one HeadsUp
     * const headsUp = await prisma.headsUp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeadsUpFindUniqueArgs>(args: SelectSubset<T, HeadsUpFindUniqueArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeadsUp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeadsUpFindUniqueOrThrowArgs} args - Arguments to find a HeadsUp
     * @example
     * // Get one HeadsUp
     * const headsUp = await prisma.headsUp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeadsUpFindUniqueOrThrowArgs>(args: SelectSubset<T, HeadsUpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeadsUp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpFindFirstArgs} args - Arguments to find a HeadsUp
     * @example
     * // Get one HeadsUp
     * const headsUp = await prisma.headsUp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeadsUpFindFirstArgs>(args?: SelectSubset<T, HeadsUpFindFirstArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeadsUp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpFindFirstOrThrowArgs} args - Arguments to find a HeadsUp
     * @example
     * // Get one HeadsUp
     * const headsUp = await prisma.headsUp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeadsUpFindFirstOrThrowArgs>(args?: SelectSubset<T, HeadsUpFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeadsUps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeadsUps
     * const headsUps = await prisma.headsUp.findMany()
     * 
     * // Get first 10 HeadsUps
     * const headsUps = await prisma.headsUp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const headsUpWithIdOnly = await prisma.headsUp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeadsUpFindManyArgs>(args?: SelectSubset<T, HeadsUpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeadsUp.
     * @param {HeadsUpCreateArgs} args - Arguments to create a HeadsUp.
     * @example
     * // Create one HeadsUp
     * const HeadsUp = await prisma.headsUp.create({
     *   data: {
     *     // ... data to create a HeadsUp
     *   }
     * })
     * 
     */
    create<T extends HeadsUpCreateArgs>(args: SelectSubset<T, HeadsUpCreateArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeadsUps.
     * @param {HeadsUpCreateManyArgs} args - Arguments to create many HeadsUps.
     * @example
     * // Create many HeadsUps
     * const headsUp = await prisma.headsUp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeadsUpCreateManyArgs>(args?: SelectSubset<T, HeadsUpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeadsUps and returns the data saved in the database.
     * @param {HeadsUpCreateManyAndReturnArgs} args - Arguments to create many HeadsUps.
     * @example
     * // Create many HeadsUps
     * const headsUp = await prisma.headsUp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeadsUps and only return the `id`
     * const headsUpWithIdOnly = await prisma.headsUp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeadsUpCreateManyAndReturnArgs>(args?: SelectSubset<T, HeadsUpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HeadsUp.
     * @param {HeadsUpDeleteArgs} args - Arguments to delete one HeadsUp.
     * @example
     * // Delete one HeadsUp
     * const HeadsUp = await prisma.headsUp.delete({
     *   where: {
     *     // ... filter to delete one HeadsUp
     *   }
     * })
     * 
     */
    delete<T extends HeadsUpDeleteArgs>(args: SelectSubset<T, HeadsUpDeleteArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeadsUp.
     * @param {HeadsUpUpdateArgs} args - Arguments to update one HeadsUp.
     * @example
     * // Update one HeadsUp
     * const headsUp = await prisma.headsUp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeadsUpUpdateArgs>(args: SelectSubset<T, HeadsUpUpdateArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeadsUps.
     * @param {HeadsUpDeleteManyArgs} args - Arguments to filter HeadsUps to delete.
     * @example
     * // Delete a few HeadsUps
     * const { count } = await prisma.headsUp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeadsUpDeleteManyArgs>(args?: SelectSubset<T, HeadsUpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeadsUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeadsUps
     * const headsUp = await prisma.headsUp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeadsUpUpdateManyArgs>(args: SelectSubset<T, HeadsUpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeadsUps and returns the data updated in the database.
     * @param {HeadsUpUpdateManyAndReturnArgs} args - Arguments to update many HeadsUps.
     * @example
     * // Update many HeadsUps
     * const headsUp = await prisma.headsUp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HeadsUps and only return the `id`
     * const headsUpWithIdOnly = await prisma.headsUp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HeadsUpUpdateManyAndReturnArgs>(args: SelectSubset<T, HeadsUpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HeadsUp.
     * @param {HeadsUpUpsertArgs} args - Arguments to update or create a HeadsUp.
     * @example
     * // Update or create a HeadsUp
     * const headsUp = await prisma.headsUp.upsert({
     *   create: {
     *     // ... data to create a HeadsUp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeadsUp we want to update
     *   }
     * })
     */
    upsert<T extends HeadsUpUpsertArgs>(args: SelectSubset<T, HeadsUpUpsertArgs<ExtArgs>>): Prisma__HeadsUpClient<$Result.GetResult<Prisma.$HeadsUpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HeadsUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpCountArgs} args - Arguments to filter HeadsUps to count.
     * @example
     * // Count the number of HeadsUps
     * const count = await prisma.headsUp.count({
     *   where: {
     *     // ... the filter for the HeadsUps we want to count
     *   }
     * })
    **/
    count<T extends HeadsUpCountArgs>(
      args?: Subset<T, HeadsUpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeadsUpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeadsUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeadsUpAggregateArgs>(args: Subset<T, HeadsUpAggregateArgs>): Prisma.PrismaPromise<GetHeadsUpAggregateType<T>>

    /**
     * Group by HeadsUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadsUpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeadsUpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeadsUpGroupByArgs['orderBy'] }
        : { orderBy?: HeadsUpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeadsUpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeadsUpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeadsUp model
   */
  readonly fields: HeadsUpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeadsUp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeadsUpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendance<T extends HeadsUp$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, HeadsUp$attendanceArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeadsUp model
   */
  interface HeadsUpFieldRefs {
    readonly id: FieldRef<"HeadsUp", 'String'>
    readonly userId: FieldRef<"HeadsUp", 'String'>
    readonly type: FieldRef<"HeadsUp", 'HeadsUpType'>
    readonly body: FieldRef<"HeadsUp", 'String'>
    readonly sentAt: FieldRef<"HeadsUp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeadsUp findUnique
   */
  export type HeadsUpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * Filter, which HeadsUp to fetch.
     */
    where: HeadsUpWhereUniqueInput
  }

  /**
   * HeadsUp findUniqueOrThrow
   */
  export type HeadsUpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * Filter, which HeadsUp to fetch.
     */
    where: HeadsUpWhereUniqueInput
  }

  /**
   * HeadsUp findFirst
   */
  export type HeadsUpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * Filter, which HeadsUp to fetch.
     */
    where?: HeadsUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeadsUps to fetch.
     */
    orderBy?: HeadsUpOrderByWithRelationInput | HeadsUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeadsUps.
     */
    cursor?: HeadsUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeadsUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeadsUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeadsUps.
     */
    distinct?: HeadsUpScalarFieldEnum | HeadsUpScalarFieldEnum[]
  }

  /**
   * HeadsUp findFirstOrThrow
   */
  export type HeadsUpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * Filter, which HeadsUp to fetch.
     */
    where?: HeadsUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeadsUps to fetch.
     */
    orderBy?: HeadsUpOrderByWithRelationInput | HeadsUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeadsUps.
     */
    cursor?: HeadsUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeadsUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeadsUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeadsUps.
     */
    distinct?: HeadsUpScalarFieldEnum | HeadsUpScalarFieldEnum[]
  }

  /**
   * HeadsUp findMany
   */
  export type HeadsUpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * Filter, which HeadsUps to fetch.
     */
    where?: HeadsUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeadsUps to fetch.
     */
    orderBy?: HeadsUpOrderByWithRelationInput | HeadsUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeadsUps.
     */
    cursor?: HeadsUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeadsUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeadsUps.
     */
    skip?: number
    distinct?: HeadsUpScalarFieldEnum | HeadsUpScalarFieldEnum[]
  }

  /**
   * HeadsUp create
   */
  export type HeadsUpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * The data needed to create a HeadsUp.
     */
    data: XOR<HeadsUpCreateInput, HeadsUpUncheckedCreateInput>
  }

  /**
   * HeadsUp createMany
   */
  export type HeadsUpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeadsUps.
     */
    data: HeadsUpCreateManyInput | HeadsUpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeadsUp createManyAndReturn
   */
  export type HeadsUpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * The data used to create many HeadsUps.
     */
    data: HeadsUpCreateManyInput | HeadsUpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HeadsUp update
   */
  export type HeadsUpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * The data needed to update a HeadsUp.
     */
    data: XOR<HeadsUpUpdateInput, HeadsUpUncheckedUpdateInput>
    /**
     * Choose, which HeadsUp to update.
     */
    where: HeadsUpWhereUniqueInput
  }

  /**
   * HeadsUp updateMany
   */
  export type HeadsUpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeadsUps.
     */
    data: XOR<HeadsUpUpdateManyMutationInput, HeadsUpUncheckedUpdateManyInput>
    /**
     * Filter which HeadsUps to update
     */
    where?: HeadsUpWhereInput
    /**
     * Limit how many HeadsUps to update.
     */
    limit?: number
  }

  /**
   * HeadsUp updateManyAndReturn
   */
  export type HeadsUpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * The data used to update HeadsUps.
     */
    data: XOR<HeadsUpUpdateManyMutationInput, HeadsUpUncheckedUpdateManyInput>
    /**
     * Filter which HeadsUps to update
     */
    where?: HeadsUpWhereInput
    /**
     * Limit how many HeadsUps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HeadsUp upsert
   */
  export type HeadsUpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * The filter to search for the HeadsUp to update in case it exists.
     */
    where: HeadsUpWhereUniqueInput
    /**
     * In case the HeadsUp found by the `where` argument doesn't exist, create a new HeadsUp with this data.
     */
    create: XOR<HeadsUpCreateInput, HeadsUpUncheckedCreateInput>
    /**
     * In case the HeadsUp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeadsUpUpdateInput, HeadsUpUncheckedUpdateInput>
  }

  /**
   * HeadsUp delete
   */
  export type HeadsUpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
    /**
     * Filter which HeadsUp to delete.
     */
    where: HeadsUpWhereUniqueInput
  }

  /**
   * HeadsUp deleteMany
   */
  export type HeadsUpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeadsUps to delete
     */
    where?: HeadsUpWhereInput
    /**
     * Limit how many HeadsUps to delete.
     */
    limit?: number
  }

  /**
   * HeadsUp.attendance
   */
  export type HeadsUp$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
  }

  /**
   * HeadsUp without action
   */
  export type HeadsUpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeadsUp
     */
    select?: HeadsUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeadsUp
     */
    omit?: HeadsUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeadsUpInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly description: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    visibility: $Enums.AnnouncementVisibility | null
    announcementType: $Enums.AnnouncementType | null
    sourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    visibility: $Enums.AnnouncementVisibility | null
    announcementType: $Enums.AnnouncementType | null
    sourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    visibility: number
    Tags: number
    announcementType: number
    sourceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    visibility?: true
    announcementType?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    visibility?: true
    announcementType?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    visibility?: true
    Tags?: true
    announcementType?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    description: string | null
    visibility: $Enums.AnnouncementVisibility
    Tags: $Enums.Tag[]
    announcementType: $Enums.AnnouncementType
    sourceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    Tags?: boolean
    announcementType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Announcement$userArgs<ExtArgs>
    _count?: boolean | AnnouncementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    Tags?: boolean
    announcementType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    Tags?: boolean
    announcementType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    Tags?: boolean
    announcementType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "visibility" | "Tags" | "announcementType" | "sourceId" | "createdAt" | "updatedAt", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Announcement$userArgs<ExtArgs>
    _count?: boolean | AnnouncementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      visibility: $Enums.AnnouncementVisibility
      Tags: $Enums.Tag[]
      announcementType: $Enums.AnnouncementType
      sourceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Announcement$userArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly description: FieldRef<"Announcement", 'String'>
    readonly visibility: FieldRef<"Announcement", 'AnnouncementVisibility'>
    readonly Tags: FieldRef<"Announcement", 'Tag[]'>
    readonly announcementType: FieldRef<"Announcement", 'AnnouncementType'>
    readonly sourceId: FieldRef<"Announcement", 'String'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement.user
   */
  export type Announcement$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model FileCategories
   */

  export type AggregateFileCategories = {
    _count: FileCategoriesCountAggregateOutputType | null
    _min: FileCategoriesMinAggregateOutputType | null
    _max: FileCategoriesMaxAggregateOutputType | null
  }

  export type FileCategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileCategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileCategoriesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileCategoriesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileCategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileCategoriesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileCategories to aggregate.
     */
    where?: FileCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileCategories to fetch.
     */
    orderBy?: FileCategoriesOrderByWithRelationInput | FileCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileCategories
    **/
    _count?: true | FileCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileCategoriesMaxAggregateInputType
  }

  export type GetFileCategoriesAggregateType<T extends FileCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateFileCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileCategories[P]>
      : GetScalarType<T[P], AggregateFileCategories[P]>
  }




  export type FileCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileCategoriesWhereInput
    orderBy?: FileCategoriesOrderByWithAggregationInput | FileCategoriesOrderByWithAggregationInput[]
    by: FileCategoriesScalarFieldEnum[] | FileCategoriesScalarFieldEnum
    having?: FileCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCategoriesCountAggregateInputType | true
    _min?: FileCategoriesMinAggregateInputType
    _max?: FileCategoriesMaxAggregateInputType
  }

  export type FileCategoriesGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: FileCategoriesCountAggregateOutputType | null
    _min: FileCategoriesMinAggregateOutputType | null
    _max: FileCategoriesMaxAggregateOutputType | null
  }

  type GetFileCategoriesGroupByPayload<T extends FileCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], FileCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type FileCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    files?: boolean | FileCategories$filesArgs<ExtArgs>
    _count?: boolean | FileCategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileCategories"]>

  export type FileCategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fileCategories"]>

  export type FileCategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fileCategories"]>

  export type FileCategoriesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileCategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["fileCategories"]>
  export type FileCategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | FileCategories$filesArgs<ExtArgs>
    _count?: boolean | FileCategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileCategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FileCategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FileCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileCategories"
    objects: {
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fileCategories"]>
    composites: {}
  }

  type FileCategoriesGetPayload<S extends boolean | null | undefined | FileCategoriesDefaultArgs> = $Result.GetResult<Prisma.$FileCategoriesPayload, S>

  type FileCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileCategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCategoriesCountAggregateInputType | true
    }

  export interface FileCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileCategories'], meta: { name: 'FileCategories' } }
    /**
     * Find zero or one FileCategories that matches the filter.
     * @param {FileCategoriesFindUniqueArgs} args - Arguments to find a FileCategories
     * @example
     * // Get one FileCategories
     * const fileCategories = await prisma.fileCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileCategoriesFindUniqueArgs>(args: SelectSubset<T, FileCategoriesFindUniqueArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileCategories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileCategoriesFindUniqueOrThrowArgs} args - Arguments to find a FileCategories
     * @example
     * // Get one FileCategories
     * const fileCategories = await prisma.fileCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, FileCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesFindFirstArgs} args - Arguments to find a FileCategories
     * @example
     * // Get one FileCategories
     * const fileCategories = await prisma.fileCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileCategoriesFindFirstArgs>(args?: SelectSubset<T, FileCategoriesFindFirstArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesFindFirstOrThrowArgs} args - Arguments to find a FileCategories
     * @example
     * // Get one FileCategories
     * const fileCategories = await prisma.fileCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, FileCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileCategories
     * const fileCategories = await prisma.fileCategories.findMany()
     * 
     * // Get first 10 FileCategories
     * const fileCategories = await prisma.fileCategories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileCategoriesWithIdOnly = await prisma.fileCategories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileCategoriesFindManyArgs>(args?: SelectSubset<T, FileCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileCategories.
     * @param {FileCategoriesCreateArgs} args - Arguments to create a FileCategories.
     * @example
     * // Create one FileCategories
     * const FileCategories = await prisma.fileCategories.create({
     *   data: {
     *     // ... data to create a FileCategories
     *   }
     * })
     * 
     */
    create<T extends FileCategoriesCreateArgs>(args: SelectSubset<T, FileCategoriesCreateArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileCategories.
     * @param {FileCategoriesCreateManyArgs} args - Arguments to create many FileCategories.
     * @example
     * // Create many FileCategories
     * const fileCategories = await prisma.fileCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCategoriesCreateManyArgs>(args?: SelectSubset<T, FileCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileCategories and returns the data saved in the database.
     * @param {FileCategoriesCreateManyAndReturnArgs} args - Arguments to create many FileCategories.
     * @example
     * // Create many FileCategories
     * const fileCategories = await prisma.fileCategories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileCategories and only return the `id`
     * const fileCategoriesWithIdOnly = await prisma.fileCategories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileCategories.
     * @param {FileCategoriesDeleteArgs} args - Arguments to delete one FileCategories.
     * @example
     * // Delete one FileCategories
     * const FileCategories = await prisma.fileCategories.delete({
     *   where: {
     *     // ... filter to delete one FileCategories
     *   }
     * })
     * 
     */
    delete<T extends FileCategoriesDeleteArgs>(args: SelectSubset<T, FileCategoriesDeleteArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileCategories.
     * @param {FileCategoriesUpdateArgs} args - Arguments to update one FileCategories.
     * @example
     * // Update one FileCategories
     * const fileCategories = await prisma.fileCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileCategoriesUpdateArgs>(args: SelectSubset<T, FileCategoriesUpdateArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileCategories.
     * @param {FileCategoriesDeleteManyArgs} args - Arguments to filter FileCategories to delete.
     * @example
     * // Delete a few FileCategories
     * const { count } = await prisma.fileCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileCategoriesDeleteManyArgs>(args?: SelectSubset<T, FileCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileCategories
     * const fileCategories = await prisma.fileCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileCategoriesUpdateManyArgs>(args: SelectSubset<T, FileCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileCategories and returns the data updated in the database.
     * @param {FileCategoriesUpdateManyAndReturnArgs} args - Arguments to update many FileCategories.
     * @example
     * // Update many FileCategories
     * const fileCategories = await prisma.fileCategories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileCategories and only return the `id`
     * const fileCategoriesWithIdOnly = await prisma.fileCategories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileCategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, FileCategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileCategories.
     * @param {FileCategoriesUpsertArgs} args - Arguments to update or create a FileCategories.
     * @example
     * // Update or create a FileCategories
     * const fileCategories = await prisma.fileCategories.upsert({
     *   create: {
     *     // ... data to create a FileCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileCategories we want to update
     *   }
     * })
     */
    upsert<T extends FileCategoriesUpsertArgs>(args: SelectSubset<T, FileCategoriesUpsertArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesCountArgs} args - Arguments to filter FileCategories to count.
     * @example
     * // Count the number of FileCategories
     * const count = await prisma.fileCategories.count({
     *   where: {
     *     // ... the filter for the FileCategories we want to count
     *   }
     * })
    **/
    count<T extends FileCategoriesCountArgs>(
      args?: Subset<T, FileCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileCategoriesAggregateArgs>(args: Subset<T, FileCategoriesAggregateArgs>): Prisma.PrismaPromise<GetFileCategoriesAggregateType<T>>

    /**
     * Group by FileCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: FileCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileCategories model
   */
  readonly fields: FileCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends FileCategories$filesArgs<ExtArgs> = {}>(args?: Subset<T, FileCategories$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileCategories model
   */
  interface FileCategoriesFieldRefs {
    readonly id: FieldRef<"FileCategories", 'String'>
    readonly name: FieldRef<"FileCategories", 'String'>
    readonly description: FieldRef<"FileCategories", 'String'>
    readonly createdAt: FieldRef<"FileCategories", 'DateTime'>
    readonly updatedAt: FieldRef<"FileCategories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileCategories findUnique
   */
  export type FileCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which FileCategories to fetch.
     */
    where: FileCategoriesWhereUniqueInput
  }

  /**
   * FileCategories findUniqueOrThrow
   */
  export type FileCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which FileCategories to fetch.
     */
    where: FileCategoriesWhereUniqueInput
  }

  /**
   * FileCategories findFirst
   */
  export type FileCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which FileCategories to fetch.
     */
    where?: FileCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileCategories to fetch.
     */
    orderBy?: FileCategoriesOrderByWithRelationInput | FileCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileCategories.
     */
    cursor?: FileCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileCategories.
     */
    distinct?: FileCategoriesScalarFieldEnum | FileCategoriesScalarFieldEnum[]
  }

  /**
   * FileCategories findFirstOrThrow
   */
  export type FileCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which FileCategories to fetch.
     */
    where?: FileCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileCategories to fetch.
     */
    orderBy?: FileCategoriesOrderByWithRelationInput | FileCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileCategories.
     */
    cursor?: FileCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileCategories.
     */
    distinct?: FileCategoriesScalarFieldEnum | FileCategoriesScalarFieldEnum[]
  }

  /**
   * FileCategories findMany
   */
  export type FileCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which FileCategories to fetch.
     */
    where?: FileCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileCategories to fetch.
     */
    orderBy?: FileCategoriesOrderByWithRelationInput | FileCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileCategories.
     */
    cursor?: FileCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileCategories.
     */
    skip?: number
    distinct?: FileCategoriesScalarFieldEnum | FileCategoriesScalarFieldEnum[]
  }

  /**
   * FileCategories create
   */
  export type FileCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a FileCategories.
     */
    data: XOR<FileCategoriesCreateInput, FileCategoriesUncheckedCreateInput>
  }

  /**
   * FileCategories createMany
   */
  export type FileCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileCategories.
     */
    data: FileCategoriesCreateManyInput | FileCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileCategories createManyAndReturn
   */
  export type FileCategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many FileCategories.
     */
    data: FileCategoriesCreateManyInput | FileCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileCategories update
   */
  export type FileCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a FileCategories.
     */
    data: XOR<FileCategoriesUpdateInput, FileCategoriesUncheckedUpdateInput>
    /**
     * Choose, which FileCategories to update.
     */
    where: FileCategoriesWhereUniqueInput
  }

  /**
   * FileCategories updateMany
   */
  export type FileCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileCategories.
     */
    data: XOR<FileCategoriesUpdateManyMutationInput, FileCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which FileCategories to update
     */
    where?: FileCategoriesWhereInput
    /**
     * Limit how many FileCategories to update.
     */
    limit?: number
  }

  /**
   * FileCategories updateManyAndReturn
   */
  export type FileCategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * The data used to update FileCategories.
     */
    data: XOR<FileCategoriesUpdateManyMutationInput, FileCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which FileCategories to update
     */
    where?: FileCategoriesWhereInput
    /**
     * Limit how many FileCategories to update.
     */
    limit?: number
  }

  /**
   * FileCategories upsert
   */
  export type FileCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the FileCategories to update in case it exists.
     */
    where: FileCategoriesWhereUniqueInput
    /**
     * In case the FileCategories found by the `where` argument doesn't exist, create a new FileCategories with this data.
     */
    create: XOR<FileCategoriesCreateInput, FileCategoriesUncheckedCreateInput>
    /**
     * In case the FileCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileCategoriesUpdateInput, FileCategoriesUncheckedUpdateInput>
  }

  /**
   * FileCategories delete
   */
  export type FileCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    /**
     * Filter which FileCategories to delete.
     */
    where: FileCategoriesWhereUniqueInput
  }

  /**
   * FileCategories deleteMany
   */
  export type FileCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileCategories to delete
     */
    where?: FileCategoriesWhereInput
    /**
     * Limit how many FileCategories to delete.
     */
    limit?: number
  }

  /**
   * FileCategories.files
   */
  export type FileCategories$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * FileCategories without action
   */
  export type FileCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    tag: string | null
    size: number | null
    fileUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    tag: string | null
    size: number | null
    fileUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    tag: number
    size: number
    fileUrl: number
    createdAt: number
    updatedAt: number
    categoryId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    tag?: true
    size?: true
    fileUrl?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    tag?: true
    size?: true
    fileUrl?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    tag?: true
    size?: true
    fileUrl?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    tag: string | null
    size: number
    fileUrl: string
    createdAt: Date
    updatedAt: Date
    categoryId: string | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    tag?: boolean
    size?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    categories?: boolean | File$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    tag?: boolean
    size?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    categories?: boolean | File$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    tag?: boolean
    size?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    categories?: boolean | File$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    tag?: boolean
    size?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "tag" | "size" | "fileUrl" | "createdAt" | "updatedAt" | "categoryId", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | File$categoriesArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | File$categoriesArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | File$categoriesArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      categories: Prisma.$FileCategoriesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      tag: string | null
      size: number
      fileUrl: string
      createdAt: Date
      updatedAt: Date
      categoryId: string | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends File$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, File$categoriesArgs<ExtArgs>>): Prisma__FileCategoriesClient<$Result.GetResult<Prisma.$FileCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly description: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'String'>
    readonly tag: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly fileUrl: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly categoryId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.categories
   */
  export type File$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCategories
     */
    select?: FileCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileCategories
     */
    omit?: FileCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileCategoriesInclude<ExtArgs> | null
    where?: FileCategoriesWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model Badges
   */

  export type AggregateBadges = {
    _count: BadgesCountAggregateOutputType | null
    _avg: BadgesAvgAggregateOutputType | null
    _sum: BadgesSumAggregateOutputType | null
    _min: BadgesMinAggregateOutputType | null
    _max: BadgesMaxAggregateOutputType | null
  }

  export type BadgesAvgAggregateOutputType = {
    points: number | null
  }

  export type BadgesSumAggregateOutputType = {
    points: number | null
  }

  export type BadgesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    criteria: string | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    criteria: string | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    criteria: number
    points: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgesAvgAggregateInputType = {
    points?: true
  }

  export type BadgesSumAggregateInputType = {
    points?: true
  }

  export type BadgesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    criteria?: true
    points?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    criteria?: true
    points?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    criteria?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to aggregate.
     */
    where?: BadgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgesOrderByWithRelationInput | BadgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgesMaxAggregateInputType
  }

  export type GetBadgesAggregateType<T extends BadgesAggregateArgs> = {
        [P in keyof T & keyof AggregateBadges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadges[P]>
      : GetScalarType<T[P], AggregateBadges[P]>
  }




  export type BadgesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgesWhereInput
    orderBy?: BadgesOrderByWithAggregationInput | BadgesOrderByWithAggregationInput[]
    by: BadgesScalarFieldEnum[] | BadgesScalarFieldEnum
    having?: BadgesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgesCountAggregateInputType | true
    _avg?: BadgesAvgAggregateInputType
    _sum?: BadgesSumAggregateInputType
    _min?: BadgesMinAggregateInputType
    _max?: BadgesMaxAggregateInputType
  }

  export type BadgesGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    criteria: string | null
    points: number | null
    createdAt: Date
    updatedAt: Date
    _count: BadgesCountAggregateOutputType | null
    _avg: BadgesAvgAggregateOutputType | null
    _sum: BadgesSumAggregateOutputType | null
    _min: BadgesMinAggregateOutputType | null
    _max: BadgesMaxAggregateOutputType | null
  }

  type GetBadgesGroupByPayload<T extends BadgesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgesGroupByOutputType[P]>
            : GetScalarType<T[P], BadgesGroupByOutputType[P]>
        }
      >
    >


  export type BadgesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    criteria?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Badges$userArgs<ExtArgs>
    _count?: boolean | BadgesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badges"]>

  export type BadgesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    criteria?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badges"]>

  export type BadgesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    criteria?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badges"]>

  export type BadgesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    criteria?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "criteria" | "points" | "createdAt" | "updatedAt", ExtArgs["result"]["badges"]>
  export type BadgesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Badges$userArgs<ExtArgs>
    _count?: boolean | BadgesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badges"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      criteria: string | null
      points: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["badges"]>
    composites: {}
  }

  type BadgesGetPayload<S extends boolean | null | undefined | BadgesDefaultArgs> = $Result.GetResult<Prisma.$BadgesPayload, S>

  type BadgesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgesCountAggregateInputType | true
    }

  export interface BadgesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badges'], meta: { name: 'Badges' } }
    /**
     * Find zero or one Badges that matches the filter.
     * @param {BadgesFindUniqueArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgesFindUniqueArgs>(args: SelectSubset<T, BadgesFindUniqueArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgesFindUniqueOrThrowArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgesFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesFindFirstArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgesFindFirstArgs>(args?: SelectSubset<T, BadgesFindFirstArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesFindFirstOrThrowArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgesFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badges.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgesWithIdOnly = await prisma.badges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgesFindManyArgs>(args?: SelectSubset<T, BadgesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badges.
     * @param {BadgesCreateArgs} args - Arguments to create a Badges.
     * @example
     * // Create one Badges
     * const Badges = await prisma.badges.create({
     *   data: {
     *     // ... data to create a Badges
     *   }
     * })
     * 
     */
    create<T extends BadgesCreateArgs>(args: SelectSubset<T, BadgesCreateArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgesCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badges = await prisma.badges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgesCreateManyArgs>(args?: SelectSubset<T, BadgesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgesCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badges = await prisma.badges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgesWithIdOnly = await prisma.badges.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgesCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badges.
     * @param {BadgesDeleteArgs} args - Arguments to delete one Badges.
     * @example
     * // Delete one Badges
     * const Badges = await prisma.badges.delete({
     *   where: {
     *     // ... filter to delete one Badges
     *   }
     * })
     * 
     */
    delete<T extends BadgesDeleteArgs>(args: SelectSubset<T, BadgesDeleteArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badges.
     * @param {BadgesUpdateArgs} args - Arguments to update one Badges.
     * @example
     * // Update one Badges
     * const badges = await prisma.badges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgesUpdateArgs>(args: SelectSubset<T, BadgesUpdateArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgesDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgesDeleteManyArgs>(args?: SelectSubset<T, BadgesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badges = await prisma.badges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgesUpdateManyArgs>(args: SelectSubset<T, BadgesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgesUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badges = await prisma.badges.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgesWithIdOnly = await prisma.badges.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgesUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badges.
     * @param {BadgesUpsertArgs} args - Arguments to update or create a Badges.
     * @example
     * // Update or create a Badges
     * const badges = await prisma.badges.upsert({
     *   create: {
     *     // ... data to create a Badges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badges we want to update
     *   }
     * })
     */
    upsert<T extends BadgesUpsertArgs>(args: SelectSubset<T, BadgesUpsertArgs<ExtArgs>>): Prisma__BadgesClient<$Result.GetResult<Prisma.$BadgesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badges.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgesCountArgs>(
      args?: Subset<T, BadgesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgesAggregateArgs>(args: Subset<T, BadgesAggregateArgs>): Prisma.PrismaPromise<GetBadgesAggregateType<T>>

    /**
     * Group by Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgesGroupByArgs['orderBy'] }
        : { orderBy?: BadgesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badges model
   */
  readonly fields: BadgesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Badges$userArgs<ExtArgs> = {}>(args?: Subset<T, Badges$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badges model
   */
  interface BadgesFieldRefs {
    readonly id: FieldRef<"Badges", 'String'>
    readonly name: FieldRef<"Badges", 'String'>
    readonly description: FieldRef<"Badges", 'String'>
    readonly imageUrl: FieldRef<"Badges", 'String'>
    readonly criteria: FieldRef<"Badges", 'String'>
    readonly points: FieldRef<"Badges", 'Int'>
    readonly createdAt: FieldRef<"Badges", 'DateTime'>
    readonly updatedAt: FieldRef<"Badges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badges findUnique
   */
  export type BadgesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where: BadgesWhereUniqueInput
  }

  /**
   * Badges findUniqueOrThrow
   */
  export type BadgesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where: BadgesWhereUniqueInput
  }

  /**
   * Badges findFirst
   */
  export type BadgesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgesOrderByWithRelationInput | BadgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * Badges findFirstOrThrow
   */
  export type BadgesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgesOrderByWithRelationInput | BadgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * Badges findMany
   */
  export type BadgesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgesOrderByWithRelationInput | BadgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * Badges create
   */
  export type BadgesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * The data needed to create a Badges.
     */
    data: XOR<BadgesCreateInput, BadgesUncheckedCreateInput>
  }

  /**
   * Badges createMany
   */
  export type BadgesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgesCreateManyInput | BadgesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badges createManyAndReturn
   */
  export type BadgesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgesCreateManyInput | BadgesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badges update
   */
  export type BadgesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * The data needed to update a Badges.
     */
    data: XOR<BadgesUpdateInput, BadgesUncheckedUpdateInput>
    /**
     * Choose, which Badges to update.
     */
    where: BadgesWhereUniqueInput
  }

  /**
   * Badges updateMany
   */
  export type BadgesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgesUpdateManyMutationInput, BadgesUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgesWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badges updateManyAndReturn
   */
  export type BadgesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgesUpdateManyMutationInput, BadgesUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgesWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badges upsert
   */
  export type BadgesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * The filter to search for the Badges to update in case it exists.
     */
    where: BadgesWhereUniqueInput
    /**
     * In case the Badges found by the `where` argument doesn't exist, create a new Badges with this data.
     */
    create: XOR<BadgesCreateInput, BadgesUncheckedCreateInput>
    /**
     * In case the Badges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgesUpdateInput, BadgesUncheckedUpdateInput>
  }

  /**
   * Badges delete
   */
  export type BadgesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
    /**
     * Filter which Badges to delete.
     */
    where: BadgesWhereUniqueInput
  }

  /**
   * Badges deleteMany
   */
  export type BadgesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgesWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badges.user
   */
  export type Badges$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Badges without action
   */
  export type BadgesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges
     */
    select?: BadgesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badges
     */
    omit?: BadgesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgesInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    key: string | null
    label: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    key: string | null
    label: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    key: number
    label: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    key?: true
    label?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    key?: true
    label?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    key?: true
    label?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    key: string
    label: string
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    label?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    label?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    label?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    key?: boolean
    label?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "label", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      label: string
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly key: FieldRef<"Permission", 'String'>
    readonly label: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    role: $Enums.RoleType | null
    permissionId: number | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    role: $Enums.RoleType | null
    permissionId: number | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    role: number
    permissionId: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    role?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    role?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    role?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    role: $Enums.RoleType
    permissionId: number
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissionId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    role?: boolean
    permissionId?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "permissionId", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role: $Enums.RoleType
      permissionId: number
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly role: FieldRef<"RolePermission", 'RoleType'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    email: 'email',
    password: 'password',
    phone_number: 'phone_number',
    telegramUserName: 'telegramUserName',
    bio: 'bio',
    berthDate: 'berthDate',
    profileImageUrl: 'profileImageUrl',
    clubStatus: 'clubStatus',
    specialty: 'specialty',
    cvUrl: 'cvUrl',
    lastSeen: 'lastSeen',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    DivisionId: 'DivisionId',
    UserSettingId: 'UserSettingId',
    DivisionHeadID: 'DivisionHeadID',
    AttendanceSummaryId: 'AttendanceSummaryId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UniversityInfoScalarFieldEnum: {
    id: 'id',
    currentYear: 'currentYear',
    expectedGraduationYear: 'expectedGraduationYear',
    major: 'major',
    universityId: 'universityId',
    status: 'status',
    department: 'department',
    userId: 'userId'
  };

  export type UniversityInfoScalarFieldEnum = (typeof UniversityInfoScalarFieldEnum)[keyof typeof UniversityInfoScalarFieldEnum]


  export const UserSettingScalarFieldEnum: {
    id: 'id',
    theme: 'theme',
    phonePublic: 'phonePublic',
    authUpdateCalendar: 'authUpdateCalendar',
    userId: 'userId'
  };

  export type UserSettingScalarFieldEnum = (typeof UserSettingScalarFieldEnum)[keyof typeof UserSettingScalarFieldEnum]


  export const DivisionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    establishedAt: 'establishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currentHeadID: 'currentHeadID'
  };

  export type DivisionsScalarFieldEnum = (typeof DivisionsScalarFieldEnum)[keyof typeof DivisionsScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    divisionId: 'divisionId'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const SocialLinkScalarFieldEnum: {
    id: 'id',
    socialLinkName: 'socialLinkName',
    socialLinkUrl: 'socialLinkUrl',
    userId: 'userId',
    DivisionId: 'DivisionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialLinkScalarFieldEnum = (typeof SocialLinkScalarFieldEnum)[keyof typeof SocialLinkScalarFieldEnum]


  export const EventTimeSlotScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type EventTimeSlotScalarFieldEnum = (typeof EventTimeSlotScalarFieldEnum)[keyof typeof EventTimeSlotScalarFieldEnum]


  export const SessionTimeSlotScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type SessionTimeSlotScalarFieldEnum = (typeof SessionTimeSlotScalarFieldEnum)[keyof typeof SessionTimeSlotScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    tags: 'tags',
    visibility: 'visibility',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startMonth: 'startMonth',
    endTMonth: 'endTMonth',
    location: 'location',
    tags: 'tags',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const TasksScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    dueDate: 'dueDate',
    status: 'status',
    completedNotes: 'completedNotes',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    eventId: 'eventId',
    sessionId: 'sessionId'
  };

  export type TasksScalarFieldEnum = (typeof TasksScalarFieldEnum)[keyof typeof TasksScalarFieldEnum]


  export const EventParticipationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    role: 'role',
    score: 'score',
    feedback: 'feedback',
    feedbackScore: 'feedbackScore',
    createdAt: 'createdAt'
  };

  export type EventParticipationScalarFieldEnum = (typeof EventParticipationScalarFieldEnum)[keyof typeof EventParticipationScalarFieldEnum]


  export const SessionParticipationScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    role: 'role',
    score: 'score',
    feedback: 'feedback',
    feedbackScore: 'feedbackScore',
    createdAt: 'createdAt'
  };

  export type SessionParticipationScalarFieldEnum = (typeof SessionParticipationScalarFieldEnum)[keyof typeof SessionParticipationScalarFieldEnum]


  export const TaskParticipationScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    role: 'role',
    score: 'score',
    feedback: 'feedback',
    feedbackScore: 'feedbackScore',
    createdAt: 'createdAt'
  };

  export type TaskParticipationScalarFieldEnum = (typeof TaskParticipationScalarFieldEnum)[keyof typeof TaskParticipationScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    eventId: 'eventId',
    status: 'status',
    timestamp: 'timestamp',
    headsUpId: 'headsUpId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const AttendanceSummaryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalEvents: 'totalEvents',
    totalSessions: 'totalSessions',
    totalTasks: 'totalTasks',
    totalAttendance: 'totalAttendance',
    totalHeadsUps: 'totalHeadsUps',
    totalPresent: 'totalPresent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceSummaryScalarFieldEnum = (typeof AttendanceSummaryScalarFieldEnum)[keyof typeof AttendanceSummaryScalarFieldEnum]


  export const HeadsUpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    body: 'body',
    sentAt: 'sentAt'
  };

  export type HeadsUpScalarFieldEnum = (typeof HeadsUpScalarFieldEnum)[keyof typeof HeadsUpScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    visibility: 'visibility',
    Tags: 'Tags',
    announcementType: 'announcementType',
    sourceId: 'sourceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const FileCategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileCategoriesScalarFieldEnum = (typeof FileCategoriesScalarFieldEnum)[keyof typeof FileCategoriesScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    tag: 'tag',
    size: 'size',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    categoryId: 'categoryId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const BadgesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    criteria: 'criteria',
    points: 'points',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgesScalarFieldEnum = (typeof BadgesScalarFieldEnum)[keyof typeof BadgesScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    key: 'key',
    label: 'label'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    role: 'role',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ClubStatus'
   */
  export type EnumClubStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClubStatus'>
    


  /**
   * Reference to a field of type 'ClubStatus[]'
   */
  export type ListEnumClubStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClubStatus[]'>
    


  /**
   * Reference to a field of type 'RoleType'
   */
  export type EnumRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleType'>
    


  /**
   * Reference to a field of type 'RoleType[]'
   */
  export type ListEnumRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UniversityStatus'
   */
  export type EnumUniversityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UniversityStatus'>
    


  /**
   * Reference to a field of type 'UniversityStatus[]'
   */
  export type ListEnumUniversityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UniversityStatus[]'>
    


  /**
   * Reference to a field of type 'Theme'
   */
  export type EnumThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Theme'>
    


  /**
   * Reference to a field of type 'Theme[]'
   */
  export type ListEnumThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Theme[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Tag[]'
   */
  export type ListEnumTagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tag[]'>
    


  /**
   * Reference to a field of type 'Tag'
   */
  export type EnumTagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tag'>
    


  /**
   * Reference to a field of type 'EventVisibility'
   */
  export type EnumEventVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventVisibility'>
    


  /**
   * Reference to a field of type 'EventVisibility[]'
   */
  export type ListEnumEventVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventVisibility[]'>
    


  /**
   * Reference to a field of type 'state'
   */
  export type EnumstateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'state'>
    


  /**
   * Reference to a field of type 'state[]'
   */
  export type ListEnumstateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'state[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'EventRole'
   */
  export type EnumEventRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRole'>
    


  /**
   * Reference to a field of type 'EventRole[]'
   */
  export type ListEnumEventRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRole[]'>
    


  /**
   * Reference to a field of type 'SessionRole'
   */
  export type EnumSessionRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionRole'>
    


  /**
   * Reference to a field of type 'SessionRole[]'
   */
  export type ListEnumSessionRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionRole[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'HeadsUpType'
   */
  export type EnumHeadsUpTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HeadsUpType'>
    


  /**
   * Reference to a field of type 'HeadsUpType[]'
   */
  export type ListEnumHeadsUpTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HeadsUpType[]'>
    


  /**
   * Reference to a field of type 'AnnouncementVisibility'
   */
  export type EnumAnnouncementVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementVisibility'>
    


  /**
   * Reference to a field of type 'AnnouncementVisibility[]'
   */
  export type ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementVisibility[]'>
    


  /**
   * Reference to a field of type 'AnnouncementType'
   */
  export type EnumAnnouncementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementType'>
    


  /**
   * Reference to a field of type 'AnnouncementType[]'
   */
  export type ListEnumAnnouncementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phone_number?: StringNullableFilter<"User"> | string | null
    telegramUserName?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    berthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    clubStatus?: EnumClubStatusNullableFilter<"User"> | $Enums.ClubStatus | null
    specialty?: StringNullableFilter<"User"> | string | null
    cvUrl?: StringNullableFilter<"User"> | string | null
    lastSeen?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleTypeFilter<"User"> | $Enums.RoleType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    DivisionId?: UuidNullableFilter<"User"> | string | null
    UserSettingId?: UuidNullableFilter<"User"> | string | null
    DivisionHeadID?: UuidNullableFilter<"User"> | string | null
    AttendanceSummaryId?: UuidNullableFilter<"User"> | string | null
    universityInfo?: XOR<UniversityInfoNullableScalarRelationFilter, UniversityInfoWhereInput> | null
    Divisions?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
    socialLinks?: SocialLinkListRelationFilter
    UserSetting?: XOR<UserSettingNullableScalarRelationFilter, UserSettingWhereInput> | null
    Badges?: BadgesListRelationFilter
    events?: EventsListRelationFilter
    sessions?: SessionsListRelationFilter
    groups?: GroupsListRelationFilter
    DivisionHead?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
    TasksCreated?: TasksListRelationFilter
    AssignedTasks?: TasksListRelationFilter
    EventParticipation?: EventParticipationListRelationFilter
    SessionParticipation?: SessionParticipationListRelationFilter
    TaskParticipation?: TaskParticipationListRelationFilter
    Attendance?: AttendanceListRelationFilter
    AttendanceSummary?: XOR<AttendanceSummaryNullableScalarRelationFilter, AttendanceSummaryWhereInput> | null
    HeadsUp?: HeadsUpListRelationFilter
    Notification?: NotificationListRelationFilter
    Announcements?: AnnouncementListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    telegramUserName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    berthDate?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    clubStatus?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    cvUrl?: SortOrderInput | SortOrder
    lastSeen?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DivisionId?: SortOrderInput | SortOrder
    UserSettingId?: SortOrderInput | SortOrder
    DivisionHeadID?: SortOrderInput | SortOrder
    AttendanceSummaryId?: SortOrderInput | SortOrder
    universityInfo?: UniversityInfoOrderByWithRelationInput
    Divisions?: DivisionsOrderByWithRelationInput
    socialLinks?: socialLinkOrderByRelationAggregateInput
    UserSetting?: UserSettingOrderByWithRelationInput
    Badges?: BadgesOrderByRelationAggregateInput
    events?: EventsOrderByRelationAggregateInput
    sessions?: SessionsOrderByRelationAggregateInput
    groups?: GroupsOrderByRelationAggregateInput
    DivisionHead?: DivisionsOrderByWithRelationInput
    TasksCreated?: TasksOrderByRelationAggregateInput
    AssignedTasks?: TasksOrderByRelationAggregateInput
    EventParticipation?: EventParticipationOrderByRelationAggregateInput
    SessionParticipation?: SessionParticipationOrderByRelationAggregateInput
    TaskParticipation?: TaskParticipationOrderByRelationAggregateInput
    Attendance?: AttendanceOrderByRelationAggregateInput
    AttendanceSummary?: AttendanceSummaryOrderByWithRelationInput
    HeadsUp?: HeadsUpOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    Announcements?: AnnouncementOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone_number?: string
    telegramUserName?: string
    DivisionId?: string
    UserSettingId?: string
    DivisionHeadID?: string
    AttendanceSummaryId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    password?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    berthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    clubStatus?: EnumClubStatusNullableFilter<"User"> | $Enums.ClubStatus | null
    specialty?: StringNullableFilter<"User"> | string | null
    cvUrl?: StringNullableFilter<"User"> | string | null
    lastSeen?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleTypeFilter<"User"> | $Enums.RoleType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    universityInfo?: XOR<UniversityInfoNullableScalarRelationFilter, UniversityInfoWhereInput> | null
    Divisions?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
    socialLinks?: SocialLinkListRelationFilter
    UserSetting?: XOR<UserSettingNullableScalarRelationFilter, UserSettingWhereInput> | null
    Badges?: BadgesListRelationFilter
    events?: EventsListRelationFilter
    sessions?: SessionsListRelationFilter
    groups?: GroupsListRelationFilter
    DivisionHead?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
    TasksCreated?: TasksListRelationFilter
    AssignedTasks?: TasksListRelationFilter
    EventParticipation?: EventParticipationListRelationFilter
    SessionParticipation?: SessionParticipationListRelationFilter
    TaskParticipation?: TaskParticipationListRelationFilter
    Attendance?: AttendanceListRelationFilter
    AttendanceSummary?: XOR<AttendanceSummaryNullableScalarRelationFilter, AttendanceSummaryWhereInput> | null
    HeadsUp?: HeadsUpListRelationFilter
    Notification?: NotificationListRelationFilter
    Announcements?: AnnouncementListRelationFilter
  }, "id" | "email" | "phone_number" | "telegramUserName" | "DivisionId" | "UserSettingId" | "DivisionHeadID" | "AttendanceSummaryId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    telegramUserName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    berthDate?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    clubStatus?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    cvUrl?: SortOrderInput | SortOrder
    lastSeen?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DivisionId?: SortOrderInput | SortOrder
    UserSettingId?: SortOrderInput | SortOrder
    DivisionHeadID?: SortOrderInput | SortOrder
    AttendanceSummaryId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"User"> | $Enums.Gender
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    telegramUserName?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    berthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    clubStatus?: EnumClubStatusNullableWithAggregatesFilter<"User"> | $Enums.ClubStatus | null
    specialty?: StringNullableWithAggregatesFilter<"User"> | string | null
    cvUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastSeen?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumRoleTypeWithAggregatesFilter<"User"> | $Enums.RoleType
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    DivisionId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    UserSettingId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    DivisionHeadID?: UuidNullableWithAggregatesFilter<"User"> | string | null
    AttendanceSummaryId?: UuidNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UniversityInfoWhereInput = {
    AND?: UniversityInfoWhereInput | UniversityInfoWhereInput[]
    OR?: UniversityInfoWhereInput[]
    NOT?: UniversityInfoWhereInput | UniversityInfoWhereInput[]
    id?: StringFilter<"UniversityInfo"> | string
    currentYear?: IntNullableFilter<"UniversityInfo"> | number | null
    expectedGraduationYear?: IntNullableFilter<"UniversityInfo"> | number | null
    major?: StringNullableFilter<"UniversityInfo"> | string | null
    universityId?: StringNullableFilter<"UniversityInfo"> | string | null
    status?: EnumUniversityStatusFilter<"UniversityInfo"> | $Enums.UniversityStatus
    department?: StringNullableFilter<"UniversityInfo"> | string | null
    userId?: UuidNullableFilter<"UniversityInfo"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UniversityInfoOrderByWithRelationInput = {
    id?: SortOrder
    currentYear?: SortOrderInput | SortOrder
    expectedGraduationYear?: SortOrderInput | SortOrder
    major?: SortOrderInput | SortOrder
    universityId?: SortOrderInput | SortOrder
    status?: SortOrder
    department?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UniversityInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    universityId?: string
    userId?: string
    AND?: UniversityInfoWhereInput | UniversityInfoWhereInput[]
    OR?: UniversityInfoWhereInput[]
    NOT?: UniversityInfoWhereInput | UniversityInfoWhereInput[]
    currentYear?: IntNullableFilter<"UniversityInfo"> | number | null
    expectedGraduationYear?: IntNullableFilter<"UniversityInfo"> | number | null
    major?: StringNullableFilter<"UniversityInfo"> | string | null
    status?: EnumUniversityStatusFilter<"UniversityInfo"> | $Enums.UniversityStatus
    department?: StringNullableFilter<"UniversityInfo"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "universityId" | "userId">

  export type UniversityInfoOrderByWithAggregationInput = {
    id?: SortOrder
    currentYear?: SortOrderInput | SortOrder
    expectedGraduationYear?: SortOrderInput | SortOrder
    major?: SortOrderInput | SortOrder
    universityId?: SortOrderInput | SortOrder
    status?: SortOrder
    department?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: UniversityInfoCountOrderByAggregateInput
    _avg?: UniversityInfoAvgOrderByAggregateInput
    _max?: UniversityInfoMaxOrderByAggregateInput
    _min?: UniversityInfoMinOrderByAggregateInput
    _sum?: UniversityInfoSumOrderByAggregateInput
  }

  export type UniversityInfoScalarWhereWithAggregatesInput = {
    AND?: UniversityInfoScalarWhereWithAggregatesInput | UniversityInfoScalarWhereWithAggregatesInput[]
    OR?: UniversityInfoScalarWhereWithAggregatesInput[]
    NOT?: UniversityInfoScalarWhereWithAggregatesInput | UniversityInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UniversityInfo"> | string
    currentYear?: IntNullableWithAggregatesFilter<"UniversityInfo"> | number | null
    expectedGraduationYear?: IntNullableWithAggregatesFilter<"UniversityInfo"> | number | null
    major?: StringNullableWithAggregatesFilter<"UniversityInfo"> | string | null
    universityId?: StringNullableWithAggregatesFilter<"UniversityInfo"> | string | null
    status?: EnumUniversityStatusWithAggregatesFilter<"UniversityInfo"> | $Enums.UniversityStatus
    department?: StringNullableWithAggregatesFilter<"UniversityInfo"> | string | null
    userId?: UuidNullableWithAggregatesFilter<"UniversityInfo"> | string | null
  }

  export type UserSettingWhereInput = {
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    id?: UuidFilter<"UserSetting"> | string
    theme?: EnumThemeFilter<"UserSetting"> | $Enums.Theme
    phonePublic?: BoolFilter<"UserSetting"> | boolean
    authUpdateCalendar?: BoolFilter<"UserSetting"> | boolean
    userId?: UuidFilter<"UserSetting"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingOrderByWithRelationInput = {
    id?: SortOrder
    theme?: SortOrder
    phonePublic?: SortOrder
    authUpdateCalendar?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    theme?: EnumThemeFilter<"UserSetting"> | $Enums.Theme
    phonePublic?: BoolFilter<"UserSetting"> | boolean
    authUpdateCalendar?: BoolFilter<"UserSetting"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingOrderByWithAggregationInput = {
    id?: SortOrder
    theme?: SortOrder
    phonePublic?: SortOrder
    authUpdateCalendar?: SortOrder
    userId?: SortOrder
    _count?: UserSettingCountOrderByAggregateInput
    _max?: UserSettingMaxOrderByAggregateInput
    _min?: UserSettingMinOrderByAggregateInput
  }

  export type UserSettingScalarWhereWithAggregatesInput = {
    AND?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    OR?: UserSettingScalarWhereWithAggregatesInput[]
    NOT?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserSetting"> | string
    theme?: EnumThemeWithAggregatesFilter<"UserSetting"> | $Enums.Theme
    phonePublic?: BoolWithAggregatesFilter<"UserSetting"> | boolean
    authUpdateCalendar?: BoolWithAggregatesFilter<"UserSetting"> | boolean
    userId?: UuidWithAggregatesFilter<"UserSetting"> | string
  }

  export type DivisionsWhereInput = {
    AND?: DivisionsWhereInput | DivisionsWhereInput[]
    OR?: DivisionsWhereInput[]
    NOT?: DivisionsWhereInput | DivisionsWhereInput[]
    id?: UuidFilter<"Divisions"> | string
    name?: StringFilter<"Divisions"> | string
    description?: StringNullableFilter<"Divisions"> | string | null
    imageUrl?: StringNullableFilter<"Divisions"> | string | null
    establishedAt?: DateTimeNullableFilter<"Divisions"> | Date | string | null
    createdAt?: DateTimeFilter<"Divisions"> | Date | string
    updatedAt?: DateTimeFilter<"Divisions"> | Date | string
    currentHeadID?: UuidNullableFilter<"Divisions"> | string | null
    currentHead?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    socialLinks?: SocialLinkListRelationFilter
    sessions?: SessionsListRelationFilter
    groups?: GroupsListRelationFilter
  }

  export type DivisionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    establishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentHeadID?: SortOrderInput | SortOrder
    currentHead?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    socialLinks?: socialLinkOrderByRelationAggregateInput
    sessions?: SessionsOrderByRelationAggregateInput
    groups?: GroupsOrderByRelationAggregateInput
  }

  export type DivisionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    currentHeadID?: string
    AND?: DivisionsWhereInput | DivisionsWhereInput[]
    OR?: DivisionsWhereInput[]
    NOT?: DivisionsWhereInput | DivisionsWhereInput[]
    name?: StringFilter<"Divisions"> | string
    description?: StringNullableFilter<"Divisions"> | string | null
    imageUrl?: StringNullableFilter<"Divisions"> | string | null
    establishedAt?: DateTimeNullableFilter<"Divisions"> | Date | string | null
    createdAt?: DateTimeFilter<"Divisions"> | Date | string
    updatedAt?: DateTimeFilter<"Divisions"> | Date | string
    currentHead?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    socialLinks?: SocialLinkListRelationFilter
    sessions?: SessionsListRelationFilter
    groups?: GroupsListRelationFilter
  }, "id" | "currentHeadID">

  export type DivisionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    establishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentHeadID?: SortOrderInput | SortOrder
    _count?: DivisionsCountOrderByAggregateInput
    _max?: DivisionsMaxOrderByAggregateInput
    _min?: DivisionsMinOrderByAggregateInput
  }

  export type DivisionsScalarWhereWithAggregatesInput = {
    AND?: DivisionsScalarWhereWithAggregatesInput | DivisionsScalarWhereWithAggregatesInput[]
    OR?: DivisionsScalarWhereWithAggregatesInput[]
    NOT?: DivisionsScalarWhereWithAggregatesInput | DivisionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Divisions"> | string
    name?: StringWithAggregatesFilter<"Divisions"> | string
    description?: StringNullableWithAggregatesFilter<"Divisions"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Divisions"> | string | null
    establishedAt?: DateTimeNullableWithAggregatesFilter<"Divisions"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Divisions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Divisions"> | Date | string
    currentHeadID?: UuidNullableWithAggregatesFilter<"Divisions"> | string | null
  }

  export type GroupsWhereInput = {
    AND?: GroupsWhereInput | GroupsWhereInput[]
    OR?: GroupsWhereInput[]
    NOT?: GroupsWhereInput | GroupsWhereInput[]
    id?: UuidFilter<"Groups"> | string
    name?: StringFilter<"Groups"> | string
    description?: StringNullableFilter<"Groups"> | string | null
    createdAt?: DateTimeFilter<"Groups"> | Date | string
    updatedAt?: DateTimeFilter<"Groups"> | Date | string
    divisionId?: UuidNullableFilter<"Groups"> | string | null
    users?: UserListRelationFilter
    division?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
    sessions?: SessionsListRelationFilter
    events?: EventsListRelationFilter
  }

  export type GroupsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    divisionId?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    division?: DivisionsOrderByWithRelationInput
    sessions?: SessionsOrderByRelationAggregateInput
    events?: EventsOrderByRelationAggregateInput
  }

  export type GroupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupsWhereInput | GroupsWhereInput[]
    OR?: GroupsWhereInput[]
    NOT?: GroupsWhereInput | GroupsWhereInput[]
    name?: StringFilter<"Groups"> | string
    description?: StringNullableFilter<"Groups"> | string | null
    createdAt?: DateTimeFilter<"Groups"> | Date | string
    updatedAt?: DateTimeFilter<"Groups"> | Date | string
    divisionId?: UuidNullableFilter<"Groups"> | string | null
    users?: UserListRelationFilter
    division?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
    sessions?: SessionsListRelationFilter
    events?: EventsListRelationFilter
  }, "id">

  export type GroupsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    divisionId?: SortOrderInput | SortOrder
    _count?: GroupsCountOrderByAggregateInput
    _max?: GroupsMaxOrderByAggregateInput
    _min?: GroupsMinOrderByAggregateInput
  }

  export type GroupsScalarWhereWithAggregatesInput = {
    AND?: GroupsScalarWhereWithAggregatesInput | GroupsScalarWhereWithAggregatesInput[]
    OR?: GroupsScalarWhereWithAggregatesInput[]
    NOT?: GroupsScalarWhereWithAggregatesInput | GroupsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Groups"> | string
    name?: StringWithAggregatesFilter<"Groups"> | string
    description?: StringNullableWithAggregatesFilter<"Groups"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Groups"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Groups"> | Date | string
    divisionId?: UuidNullableWithAggregatesFilter<"Groups"> | string | null
  }

  export type socialLinkWhereInput = {
    AND?: socialLinkWhereInput | socialLinkWhereInput[]
    OR?: socialLinkWhereInput[]
    NOT?: socialLinkWhereInput | socialLinkWhereInput[]
    id?: UuidFilter<"socialLink"> | string
    socialLinkName?: StringFilter<"socialLink"> | string
    socialLinkUrl?: StringFilter<"socialLink"> | string
    userId?: UuidNullableFilter<"socialLink"> | string | null
    DivisionId?: UuidNullableFilter<"socialLink"> | string | null
    createdAt?: DateTimeFilter<"socialLink"> | Date | string
    updatedAt?: DateTimeFilter<"socialLink"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Division?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
  }

  export type socialLinkOrderByWithRelationInput = {
    id?: SortOrder
    socialLinkName?: SortOrder
    socialLinkUrl?: SortOrder
    userId?: SortOrderInput | SortOrder
    DivisionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Division?: DivisionsOrderByWithRelationInput
  }

  export type socialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: socialLinkWhereInput | socialLinkWhereInput[]
    OR?: socialLinkWhereInput[]
    NOT?: socialLinkWhereInput | socialLinkWhereInput[]
    socialLinkName?: StringFilter<"socialLink"> | string
    socialLinkUrl?: StringFilter<"socialLink"> | string
    userId?: UuidNullableFilter<"socialLink"> | string | null
    DivisionId?: UuidNullableFilter<"socialLink"> | string | null
    createdAt?: DateTimeFilter<"socialLink"> | Date | string
    updatedAt?: DateTimeFilter<"socialLink"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Division?: XOR<DivisionsNullableScalarRelationFilter, DivisionsWhereInput> | null
  }, "id">

  export type socialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    socialLinkName?: SortOrder
    socialLinkUrl?: SortOrder
    userId?: SortOrderInput | SortOrder
    DivisionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: socialLinkCountOrderByAggregateInput
    _max?: socialLinkMaxOrderByAggregateInput
    _min?: socialLinkMinOrderByAggregateInput
  }

  export type socialLinkScalarWhereWithAggregatesInput = {
    AND?: socialLinkScalarWhereWithAggregatesInput | socialLinkScalarWhereWithAggregatesInput[]
    OR?: socialLinkScalarWhereWithAggregatesInput[]
    NOT?: socialLinkScalarWhereWithAggregatesInput | socialLinkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"socialLink"> | string
    socialLinkName?: StringWithAggregatesFilter<"socialLink"> | string
    socialLinkUrl?: StringWithAggregatesFilter<"socialLink"> | string
    userId?: UuidNullableWithAggregatesFilter<"socialLink"> | string | null
    DivisionId?: UuidNullableWithAggregatesFilter<"socialLink"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"socialLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"socialLink"> | Date | string
  }

  export type EventTimeSlotWhereInput = {
    AND?: EventTimeSlotWhereInput | EventTimeSlotWhereInput[]
    OR?: EventTimeSlotWhereInput[]
    NOT?: EventTimeSlotWhereInput | EventTimeSlotWhereInput[]
    id?: UuidFilter<"EventTimeSlot"> | string
    eventId?: UuidNullableFilter<"EventTimeSlot"> | string | null
    startTime?: DateTimeFilter<"EventTimeSlot"> | Date | string
    endTime?: DateTimeFilter<"EventTimeSlot"> | Date | string
    event?: XOR<EventsNullableScalarRelationFilter, EventsWhereInput> | null
  }

  export type EventTimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    event?: EventsOrderByWithRelationInput
  }

  export type EventTimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventTimeSlotWhereInput | EventTimeSlotWhereInput[]
    OR?: EventTimeSlotWhereInput[]
    NOT?: EventTimeSlotWhereInput | EventTimeSlotWhereInput[]
    eventId?: UuidNullableFilter<"EventTimeSlot"> | string | null
    startTime?: DateTimeFilter<"EventTimeSlot"> | Date | string
    endTime?: DateTimeFilter<"EventTimeSlot"> | Date | string
    event?: XOR<EventsNullableScalarRelationFilter, EventsWhereInput> | null
  }, "id">

  export type EventTimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    _count?: EventTimeSlotCountOrderByAggregateInput
    _max?: EventTimeSlotMaxOrderByAggregateInput
    _min?: EventTimeSlotMinOrderByAggregateInput
  }

  export type EventTimeSlotScalarWhereWithAggregatesInput = {
    AND?: EventTimeSlotScalarWhereWithAggregatesInput | EventTimeSlotScalarWhereWithAggregatesInput[]
    OR?: EventTimeSlotScalarWhereWithAggregatesInput[]
    NOT?: EventTimeSlotScalarWhereWithAggregatesInput | EventTimeSlotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventTimeSlot"> | string
    eventId?: UuidNullableWithAggregatesFilter<"EventTimeSlot"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"EventTimeSlot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"EventTimeSlot"> | Date | string
  }

  export type SessionTimeSlotWhereInput = {
    AND?: SessionTimeSlotWhereInput | SessionTimeSlotWhereInput[]
    OR?: SessionTimeSlotWhereInput[]
    NOT?: SessionTimeSlotWhereInput | SessionTimeSlotWhereInput[]
    id?: UuidFilter<"SessionTimeSlot"> | string
    sessionId?: UuidNullableFilter<"SessionTimeSlot"> | string | null
    startTime?: DateTimeFilter<"SessionTimeSlot"> | Date | string
    endTime?: DateTimeFilter<"SessionTimeSlot"> | Date | string
    session?: XOR<SessionsNullableScalarRelationFilter, SessionsWhereInput> | null
  }

  export type SessionTimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: SessionsOrderByWithRelationInput
  }

  export type SessionTimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionTimeSlotWhereInput | SessionTimeSlotWhereInput[]
    OR?: SessionTimeSlotWhereInput[]
    NOT?: SessionTimeSlotWhereInput | SessionTimeSlotWhereInput[]
    sessionId?: UuidNullableFilter<"SessionTimeSlot"> | string | null
    startTime?: DateTimeFilter<"SessionTimeSlot"> | Date | string
    endTime?: DateTimeFilter<"SessionTimeSlot"> | Date | string
    session?: XOR<SessionsNullableScalarRelationFilter, SessionsWhereInput> | null
  }, "id">

  export type SessionTimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    _count?: SessionTimeSlotCountOrderByAggregateInput
    _max?: SessionTimeSlotMaxOrderByAggregateInput
    _min?: SessionTimeSlotMinOrderByAggregateInput
  }

  export type SessionTimeSlotScalarWhereWithAggregatesInput = {
    AND?: SessionTimeSlotScalarWhereWithAggregatesInput | SessionTimeSlotScalarWhereWithAggregatesInput[]
    OR?: SessionTimeSlotScalarWhereWithAggregatesInput[]
    NOT?: SessionTimeSlotScalarWhereWithAggregatesInput | SessionTimeSlotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SessionTimeSlot"> | string
    sessionId?: UuidNullableWithAggregatesFilter<"SessionTimeSlot"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"SessionTimeSlot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"SessionTimeSlot"> | Date | string
  }

  export type EventsWhereInput = {
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    id?: UuidFilter<"Events"> | string
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    startDate?: DateTimeFilter<"Events"> | Date | string
    startTime?: DateTimeFilter<"Events"> | Date | string
    endTime?: DateTimeFilter<"Events"> | Date | string
    location?: StringNullableFilter<"Events"> | string | null
    tags?: EnumTagNullableListFilter<"Events">
    visibility?: EnumEventVisibilityFilter<"Events"> | $Enums.EventVisibility
    state?: EnumstateFilter<"Events"> | $Enums.state
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
    creatorId?: UuidFilter<"Events"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    timeSlots?: EventTimeSlotListRelationFilter
    groups?: GroupsListRelationFilter
    tasks?: TasksListRelationFilter
    participants?: EventParticipationListRelationFilter
    attendance?: AttendanceListRelationFilter
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    creator?: UserOrderByWithRelationInput
    timeSlots?: EventTimeSlotOrderByRelationAggregateInput
    groups?: GroupsOrderByRelationAggregateInput
    tasks?: TasksOrderByRelationAggregateInput
    participants?: EventParticipationOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
  }

  export type EventsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    startDate?: DateTimeFilter<"Events"> | Date | string
    startTime?: DateTimeFilter<"Events"> | Date | string
    endTime?: DateTimeFilter<"Events"> | Date | string
    location?: StringNullableFilter<"Events"> | string | null
    tags?: EnumTagNullableListFilter<"Events">
    visibility?: EnumEventVisibilityFilter<"Events"> | $Enums.EventVisibility
    state?: EnumstateFilter<"Events"> | $Enums.state
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
    creatorId?: UuidFilter<"Events"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    timeSlots?: EventTimeSlotListRelationFilter
    groups?: GroupsListRelationFilter
    tasks?: TasksListRelationFilter
    participants?: EventParticipationListRelationFilter
    attendance?: AttendanceListRelationFilter
  }, "id">

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    _count?: EventsCountOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    OR?: EventsScalarWhereWithAggregatesInput[]
    NOT?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Events"> | string
    title?: StringWithAggregatesFilter<"Events"> | string
    description?: StringNullableWithAggregatesFilter<"Events"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Events"> | string | null
    tags?: EnumTagNullableListFilter<"Events">
    visibility?: EnumEventVisibilityWithAggregatesFilter<"Events"> | $Enums.EventVisibility
    state?: EnumstateWithAggregatesFilter<"Events"> | $Enums.state
    createdAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    creatorId?: UuidWithAggregatesFilter<"Events"> | string
  }

  export type SessionsWhereInput = {
    AND?: SessionsWhereInput | SessionsWhereInput[]
    OR?: SessionsWhereInput[]
    NOT?: SessionsWhereInput | SessionsWhereInput[]
    id?: UuidFilter<"Sessions"> | string
    title?: StringFilter<"Sessions"> | string
    description?: StringNullableFilter<"Sessions"> | string | null
    startMonth?: DateTimeFilter<"Sessions"> | Date | string
    endTMonth?: DateTimeFilter<"Sessions"> | Date | string
    location?: StringNullableFilter<"Sessions"> | string | null
    tags?: EnumTagNullableListFilter<"Sessions">
    state?: EnumstateFilter<"Sessions"> | $Enums.state
    createdAt?: DateTimeFilter<"Sessions"> | Date | string
    updatedAt?: DateTimeFilter<"Sessions"> | Date | string
    creatorId?: UuidFilter<"Sessions"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    division?: DivisionsListRelationFilter
    timeSlot?: SessionTimeSlotListRelationFilter
    targetGroups?: GroupsListRelationFilter
    tasks?: TasksListRelationFilter
    participants?: SessionParticipationListRelationFilter
    attendance?: AttendanceListRelationFilter
  }

  export type SessionsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startMonth?: SortOrder
    endTMonth?: SortOrder
    location?: SortOrderInput | SortOrder
    tags?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    creator?: UserOrderByWithRelationInput
    division?: DivisionsOrderByRelationAggregateInput
    timeSlot?: SessionTimeSlotOrderByRelationAggregateInput
    targetGroups?: GroupsOrderByRelationAggregateInput
    tasks?: TasksOrderByRelationAggregateInput
    participants?: SessionParticipationOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
  }

  export type SessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionsWhereInput | SessionsWhereInput[]
    OR?: SessionsWhereInput[]
    NOT?: SessionsWhereInput | SessionsWhereInput[]
    title?: StringFilter<"Sessions"> | string
    description?: StringNullableFilter<"Sessions"> | string | null
    startMonth?: DateTimeFilter<"Sessions"> | Date | string
    endTMonth?: DateTimeFilter<"Sessions"> | Date | string
    location?: StringNullableFilter<"Sessions"> | string | null
    tags?: EnumTagNullableListFilter<"Sessions">
    state?: EnumstateFilter<"Sessions"> | $Enums.state
    createdAt?: DateTimeFilter<"Sessions"> | Date | string
    updatedAt?: DateTimeFilter<"Sessions"> | Date | string
    creatorId?: UuidFilter<"Sessions"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    division?: DivisionsListRelationFilter
    timeSlot?: SessionTimeSlotListRelationFilter
    targetGroups?: GroupsListRelationFilter
    tasks?: TasksListRelationFilter
    participants?: SessionParticipationListRelationFilter
    attendance?: AttendanceListRelationFilter
  }, "id">

  export type SessionsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startMonth?: SortOrder
    endTMonth?: SortOrder
    location?: SortOrderInput | SortOrder
    tags?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    _count?: SessionsCountOrderByAggregateInput
    _max?: SessionsMaxOrderByAggregateInput
    _min?: SessionsMinOrderByAggregateInput
  }

  export type SessionsScalarWhereWithAggregatesInput = {
    AND?: SessionsScalarWhereWithAggregatesInput | SessionsScalarWhereWithAggregatesInput[]
    OR?: SessionsScalarWhereWithAggregatesInput[]
    NOT?: SessionsScalarWhereWithAggregatesInput | SessionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Sessions"> | string
    title?: StringWithAggregatesFilter<"Sessions"> | string
    description?: StringNullableWithAggregatesFilter<"Sessions"> | string | null
    startMonth?: DateTimeWithAggregatesFilter<"Sessions"> | Date | string
    endTMonth?: DateTimeWithAggregatesFilter<"Sessions"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Sessions"> | string | null
    tags?: EnumTagNullableListFilter<"Sessions">
    state?: EnumstateWithAggregatesFilter<"Sessions"> | $Enums.state
    createdAt?: DateTimeWithAggregatesFilter<"Sessions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sessions"> | Date | string
    creatorId?: UuidWithAggregatesFilter<"Sessions"> | string
  }

  export type TasksWhereInput = {
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    id?: UuidFilter<"Tasks"> | string
    title?: StringFilter<"Tasks"> | string
    description?: StringNullableFilter<"Tasks"> | string | null
    dueDate?: DateTimeFilter<"Tasks"> | Date | string
    status?: EnumTaskStatusFilter<"Tasks"> | $Enums.TaskStatus
    completedNotes?: StringNullableFilter<"Tasks"> | string | null
    approvedAt?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    createdAt?: DateTimeFilter<"Tasks"> | Date | string
    updatedAt?: DateTimeFilter<"Tasks"> | Date | string
    creatorId?: UuidFilter<"Tasks"> | string
    eventId?: UuidNullableFilter<"Tasks"> | string | null
    sessionId?: UuidNullableFilter<"Tasks"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: UserListRelationFilter
    event?: XOR<EventsNullableScalarRelationFilter, EventsWhereInput> | null
    session?: XOR<SessionsNullableScalarRelationFilter, SessionsWhereInput> | null
    participants?: TaskParticipationListRelationFilter
  }

  export type TasksOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedNotes?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    eventId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByRelationAggregateInput
    event?: EventsOrderByWithRelationInput
    session?: SessionsOrderByWithRelationInput
    participants?: TaskParticipationOrderByRelationAggregateInput
  }

  export type TasksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    title?: StringFilter<"Tasks"> | string
    description?: StringNullableFilter<"Tasks"> | string | null
    dueDate?: DateTimeFilter<"Tasks"> | Date | string
    status?: EnumTaskStatusFilter<"Tasks"> | $Enums.TaskStatus
    completedNotes?: StringNullableFilter<"Tasks"> | string | null
    approvedAt?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    createdAt?: DateTimeFilter<"Tasks"> | Date | string
    updatedAt?: DateTimeFilter<"Tasks"> | Date | string
    creatorId?: UuidFilter<"Tasks"> | string
    eventId?: UuidNullableFilter<"Tasks"> | string | null
    sessionId?: UuidNullableFilter<"Tasks"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: UserListRelationFilter
    event?: XOR<EventsNullableScalarRelationFilter, EventsWhereInput> | null
    session?: XOR<SessionsNullableScalarRelationFilter, SessionsWhereInput> | null
    participants?: TaskParticipationListRelationFilter
  }, "id">

  export type TasksOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedNotes?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    eventId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: TasksCountOrderByAggregateInput
    _max?: TasksMaxOrderByAggregateInput
    _min?: TasksMinOrderByAggregateInput
  }

  export type TasksScalarWhereWithAggregatesInput = {
    AND?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    OR?: TasksScalarWhereWithAggregatesInput[]
    NOT?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tasks"> | string
    title?: StringWithAggregatesFilter<"Tasks"> | string
    description?: StringNullableWithAggregatesFilter<"Tasks"> | string | null
    dueDate?: DateTimeWithAggregatesFilter<"Tasks"> | Date | string
    status?: EnumTaskStatusWithAggregatesFilter<"Tasks"> | $Enums.TaskStatus
    completedNotes?: StringNullableWithAggregatesFilter<"Tasks"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Tasks"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tasks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tasks"> | Date | string
    creatorId?: UuidWithAggregatesFilter<"Tasks"> | string
    eventId?: UuidNullableWithAggregatesFilter<"Tasks"> | string | null
    sessionId?: UuidNullableWithAggregatesFilter<"Tasks"> | string | null
  }

  export type EventParticipationWhereInput = {
    AND?: EventParticipationWhereInput | EventParticipationWhereInput[]
    OR?: EventParticipationWhereInput[]
    NOT?: EventParticipationWhereInput | EventParticipationWhereInput[]
    id?: UuidFilter<"EventParticipation"> | string
    eventId?: UuidFilter<"EventParticipation"> | string
    userId?: UuidFilter<"EventParticipation"> | string
    role?: EnumEventRoleFilter<"EventParticipation"> | $Enums.EventRole
    score?: IntFilter<"EventParticipation"> | number
    feedback?: StringNullableFilter<"EventParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"EventParticipation"> | number | null
    createdAt?: DateTimeFilter<"EventParticipation"> | Date | string
    event?: XOR<EventsScalarRelationFilter, EventsWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EventParticipationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    event?: EventsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventParticipationWhereInput | EventParticipationWhereInput[]
    OR?: EventParticipationWhereInput[]
    NOT?: EventParticipationWhereInput | EventParticipationWhereInput[]
    eventId?: UuidFilter<"EventParticipation"> | string
    userId?: UuidFilter<"EventParticipation"> | string
    role?: EnumEventRoleFilter<"EventParticipation"> | $Enums.EventRole
    score?: IntFilter<"EventParticipation"> | number
    feedback?: StringNullableFilter<"EventParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"EventParticipation"> | number | null
    createdAt?: DateTimeFilter<"EventParticipation"> | Date | string
    event?: XOR<EventsScalarRelationFilter, EventsWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EventParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventParticipationCountOrderByAggregateInput
    _avg?: EventParticipationAvgOrderByAggregateInput
    _max?: EventParticipationMaxOrderByAggregateInput
    _min?: EventParticipationMinOrderByAggregateInput
    _sum?: EventParticipationSumOrderByAggregateInput
  }

  export type EventParticipationScalarWhereWithAggregatesInput = {
    AND?: EventParticipationScalarWhereWithAggregatesInput | EventParticipationScalarWhereWithAggregatesInput[]
    OR?: EventParticipationScalarWhereWithAggregatesInput[]
    NOT?: EventParticipationScalarWhereWithAggregatesInput | EventParticipationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EventParticipation"> | string
    eventId?: UuidWithAggregatesFilter<"EventParticipation"> | string
    userId?: UuidWithAggregatesFilter<"EventParticipation"> | string
    role?: EnumEventRoleWithAggregatesFilter<"EventParticipation"> | $Enums.EventRole
    score?: IntWithAggregatesFilter<"EventParticipation"> | number
    feedback?: StringNullableWithAggregatesFilter<"EventParticipation"> | string | null
    feedbackScore?: IntNullableWithAggregatesFilter<"EventParticipation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EventParticipation"> | Date | string
  }

  export type SessionParticipationWhereInput = {
    AND?: SessionParticipationWhereInput | SessionParticipationWhereInput[]
    OR?: SessionParticipationWhereInput[]
    NOT?: SessionParticipationWhereInput | SessionParticipationWhereInput[]
    id?: UuidFilter<"SessionParticipation"> | string
    sessionId?: UuidFilter<"SessionParticipation"> | string
    userId?: UuidFilter<"SessionParticipation"> | string
    role?: EnumSessionRoleFilter<"SessionParticipation"> | $Enums.SessionRole
    score?: IntFilter<"SessionParticipation"> | number
    feedback?: StringNullableFilter<"SessionParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"SessionParticipation"> | number | null
    createdAt?: DateTimeFilter<"SessionParticipation"> | Date | string
    session?: XOR<SessionsScalarRelationFilter, SessionsWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionParticipationOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SessionParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionParticipationWhereInput | SessionParticipationWhereInput[]
    OR?: SessionParticipationWhereInput[]
    NOT?: SessionParticipationWhereInput | SessionParticipationWhereInput[]
    sessionId?: UuidFilter<"SessionParticipation"> | string
    userId?: UuidFilter<"SessionParticipation"> | string
    role?: EnumSessionRoleFilter<"SessionParticipation"> | $Enums.SessionRole
    score?: IntFilter<"SessionParticipation"> | number
    feedback?: StringNullableFilter<"SessionParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"SessionParticipation"> | number | null
    createdAt?: DateTimeFilter<"SessionParticipation"> | Date | string
    session?: XOR<SessionsScalarRelationFilter, SessionsWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionParticipationCountOrderByAggregateInput
    _avg?: SessionParticipationAvgOrderByAggregateInput
    _max?: SessionParticipationMaxOrderByAggregateInput
    _min?: SessionParticipationMinOrderByAggregateInput
    _sum?: SessionParticipationSumOrderByAggregateInput
  }

  export type SessionParticipationScalarWhereWithAggregatesInput = {
    AND?: SessionParticipationScalarWhereWithAggregatesInput | SessionParticipationScalarWhereWithAggregatesInput[]
    OR?: SessionParticipationScalarWhereWithAggregatesInput[]
    NOT?: SessionParticipationScalarWhereWithAggregatesInput | SessionParticipationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SessionParticipation"> | string
    sessionId?: UuidWithAggregatesFilter<"SessionParticipation"> | string
    userId?: UuidWithAggregatesFilter<"SessionParticipation"> | string
    role?: EnumSessionRoleWithAggregatesFilter<"SessionParticipation"> | $Enums.SessionRole
    score?: IntWithAggregatesFilter<"SessionParticipation"> | number
    feedback?: StringNullableWithAggregatesFilter<"SessionParticipation"> | string | null
    feedbackScore?: IntNullableWithAggregatesFilter<"SessionParticipation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionParticipation"> | Date | string
  }

  export type TaskParticipationWhereInput = {
    AND?: TaskParticipationWhereInput | TaskParticipationWhereInput[]
    OR?: TaskParticipationWhereInput[]
    NOT?: TaskParticipationWhereInput | TaskParticipationWhereInput[]
    id?: UuidFilter<"TaskParticipation"> | string
    taskId?: StringFilter<"TaskParticipation"> | string
    userId?: StringFilter<"TaskParticipation"> | string
    role?: StringFilter<"TaskParticipation"> | string
    score?: IntFilter<"TaskParticipation"> | number
    feedback?: StringNullableFilter<"TaskParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"TaskParticipation"> | number | null
    createdAt?: DateTimeFilter<"TaskParticipation"> | Date | string
    task?: XOR<TasksScalarRelationFilter, TasksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskParticipationOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: TasksOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskParticipationWhereInput | TaskParticipationWhereInput[]
    OR?: TaskParticipationWhereInput[]
    NOT?: TaskParticipationWhereInput | TaskParticipationWhereInput[]
    taskId?: StringFilter<"TaskParticipation"> | string
    userId?: StringFilter<"TaskParticipation"> | string
    role?: StringFilter<"TaskParticipation"> | string
    score?: IntFilter<"TaskParticipation"> | number
    feedback?: StringNullableFilter<"TaskParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"TaskParticipation"> | number | null
    createdAt?: DateTimeFilter<"TaskParticipation"> | Date | string
    task?: XOR<TasksScalarRelationFilter, TasksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrderInput | SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskParticipationCountOrderByAggregateInput
    _avg?: TaskParticipationAvgOrderByAggregateInput
    _max?: TaskParticipationMaxOrderByAggregateInput
    _min?: TaskParticipationMinOrderByAggregateInput
    _sum?: TaskParticipationSumOrderByAggregateInput
  }

  export type TaskParticipationScalarWhereWithAggregatesInput = {
    AND?: TaskParticipationScalarWhereWithAggregatesInput | TaskParticipationScalarWhereWithAggregatesInput[]
    OR?: TaskParticipationScalarWhereWithAggregatesInput[]
    NOT?: TaskParticipationScalarWhereWithAggregatesInput | TaskParticipationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TaskParticipation"> | string
    taskId?: StringWithAggregatesFilter<"TaskParticipation"> | string
    userId?: StringWithAggregatesFilter<"TaskParticipation"> | string
    role?: StringWithAggregatesFilter<"TaskParticipation"> | string
    score?: IntWithAggregatesFilter<"TaskParticipation"> | number
    feedback?: StringNullableWithAggregatesFilter<"TaskParticipation"> | string | null
    feedbackScore?: IntNullableWithAggregatesFilter<"TaskParticipation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskParticipation"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: UuidFilter<"Attendance"> | string
    userId?: UuidFilter<"Attendance"> | string
    sessionId?: UuidNullableFilter<"Attendance"> | string | null
    eventId?: UuidNullableFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    timestamp?: DateTimeFilter<"Attendance"> | Date | string
    headsUpId?: UuidNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<SessionsNullableScalarRelationFilter, SessionsWhereInput> | null
    event?: XOR<EventsNullableScalarRelationFilter, EventsWhereInput> | null
    headsUp?: XOR<HeadsUpNullableScalarRelationFilter, HeadsUpWhereInput> | null
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    headsUpId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    session?: SessionsOrderByWithRelationInput
    event?: EventsOrderByWithRelationInput
    headsUp?: HeadsUpOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    headsUpId?: string
    userId_sessionId?: AttendanceUserIdSessionIdCompoundUniqueInput
    userId_eventId?: AttendanceUserIdEventIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    userId?: UuidFilter<"Attendance"> | string
    sessionId?: UuidNullableFilter<"Attendance"> | string | null
    eventId?: UuidNullableFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    timestamp?: DateTimeFilter<"Attendance"> | Date | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<SessionsNullableScalarRelationFilter, SessionsWhereInput> | null
    event?: XOR<EventsNullableScalarRelationFilter, EventsWhereInput> | null
    headsUp?: XOR<HeadsUpNullableScalarRelationFilter, HeadsUpWhereInput> | null
  }, "id" | "headsUpId" | "userId_sessionId" | "userId_eventId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    headsUpId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Attendance"> | string
    userId?: UuidWithAggregatesFilter<"Attendance"> | string
    sessionId?: UuidNullableWithAggregatesFilter<"Attendance"> | string | null
    eventId?: UuidNullableWithAggregatesFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    timestamp?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    headsUpId?: UuidNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type AttendanceSummaryWhereInput = {
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    id?: UuidFilter<"AttendanceSummary"> | string
    userId?: StringFilter<"AttendanceSummary"> | string
    totalEvents?: IntFilter<"AttendanceSummary"> | number
    totalSessions?: IntFilter<"AttendanceSummary"> | number
    totalTasks?: IntFilter<"AttendanceSummary"> | number
    totalAttendance?: IntFilter<"AttendanceSummary"> | number
    totalHeadsUps?: IntFilter<"AttendanceSummary"> | number
    totalPresent?: IntFilter<"AttendanceSummary"> | number
    createdAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceSummaryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    totalEvents?: IntFilter<"AttendanceSummary"> | number
    totalSessions?: IntFilter<"AttendanceSummary"> | number
    totalTasks?: IntFilter<"AttendanceSummary"> | number
    totalAttendance?: IntFilter<"AttendanceSummary"> | number
    totalHeadsUps?: IntFilter<"AttendanceSummary"> | number
    totalPresent?: IntFilter<"AttendanceSummary"> | number
    createdAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AttendanceSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceSummaryCountOrderByAggregateInput
    _avg?: AttendanceSummaryAvgOrderByAggregateInput
    _max?: AttendanceSummaryMaxOrderByAggregateInput
    _min?: AttendanceSummaryMinOrderByAggregateInput
    _sum?: AttendanceSummarySumOrderByAggregateInput
  }

  export type AttendanceSummaryScalarWhereWithAggregatesInput = {
    AND?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    OR?: AttendanceSummaryScalarWhereWithAggregatesInput[]
    NOT?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AttendanceSummary"> | string
    userId?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    totalEvents?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    totalSessions?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    totalTasks?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    totalAttendance?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    totalHeadsUps?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    totalPresent?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
  }

  export type HeadsUpWhereInput = {
    AND?: HeadsUpWhereInput | HeadsUpWhereInput[]
    OR?: HeadsUpWhereInput[]
    NOT?: HeadsUpWhereInput | HeadsUpWhereInput[]
    id?: UuidFilter<"HeadsUp"> | string
    userId?: StringFilter<"HeadsUp"> | string
    type?: EnumHeadsUpTypeFilter<"HeadsUp"> | $Enums.HeadsUpType
    body?: StringFilter<"HeadsUp"> | string
    sentAt?: DateTimeFilter<"HeadsUp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
  }

  export type HeadsUpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    user?: UserOrderByWithRelationInput
    attendance?: AttendanceOrderByWithRelationInput
  }

  export type HeadsUpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeadsUpWhereInput | HeadsUpWhereInput[]
    OR?: HeadsUpWhereInput[]
    NOT?: HeadsUpWhereInput | HeadsUpWhereInput[]
    userId?: StringFilter<"HeadsUp"> | string
    type?: EnumHeadsUpTypeFilter<"HeadsUp"> | $Enums.HeadsUpType
    body?: StringFilter<"HeadsUp"> | string
    sentAt?: DateTimeFilter<"HeadsUp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
  }, "id">

  export type HeadsUpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    _count?: HeadsUpCountOrderByAggregateInput
    _max?: HeadsUpMaxOrderByAggregateInput
    _min?: HeadsUpMinOrderByAggregateInput
  }

  export type HeadsUpScalarWhereWithAggregatesInput = {
    AND?: HeadsUpScalarWhereWithAggregatesInput | HeadsUpScalarWhereWithAggregatesInput[]
    OR?: HeadsUpScalarWhereWithAggregatesInput[]
    NOT?: HeadsUpScalarWhereWithAggregatesInput | HeadsUpScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"HeadsUp"> | string
    userId?: StringWithAggregatesFilter<"HeadsUp"> | string
    type?: EnumHeadsUpTypeWithAggregatesFilter<"HeadsUp"> | $Enums.HeadsUpType
    body?: StringWithAggregatesFilter<"HeadsUp"> | string
    sentAt?: DateTimeWithAggregatesFilter<"HeadsUp"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: UserListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: UserListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    description?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: UuidFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    description?: StringNullableFilter<"Announcement"> | string | null
    visibility?: EnumAnnouncementVisibilityFilter<"Announcement"> | $Enums.AnnouncementVisibility
    Tags?: EnumTagNullableListFilter<"Announcement">
    announcementType?: EnumAnnouncementTypeFilter<"Announcement"> | $Enums.AnnouncementType
    sourceId?: UuidNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    user?: UserListRelationFilter
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    visibility?: SortOrder
    Tags?: SortOrder
    announcementType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    description?: StringNullableFilter<"Announcement"> | string | null
    visibility?: EnumAnnouncementVisibilityFilter<"Announcement"> | $Enums.AnnouncementVisibility
    Tags?: EnumTagNullableListFilter<"Announcement">
    announcementType?: EnumAnnouncementTypeFilter<"Announcement"> | $Enums.AnnouncementType
    sourceId?: UuidNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    user?: UserListRelationFilter
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    visibility?: SortOrder
    Tags?: SortOrder
    announcementType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    description?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    visibility?: EnumAnnouncementVisibilityWithAggregatesFilter<"Announcement"> | $Enums.AnnouncementVisibility
    Tags?: EnumTagNullableListFilter<"Announcement">
    announcementType?: EnumAnnouncementTypeWithAggregatesFilter<"Announcement"> | $Enums.AnnouncementType
    sourceId?: UuidNullableWithAggregatesFilter<"Announcement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type FileCategoriesWhereInput = {
    AND?: FileCategoriesWhereInput | FileCategoriesWhereInput[]
    OR?: FileCategoriesWhereInput[]
    NOT?: FileCategoriesWhereInput | FileCategoriesWhereInput[]
    id?: UuidFilter<"FileCategories"> | string
    name?: StringFilter<"FileCategories"> | string
    description?: StringNullableFilter<"FileCategories"> | string | null
    createdAt?: DateTimeFilter<"FileCategories"> | Date | string
    updatedAt?: DateTimeFilter<"FileCategories"> | Date | string
    files?: FileListRelationFilter
  }

  export type FileCategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    files?: FileOrderByRelationAggregateInput
  }

  export type FileCategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileCategoriesWhereInput | FileCategoriesWhereInput[]
    OR?: FileCategoriesWhereInput[]
    NOT?: FileCategoriesWhereInput | FileCategoriesWhereInput[]
    name?: StringFilter<"FileCategories"> | string
    description?: StringNullableFilter<"FileCategories"> | string | null
    createdAt?: DateTimeFilter<"FileCategories"> | Date | string
    updatedAt?: DateTimeFilter<"FileCategories"> | Date | string
    files?: FileListRelationFilter
  }, "id">

  export type FileCategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileCategoriesCountOrderByAggregateInput
    _max?: FileCategoriesMaxOrderByAggregateInput
    _min?: FileCategoriesMinOrderByAggregateInput
  }

  export type FileCategoriesScalarWhereWithAggregatesInput = {
    AND?: FileCategoriesScalarWhereWithAggregatesInput | FileCategoriesScalarWhereWithAggregatesInput[]
    OR?: FileCategoriesScalarWhereWithAggregatesInput[]
    NOT?: FileCategoriesScalarWhereWithAggregatesInput | FileCategoriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FileCategories"> | string
    name?: StringWithAggregatesFilter<"FileCategories"> | string
    description?: StringNullableWithAggregatesFilter<"FileCategories"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FileCategories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileCategories"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: UuidFilter<"File"> | string
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    type?: StringFilter<"File"> | string
    tag?: StringNullableFilter<"File"> | string | null
    size?: IntFilter<"File"> | number
    fileUrl?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    categoryId?: UuidNullableFilter<"File"> | string | null
    categories?: XOR<FileCategoriesNullableScalarRelationFilter, FileCategoriesWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    tag?: SortOrderInput | SortOrder
    size?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    categories?: FileCategoriesOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    type?: StringFilter<"File"> | string
    tag?: StringNullableFilter<"File"> | string | null
    size?: IntFilter<"File"> | number
    fileUrl?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    categoryId?: UuidNullableFilter<"File"> | string | null
    categories?: XOR<FileCategoriesNullableScalarRelationFilter, FileCategoriesWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    tag?: SortOrderInput | SortOrder
    size?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    description?: StringNullableWithAggregatesFilter<"File"> | string | null
    type?: StringWithAggregatesFilter<"File"> | string
    tag?: StringNullableWithAggregatesFilter<"File"> | string | null
    size?: IntWithAggregatesFilter<"File"> | number
    fileUrl?: StringWithAggregatesFilter<"File"> | string
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    categoryId?: UuidNullableWithAggregatesFilter<"File"> | string | null
  }

  export type BadgesWhereInput = {
    AND?: BadgesWhereInput | BadgesWhereInput[]
    OR?: BadgesWhereInput[]
    NOT?: BadgesWhereInput | BadgesWhereInput[]
    id?: UuidFilter<"Badges"> | string
    name?: StringFilter<"Badges"> | string
    description?: StringNullableFilter<"Badges"> | string | null
    imageUrl?: StringNullableFilter<"Badges"> | string | null
    criteria?: StringNullableFilter<"Badges"> | string | null
    points?: IntNullableFilter<"Badges"> | number | null
    createdAt?: DateTimeFilter<"Badges"> | Date | string
    updatedAt?: DateTimeFilter<"Badges"> | Date | string
    user?: UserListRelationFilter
  }

  export type BadgesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    criteria?: SortOrderInput | SortOrder
    points?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type BadgesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgesWhereInput | BadgesWhereInput[]
    OR?: BadgesWhereInput[]
    NOT?: BadgesWhereInput | BadgesWhereInput[]
    name?: StringFilter<"Badges"> | string
    description?: StringNullableFilter<"Badges"> | string | null
    imageUrl?: StringNullableFilter<"Badges"> | string | null
    criteria?: StringNullableFilter<"Badges"> | string | null
    points?: IntNullableFilter<"Badges"> | number | null
    createdAt?: DateTimeFilter<"Badges"> | Date | string
    updatedAt?: DateTimeFilter<"Badges"> | Date | string
    user?: UserListRelationFilter
  }, "id">

  export type BadgesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    criteria?: SortOrderInput | SortOrder
    points?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BadgesCountOrderByAggregateInput
    _avg?: BadgesAvgOrderByAggregateInput
    _max?: BadgesMaxOrderByAggregateInput
    _min?: BadgesMinOrderByAggregateInput
    _sum?: BadgesSumOrderByAggregateInput
  }

  export type BadgesScalarWhereWithAggregatesInput = {
    AND?: BadgesScalarWhereWithAggregatesInput | BadgesScalarWhereWithAggregatesInput[]
    OR?: BadgesScalarWhereWithAggregatesInput[]
    NOT?: BadgesScalarWhereWithAggregatesInput | BadgesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Badges"> | string
    name?: StringWithAggregatesFilter<"Badges"> | string
    description?: StringNullableWithAggregatesFilter<"Badges"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Badges"> | string | null
    criteria?: StringNullableWithAggregatesFilter<"Badges"> | string | null
    points?: IntNullableWithAggregatesFilter<"Badges"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Badges"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Badges"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    key?: StringFilter<"Permission"> | string
    label?: StringFilter<"Permission"> | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    label?: StringFilter<"Permission"> | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "key">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    key?: StringWithAggregatesFilter<"Permission"> | string
    label?: StringWithAggregatesFilter<"Permission"> | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    role?: EnumRoleTypeFilter<"RolePermission"> | $Enums.RoleType
    permissionId?: IntFilter<"RolePermission"> | number
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    role_permissionId?: RolePermissionRolePermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    role?: EnumRoleTypeFilter<"RolePermission"> | $Enums.RoleType
    permissionId?: IntFilter<"RolePermission"> | number
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "role_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    role?: EnumRoleTypeWithAggregatesFilter<"RolePermission"> | $Enums.RoleType
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
  }

  export type UserCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UniversityInfoCreateInput = {
    id?: string
    currentYear?: number | null
    expectedGraduationYear?: number | null
    major?: string | null
    universityId?: string | null
    status: $Enums.UniversityStatus
    department?: string | null
    user?: UserCreateNestedOneWithoutUniversityInfoInput
  }

  export type UniversityInfoUncheckedCreateInput = {
    id?: string
    currentYear?: number | null
    expectedGraduationYear?: number | null
    major?: string | null
    universityId?: string | null
    status: $Enums.UniversityStatus
    department?: string | null
    userId?: string | null
  }

  export type UniversityInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentYear?: NullableIntFieldUpdateOperationsInput | number | null
    expectedGraduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUniversityStatusFieldUpdateOperationsInput | $Enums.UniversityStatus
    department?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUniversityInfoNestedInput
  }

  export type UniversityInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentYear?: NullableIntFieldUpdateOperationsInput | number | null
    expectedGraduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUniversityStatusFieldUpdateOperationsInput | $Enums.UniversityStatus
    department?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UniversityInfoCreateManyInput = {
    id?: string
    currentYear?: number | null
    expectedGraduationYear?: number | null
    major?: string | null
    universityId?: string | null
    status: $Enums.UniversityStatus
    department?: string | null
    userId?: string | null
  }

  export type UniversityInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentYear?: NullableIntFieldUpdateOperationsInput | number | null
    expectedGraduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUniversityStatusFieldUpdateOperationsInput | $Enums.UniversityStatus
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UniversityInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentYear?: NullableIntFieldUpdateOperationsInput | number | null
    expectedGraduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUniversityStatusFieldUpdateOperationsInput | $Enums.UniversityStatus
    department?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSettingCreateInput = {
    id?: string
    theme?: $Enums.Theme
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    user: UserCreateNestedOneWithoutUserSettingInput
  }

  export type UserSettingUncheckedCreateInput = {
    id?: string
    theme?: $Enums.Theme
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    userId: string
  }

  export type UserSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    phonePublic?: BoolFieldUpdateOperationsInput | boolean
    authUpdateCalendar?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUserSettingNestedInput
  }

  export type UserSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    phonePublic?: BoolFieldUpdateOperationsInput | boolean
    authUpdateCalendar?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSettingCreateManyInput = {
    id?: string
    theme?: $Enums.Theme
    phonePublic?: boolean
    authUpdateCalendar?: boolean
    userId: string
  }

  export type UserSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    phonePublic?: BoolFieldUpdateOperationsInput | boolean
    authUpdateCalendar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    phonePublic?: BoolFieldUpdateOperationsInput | boolean
    authUpdateCalendar?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DivisionsCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHead?: UserCreateNestedOneWithoutDivisionHeadInput
    user?: UserCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkCreateNestedManyWithoutDivisionInput
    sessions?: SessionsCreateNestedManyWithoutDivisionInput
    groups?: GroupsCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHeadID?: string | null
    user?: UserUncheckedCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutDivisionInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutDivisionInput
    groups?: GroupsUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHead?: UserUpdateOneWithoutDivisionHeadNestedInput
    user?: UserUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHeadID?: string | null
  }

  export type DivisionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DivisionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupsCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutGroupsInput
    division?: DivisionsCreateNestedOneWithoutGroupsInput
    sessions?: SessionsCreateNestedManyWithoutTargetGroupsInput
    events?: EventsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutTargetGroupsInput
    events?: EventsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutGroupsNestedInput
    division?: DivisionsUpdateOneWithoutGroupsNestedInput
    sessions?: SessionsUpdateManyWithoutTargetGroupsNestedInput
    events?: EventsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutTargetGroupsNestedInput
    events?: EventsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionId?: string | null
  }

  export type GroupsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type socialLinkCreateInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSocialLinksInput
    Division?: DivisionsCreateNestedOneWithoutSocialLinksInput
  }

  export type socialLinkUncheckedCreateInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    userId?: string | null
    DivisionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type socialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSocialLinksNestedInput
    Division?: DivisionsUpdateOneWithoutSocialLinksNestedInput
  }

  export type socialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type socialLinkCreateManyInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    userId?: string | null
    DivisionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type socialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type socialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTimeSlotCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    event?: EventsCreateNestedOneWithoutTimeSlotsInput
  }

  export type EventTimeSlotUncheckedCreateInput = {
    id?: string
    eventId?: string | null
    startTime: Date | string
    endTime: Date | string
  }

  export type EventTimeSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventsUpdateOneWithoutTimeSlotsNestedInput
  }

  export type EventTimeSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTimeSlotCreateManyInput = {
    id?: string
    eventId?: string | null
    startTime: Date | string
    endTime: Date | string
  }

  export type EventTimeSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTimeSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionTimeSlotCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    session?: SessionsCreateNestedOneWithoutTimeSlotInput
  }

  export type SessionTimeSlotUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    startTime: Date | string
    endTime: Date | string
  }

  export type SessionTimeSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionsUpdateOneWithoutTimeSlotNestedInput
  }

  export type SessionTimeSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionTimeSlotCreateManyInput = {
    id?: string
    sessionId?: string | null
    startTime: Date | string
    endTime: Date | string
  }

  export type SessionTimeSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionTimeSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutEventsInput
    timeSlots?: EventTimeSlotCreateNestedManyWithoutEventInput
    groups?: GroupsCreateNestedManyWithoutEventsInput
    tasks?: TasksCreateNestedManyWithoutEventInput
    participants?: EventParticipationCreateNestedManyWithoutEventInput
    attendance?: AttendanceCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    timeSlots?: EventTimeSlotUncheckedCreateNestedManyWithoutEventInput
    groups?: GroupsUncheckedCreateNestedManyWithoutEventsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutEventInput
    participants?: EventParticipationUncheckedCreateNestedManyWithoutEventInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutEventsNestedInput
    timeSlots?: EventTimeSlotUpdateManyWithoutEventNestedInput
    groups?: GroupsUpdateManyWithoutEventsNestedInput
    tasks?: TasksUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    timeSlots?: EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutEventsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUncheckedUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventsCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type EventsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionsCreateInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionsCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type SessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type TasksCreateInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    assignedTo?: UserCreateNestedManyWithoutAssignedTasksInput
    event?: EventsCreateNestedOneWithoutTasksInput
    session?: SessionsCreateNestedOneWithoutTasksInput
    participants?: TaskParticipationCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    eventId?: string | null
    sessionId?: string | null
    assignedTo?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
    participants?: TaskParticipationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignedTo?: UserUpdateManyWithoutAssignedTasksNestedInput
    event?: EventsUpdateOneWithoutTasksNestedInput
    session?: SessionsUpdateOneWithoutTasksNestedInput
    participants?: TaskParticipationUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
    participants?: TaskParticipationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    eventId?: string | null
    sessionId?: string | null
  }

  export type TasksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipationCreateInput = {
    id?: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    event: EventsCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutEventParticipationInput
  }

  export type EventParticipationUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type EventParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventsUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutEventParticipationNestedInput
  }

  export type EventParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipationCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type EventParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipationCreateInput = {
    id?: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    session: SessionsCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutSessionParticipationInput
  }

  export type SessionParticipationUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type SessionParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionsUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionParticipationNestedInput
  }

  export type SessionParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipationCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type SessionParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationCreateInput = {
    id?: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    task: TasksCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTaskParticipationInput
  }

  export type TaskParticipationUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type TaskParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TasksUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTaskParticipationNestedInput
  }

  export type TaskParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type TaskParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
    session?: SessionsCreateNestedOneWithoutAttendanceInput
    event?: EventsCreateNestedOneWithoutAttendanceInput
    headsUp?: HeadsUpCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId?: string | null
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
    session?: SessionsUpdateOneWithoutAttendanceNestedInput
    event?: EventsUpdateOneWithoutAttendanceNestedInput
    headsUp?: HeadsUpUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    userId: string
    sessionId?: string | null
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryCreateInput = {
    id?: string
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceSummaryInput
  }

  export type AttendanceSummaryUncheckedCreateInput = {
    id?: string
    userId: string
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    totalAttendance?: IntFieldUpdateOperationsInput | number
    totalHeadsUps?: IntFieldUpdateOperationsInput | number
    totalPresent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceSummaryNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    totalAttendance?: IntFieldUpdateOperationsInput | number
    totalHeadsUps?: IntFieldUpdateOperationsInput | number
    totalPresent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryCreateManyInput = {
    id?: string
    userId: string
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    totalAttendance?: IntFieldUpdateOperationsInput | number
    totalHeadsUps?: IntFieldUpdateOperationsInput | number
    totalPresent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    totalAttendance?: IntFieldUpdateOperationsInput | number
    totalHeadsUps?: IntFieldUpdateOperationsInput | number
    totalPresent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeadsUpCreateInput = {
    id?: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
    user: UserCreateNestedOneWithoutHeadsUpInput
    attendance?: AttendanceCreateNestedOneWithoutHeadsUpInput
  }

  export type HeadsUpUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedOneWithoutHeadsUpInput
  }

  export type HeadsUpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHeadsUpNestedInput
    attendance?: AttendanceUpdateOneWithoutHeadsUpNestedInput
  }

  export type HeadsUpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateOneWithoutHeadsUpNestedInput
  }

  export type HeadsUpCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
  }

  export type HeadsUpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeadsUpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    description?: string | null
    visibility: $Enums.AnnouncementVisibility
    Tags?: AnnouncementCreateTagsInput | $Enums.Tag[]
    announcementType: $Enums.AnnouncementType
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    visibility: $Enums.AnnouncementVisibility
    Tags?: AnnouncementCreateTagsInput | $Enums.Tag[]
    announcementType: $Enums.AnnouncementType
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutAnnouncementsInput
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutAnnouncementsNestedInput
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    visibility: $Enums.AnnouncementVisibility
    Tags?: AnnouncementCreateTagsInput | $Enums.Tag[]
    announcementType: $Enums.AnnouncementType
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCategoriesCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileCreateNestedManyWithoutCategoriesInput
  }

  export type FileCategoriesUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type FileCategoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUpdateManyWithoutCategoriesNestedInput
  }

  export type FileCategoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type FileCategoriesCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCategoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCategoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    tag?: string | null
    size: number
    fileUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: FileCategoriesCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    tag?: string | null
    size: number
    fileUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: FileCategoriesUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    tag?: string | null
    size: number
    fileUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BadgesCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    criteria?: string | null
    points?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutBadgesInput
  }

  export type BadgesUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    criteria?: string | null
    points?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutBadgesInput
  }

  export type BadgesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutBadgesNestedInput
  }

  export type BadgesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutBadgesNestedInput
  }

  export type BadgesCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    criteria?: string | null
    points?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    key: string
    label: string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    key: string
    label: string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    key: string
    label: string
  }

  export type PermissionUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateInput = {
    role: $Enums.RoleType
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    role: $Enums.RoleType
    permissionId: number
  }

  export type RolePermissionUpdateInput = {
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    role: $Enums.RoleType
    permissionId: number
  }

  export type RolePermissionUpdateManyMutationInput = {
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumClubStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubStatus | EnumClubStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClubStatusNullableFilter<$PrismaModel> | $Enums.ClubStatus | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleType | EnumRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleTypeFilter<$PrismaModel> | $Enums.RoleType
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UniversityInfoNullableScalarRelationFilter = {
    is?: UniversityInfoWhereInput | null
    isNot?: UniversityInfoWhereInput | null
  }

  export type DivisionsNullableScalarRelationFilter = {
    is?: DivisionsWhereInput | null
    isNot?: DivisionsWhereInput | null
  }

  export type SocialLinkListRelationFilter = {
    every?: socialLinkWhereInput
    some?: socialLinkWhereInput
    none?: socialLinkWhereInput
  }

  export type UserSettingNullableScalarRelationFilter = {
    is?: UserSettingWhereInput | null
    isNot?: UserSettingWhereInput | null
  }

  export type BadgesListRelationFilter = {
    every?: BadgesWhereInput
    some?: BadgesWhereInput
    none?: BadgesWhereInput
  }

  export type EventsListRelationFilter = {
    every?: EventsWhereInput
    some?: EventsWhereInput
    none?: EventsWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: SessionsWhereInput
    some?: SessionsWhereInput
    none?: SessionsWhereInput
  }

  export type GroupsListRelationFilter = {
    every?: GroupsWhereInput
    some?: GroupsWhereInput
    none?: GroupsWhereInput
  }

  export type TasksListRelationFilter = {
    every?: TasksWhereInput
    some?: TasksWhereInput
    none?: TasksWhereInput
  }

  export type EventParticipationListRelationFilter = {
    every?: EventParticipationWhereInput
    some?: EventParticipationWhereInput
    none?: EventParticipationWhereInput
  }

  export type SessionParticipationListRelationFilter = {
    every?: SessionParticipationWhereInput
    some?: SessionParticipationWhereInput
    none?: SessionParticipationWhereInput
  }

  export type TaskParticipationListRelationFilter = {
    every?: TaskParticipationWhereInput
    some?: TaskParticipationWhereInput
    none?: TaskParticipationWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type AttendanceSummaryNullableScalarRelationFilter = {
    is?: AttendanceSummaryWhereInput | null
    isNot?: AttendanceSummaryWhereInput | null
  }

  export type HeadsUpListRelationFilter = {
    every?: HeadsUpWhereInput
    some?: HeadsUpWhereInput
    none?: HeadsUpWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type socialLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HeadsUpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    telegramUserName?: SortOrder
    bio?: SortOrder
    berthDate?: SortOrder
    profileImageUrl?: SortOrder
    clubStatus?: SortOrder
    specialty?: SortOrder
    cvUrl?: SortOrder
    lastSeen?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DivisionId?: SortOrder
    UserSettingId?: SortOrder
    DivisionHeadID?: SortOrder
    AttendanceSummaryId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    telegramUserName?: SortOrder
    bio?: SortOrder
    berthDate?: SortOrder
    profileImageUrl?: SortOrder
    clubStatus?: SortOrder
    specialty?: SortOrder
    cvUrl?: SortOrder
    lastSeen?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DivisionId?: SortOrder
    UserSettingId?: SortOrder
    DivisionHeadID?: SortOrder
    AttendanceSummaryId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    telegramUserName?: SortOrder
    bio?: SortOrder
    berthDate?: SortOrder
    profileImageUrl?: SortOrder
    clubStatus?: SortOrder
    specialty?: SortOrder
    cvUrl?: SortOrder
    lastSeen?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DivisionId?: SortOrder
    UserSettingId?: SortOrder
    DivisionHeadID?: SortOrder
    AttendanceSummaryId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumClubStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubStatus | EnumClubStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClubStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ClubStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumClubStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumClubStatusNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleType | EnumRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleTypeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumUniversityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UniversityStatus | EnumUniversityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUniversityStatusFilter<$PrismaModel> | $Enums.UniversityStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UniversityInfoCountOrderByAggregateInput = {
    id?: SortOrder
    currentYear?: SortOrder
    expectedGraduationYear?: SortOrder
    major?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    department?: SortOrder
    userId?: SortOrder
  }

  export type UniversityInfoAvgOrderByAggregateInput = {
    currentYear?: SortOrder
    expectedGraduationYear?: SortOrder
  }

  export type UniversityInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    currentYear?: SortOrder
    expectedGraduationYear?: SortOrder
    major?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    department?: SortOrder
    userId?: SortOrder
  }

  export type UniversityInfoMinOrderByAggregateInput = {
    id?: SortOrder
    currentYear?: SortOrder
    expectedGraduationYear?: SortOrder
    major?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    department?: SortOrder
    userId?: SortOrder
  }

  export type UniversityInfoSumOrderByAggregateInput = {
    currentYear?: SortOrder
    expectedGraduationYear?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUniversityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UniversityStatus | EnumUniversityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUniversityStatusWithAggregatesFilter<$PrismaModel> | $Enums.UniversityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUniversityStatusFilter<$PrismaModel>
    _max?: NestedEnumUniversityStatusFilter<$PrismaModel>
  }

  export type EnumThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeFilter<$PrismaModel> | $Enums.Theme
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSettingCountOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    phonePublic?: SortOrder
    authUpdateCalendar?: SortOrder
    userId?: SortOrder
  }

  export type UserSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    phonePublic?: SortOrder
    authUpdateCalendar?: SortOrder
    userId?: SortOrder
  }

  export type UserSettingMinOrderByAggregateInput = {
    id?: SortOrder
    theme?: SortOrder
    phonePublic?: SortOrder
    authUpdateCalendar?: SortOrder
    userId?: SortOrder
  }

  export type EnumThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeWithAggregatesFilter<$PrismaModel> | $Enums.Theme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeFilter<$PrismaModel>
    _max?: NestedEnumThemeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DivisionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    establishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentHeadID?: SortOrder
  }

  export type DivisionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    establishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentHeadID?: SortOrder
  }

  export type DivisionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    establishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentHeadID?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    divisionId?: SortOrder
  }

  export type GroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    divisionId?: SortOrder
  }

  export type GroupsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    divisionId?: SortOrder
  }

  export type socialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    socialLinkName?: SortOrder
    socialLinkUrl?: SortOrder
    userId?: SortOrder
    DivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type socialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    socialLinkName?: SortOrder
    socialLinkUrl?: SortOrder
    userId?: SortOrder
    DivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type socialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    socialLinkName?: SortOrder
    socialLinkUrl?: SortOrder
    userId?: SortOrder
    DivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsNullableScalarRelationFilter = {
    is?: EventsWhereInput | null
    isNot?: EventsWhereInput | null
  }

  export type EventTimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type EventTimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type EventTimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type SessionsNullableScalarRelationFilter = {
    is?: SessionsWhereInput | null
    isNot?: SessionsWhereInput | null
  }

  export type SessionTimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type SessionTimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type SessionTimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type EnumTagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Tag[] | ListEnumTagFieldRefInput<$PrismaModel> | null
    has?: $Enums.Tag | EnumTagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Tag[] | ListEnumTagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Tag[] | ListEnumTagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumEventVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.EventVisibility | EnumEventVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEventVisibilityFilter<$PrismaModel> | $Enums.EventVisibility
  }

  export type EnumstateFilter<$PrismaModel = never> = {
    equals?: $Enums.state | EnumstateFieldRefInput<$PrismaModel>
    in?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    notIn?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    not?: NestedEnumstateFilter<$PrismaModel> | $Enums.state
  }

  export type EventTimeSlotListRelationFilter = {
    every?: EventTimeSlotWhereInput
    some?: EventTimeSlotWhereInput
    none?: EventTimeSlotWhereInput
  }

  export type EventTimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    visibility?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    visibility?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type EnumEventVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventVisibility | EnumEventVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEventVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.EventVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventVisibilityFilter<$PrismaModel>
    _max?: NestedEnumEventVisibilityFilter<$PrismaModel>
  }

  export type EnumstateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.state | EnumstateFieldRefInput<$PrismaModel>
    in?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    notIn?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    not?: NestedEnumstateWithAggregatesFilter<$PrismaModel> | $Enums.state
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstateFilter<$PrismaModel>
    _max?: NestedEnumstateFilter<$PrismaModel>
  }

  export type DivisionsListRelationFilter = {
    every?: DivisionsWhereInput
    some?: DivisionsWhereInput
    none?: DivisionsWhereInput
  }

  export type SessionTimeSlotListRelationFilter = {
    every?: SessionTimeSlotWhereInput
    some?: SessionTimeSlotWhereInput
    none?: SessionTimeSlotWhereInput
  }

  export type DivisionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionTimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startMonth?: SortOrder
    endTMonth?: SortOrder
    location?: SortOrder
    tags?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type SessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startMonth?: SortOrder
    endTMonth?: SortOrder
    location?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type SessionsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startMonth?: SortOrder
    endTMonth?: SortOrder
    location?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type TasksCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedNotes?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    eventId?: SortOrder
    sessionId?: SortOrder
  }

  export type TasksMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedNotes?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    eventId?: SortOrder
    sessionId?: SortOrder
  }

  export type TasksMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedNotes?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    eventId?: SortOrder
    sessionId?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumEventRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRole | EnumEventRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRoleFilter<$PrismaModel> | $Enums.EventRole
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EventsScalarRelationFilter = {
    is?: EventsWhereInput
    isNot?: EventsWhereInput
  }

  export type EventParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type EventParticipationAvgOrderByAggregateInput = {
    score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type EventParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type EventParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type EventParticipationSumOrderByAggregateInput = {
    score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type EnumEventRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRole | EnumEventRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRoleWithAggregatesFilter<$PrismaModel> | $Enums.EventRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventRoleFilter<$PrismaModel>
    _max?: NestedEnumEventRoleFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumSessionRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionRole | EnumSessionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionRoleFilter<$PrismaModel> | $Enums.SessionRole
  }

  export type SessionsScalarRelationFilter = {
    is?: SessionsWhereInput
    isNot?: SessionsWhereInput
  }

  export type SessionParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionParticipationAvgOrderByAggregateInput = {
    score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type SessionParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionParticipationSumOrderByAggregateInput = {
    score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type EnumSessionRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionRole | EnumSessionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionRoleWithAggregatesFilter<$PrismaModel> | $Enums.SessionRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionRoleFilter<$PrismaModel>
    _max?: NestedEnumSessionRoleFilter<$PrismaModel>
  }

  export type TasksScalarRelationFilter = {
    is?: TasksWhereInput
    isNot?: TasksWhereInput
  }

  export type TaskParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskParticipationAvgOrderByAggregateInput = {
    score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type TaskParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskParticipationSumOrderByAggregateInput = {
    score?: SortOrder
    feedbackScore?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type HeadsUpNullableScalarRelationFilter = {
    is?: HeadsUpWhereInput | null
    isNot?: HeadsUpWhereInput | null
  }

  export type AttendanceUserIdSessionIdCompoundUniqueInput = {
    userId: string
    sessionId: string
  }

  export type AttendanceUserIdEventIdCompoundUniqueInput = {
    userId: string
    eventId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    headsUpId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    headsUpId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    headsUpId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type AttendanceSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSummaryAvgOrderByAggregateInput = {
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
  }

  export type AttendanceSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSummarySumOrderByAggregateInput = {
    totalEvents?: SortOrder
    totalSessions?: SortOrder
    totalTasks?: SortOrder
    totalAttendance?: SortOrder
    totalHeadsUps?: SortOrder
    totalPresent?: SortOrder
  }

  export type EnumHeadsUpTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HeadsUpType | EnumHeadsUpTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeadsUpTypeFilter<$PrismaModel> | $Enums.HeadsUpType
  }

  export type AttendanceNullableScalarRelationFilter = {
    is?: AttendanceWhereInput | null
    isNot?: AttendanceWhereInput | null
  }

  export type HeadsUpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
  }

  export type HeadsUpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
  }

  export type HeadsUpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
  }

  export type EnumHeadsUpTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HeadsUpType | EnumHeadsUpTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeadsUpTypeWithAggregatesFilter<$PrismaModel> | $Enums.HeadsUpType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHeadsUpTypeFilter<$PrismaModel>
    _max?: NestedEnumHeadsUpTypeFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnnouncementVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementVisibility | EnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementVisibilityFilter<$PrismaModel> | $Enums.AnnouncementVisibility
  }

  export type EnumAnnouncementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeFilter<$PrismaModel> | $Enums.AnnouncementType
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    Tags?: SortOrder
    announcementType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    announcementType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    announcementType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnnouncementVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementVisibility | EnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementVisibilityFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementVisibilityFilter<$PrismaModel>
  }

  export type EnumAnnouncementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileCategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileCategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileCategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileCategoriesNullableScalarRelationFilter = {
    is?: FileCategoriesWhereInput | null
    isNot?: FileCategoriesWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    tag?: SortOrder
    size?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    tag?: SortOrder
    size?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    tag?: SortOrder
    size?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BadgesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    criteria?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgesAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type BadgesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    criteria?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    criteria?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgesSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRolePermissionIdCompoundUniqueInput = {
    role: $Enums.RoleType
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    permissionId?: SortOrder
  }

  export type UniversityInfoCreateNestedOneWithoutUserInput = {
    create?: XOR<UniversityInfoCreateWithoutUserInput, UniversityInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UniversityInfoCreateOrConnectWithoutUserInput
    connect?: UniversityInfoWhereUniqueInput
  }

  export type DivisionsCreateNestedOneWithoutUserInput = {
    create?: XOR<DivisionsCreateWithoutUserInput, DivisionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutUserInput
    connect?: DivisionsWhereUniqueInput
  }

  export type socialLinkCreateNestedManyWithoutUserInput = {
    create?: XOR<socialLinkCreateWithoutUserInput, socialLinkUncheckedCreateWithoutUserInput> | socialLinkCreateWithoutUserInput[] | socialLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutUserInput | socialLinkCreateOrConnectWithoutUserInput[]
    createMany?: socialLinkCreateManyUserInputEnvelope
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
  }

  export type UserSettingCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput
    connect?: UserSettingWhereUniqueInput
  }

  export type BadgesCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgesCreateWithoutUserInput, BadgesUncheckedCreateWithoutUserInput> | BadgesCreateWithoutUserInput[] | BadgesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgesCreateOrConnectWithoutUserInput | BadgesCreateOrConnectWithoutUserInput[]
    connect?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
  }

  export type EventsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventsCreateWithoutCreatorInput, EventsUncheckedCreateWithoutCreatorInput> | EventsCreateWithoutCreatorInput[] | EventsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutCreatorInput | EventsCreateOrConnectWithoutCreatorInput[]
    createMany?: EventsCreateManyCreatorInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type SessionsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SessionsCreateWithoutCreatorInput, SessionsUncheckedCreateWithoutCreatorInput> | SessionsCreateWithoutCreatorInput[] | SessionsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutCreatorInput | SessionsCreateOrConnectWithoutCreatorInput[]
    createMany?: SessionsCreateManyCreatorInputEnvelope
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
  }

  export type GroupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<GroupsCreateWithoutUsersInput, GroupsUncheckedCreateWithoutUsersInput> | GroupsCreateWithoutUsersInput[] | GroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutUsersInput | GroupsCreateOrConnectWithoutUsersInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type DivisionsCreateNestedOneWithoutCurrentHeadInput = {
    create?: XOR<DivisionsCreateWithoutCurrentHeadInput, DivisionsUncheckedCreateWithoutCurrentHeadInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutCurrentHeadInput
    connect?: DivisionsWhereUniqueInput
  }

  export type TasksCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TasksCreateWithoutCreatorInput, TasksUncheckedCreateWithoutCreatorInput> | TasksCreateWithoutCreatorInput[] | TasksUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutCreatorInput | TasksCreateOrConnectWithoutCreatorInput[]
    createMany?: TasksCreateManyCreatorInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type TasksCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput> | TasksCreateWithoutAssignedToInput[] | TasksUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput | TasksCreateOrConnectWithoutAssignedToInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type EventParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<EventParticipationCreateWithoutUserInput, EventParticipationUncheckedCreateWithoutUserInput> | EventParticipationCreateWithoutUserInput[] | EventParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutUserInput | EventParticipationCreateOrConnectWithoutUserInput[]
    createMany?: EventParticipationCreateManyUserInputEnvelope
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
  }

  export type SessionParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionParticipationCreateWithoutUserInput, SessionParticipationUncheckedCreateWithoutUserInput> | SessionParticipationCreateWithoutUserInput[] | SessionParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutUserInput | SessionParticipationCreateOrConnectWithoutUserInput[]
    createMany?: SessionParticipationCreateManyUserInputEnvelope
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
  }

  export type TaskParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskParticipationCreateWithoutUserInput, TaskParticipationUncheckedCreateWithoutUserInput> | TaskParticipationCreateWithoutUserInput[] | TaskParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutUserInput | TaskParticipationCreateOrConnectWithoutUserInput[]
    createMany?: TaskParticipationCreateManyUserInputEnvelope
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceSummaryCreateNestedOneWithoutUserInput = {
    create?: XOR<AttendanceSummaryCreateWithoutUserInput, AttendanceSummaryUncheckedCreateWithoutUserInput>
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutUserInput
    connect?: AttendanceSummaryWhereUniqueInput
  }

  export type HeadsUpCreateNestedManyWithoutUserInput = {
    create?: XOR<HeadsUpCreateWithoutUserInput, HeadsUpUncheckedCreateWithoutUserInput> | HeadsUpCreateWithoutUserInput[] | HeadsUpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HeadsUpCreateOrConnectWithoutUserInput | HeadsUpCreateOrConnectWithoutUserInput[]
    createMany?: HeadsUpCreateManyUserInputEnvelope
    connect?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnouncementCreateWithoutUserInput, AnnouncementUncheckedCreateWithoutUserInput> | AnnouncementCreateWithoutUserInput[] | AnnouncementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutUserInput | AnnouncementCreateOrConnectWithoutUserInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type UniversityInfoUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UniversityInfoCreateWithoutUserInput, UniversityInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UniversityInfoCreateOrConnectWithoutUserInput
    connect?: UniversityInfoWhereUniqueInput
  }

  export type socialLinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<socialLinkCreateWithoutUserInput, socialLinkUncheckedCreateWithoutUserInput> | socialLinkCreateWithoutUserInput[] | socialLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutUserInput | socialLinkCreateOrConnectWithoutUserInput[]
    createMany?: socialLinkCreateManyUserInputEnvelope
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
  }

  export type UserSettingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput
    connect?: UserSettingWhereUniqueInput
  }

  export type BadgesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgesCreateWithoutUserInput, BadgesUncheckedCreateWithoutUserInput> | BadgesCreateWithoutUserInput[] | BadgesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgesCreateOrConnectWithoutUserInput | BadgesCreateOrConnectWithoutUserInput[]
    connect?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventsCreateWithoutCreatorInput, EventsUncheckedCreateWithoutCreatorInput> | EventsCreateWithoutCreatorInput[] | EventsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutCreatorInput | EventsCreateOrConnectWithoutCreatorInput[]
    createMany?: EventsCreateManyCreatorInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type SessionsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SessionsCreateWithoutCreatorInput, SessionsUncheckedCreateWithoutCreatorInput> | SessionsCreateWithoutCreatorInput[] | SessionsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutCreatorInput | SessionsCreateOrConnectWithoutCreatorInput[]
    createMany?: SessionsCreateManyCreatorInputEnvelope
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
  }

  export type GroupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<GroupsCreateWithoutUsersInput, GroupsUncheckedCreateWithoutUsersInput> | GroupsCreateWithoutUsersInput[] | GroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutUsersInput | GroupsCreateOrConnectWithoutUsersInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput = {
    create?: XOR<DivisionsCreateWithoutCurrentHeadInput, DivisionsUncheckedCreateWithoutCurrentHeadInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutCurrentHeadInput
    connect?: DivisionsWhereUniqueInput
  }

  export type TasksUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TasksCreateWithoutCreatorInput, TasksUncheckedCreateWithoutCreatorInput> | TasksCreateWithoutCreatorInput[] | TasksUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutCreatorInput | TasksCreateOrConnectWithoutCreatorInput[]
    createMany?: TasksCreateManyCreatorInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type TasksUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput> | TasksCreateWithoutAssignedToInput[] | TasksUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput | TasksCreateOrConnectWithoutAssignedToInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type EventParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventParticipationCreateWithoutUserInput, EventParticipationUncheckedCreateWithoutUserInput> | EventParticipationCreateWithoutUserInput[] | EventParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutUserInput | EventParticipationCreateOrConnectWithoutUserInput[]
    createMany?: EventParticipationCreateManyUserInputEnvelope
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
  }

  export type SessionParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionParticipationCreateWithoutUserInput, SessionParticipationUncheckedCreateWithoutUserInput> | SessionParticipationCreateWithoutUserInput[] | SessionParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutUserInput | SessionParticipationCreateOrConnectWithoutUserInput[]
    createMany?: SessionParticipationCreateManyUserInputEnvelope
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
  }

  export type TaskParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskParticipationCreateWithoutUserInput, TaskParticipationUncheckedCreateWithoutUserInput> | TaskParticipationCreateWithoutUserInput[] | TaskParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutUserInput | TaskParticipationCreateOrConnectWithoutUserInput[]
    createMany?: TaskParticipationCreateManyUserInputEnvelope
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AttendanceSummaryCreateWithoutUserInput, AttendanceSummaryUncheckedCreateWithoutUserInput>
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutUserInput
    connect?: AttendanceSummaryWhereUniqueInput
  }

  export type HeadsUpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HeadsUpCreateWithoutUserInput, HeadsUpUncheckedCreateWithoutUserInput> | HeadsUpCreateWithoutUserInput[] | HeadsUpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HeadsUpCreateOrConnectWithoutUserInput | HeadsUpCreateOrConnectWithoutUserInput[]
    createMany?: HeadsUpCreateManyUserInputEnvelope
    connect?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnouncementCreateWithoutUserInput, AnnouncementUncheckedCreateWithoutUserInput> | AnnouncementCreateWithoutUserInput[] | AnnouncementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutUserInput | AnnouncementCreateOrConnectWithoutUserInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumClubStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClubStatus | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoleType
  }

  export type UniversityInfoUpdateOneWithoutUserNestedInput = {
    create?: XOR<UniversityInfoCreateWithoutUserInput, UniversityInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UniversityInfoCreateOrConnectWithoutUserInput
    upsert?: UniversityInfoUpsertWithoutUserInput
    disconnect?: UniversityInfoWhereInput | boolean
    delete?: UniversityInfoWhereInput | boolean
    connect?: UniversityInfoWhereUniqueInput
    update?: XOR<XOR<UniversityInfoUpdateToOneWithWhereWithoutUserInput, UniversityInfoUpdateWithoutUserInput>, UniversityInfoUncheckedUpdateWithoutUserInput>
  }

  export type DivisionsUpdateOneWithoutUserNestedInput = {
    create?: XOR<DivisionsCreateWithoutUserInput, DivisionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutUserInput
    upsert?: DivisionsUpsertWithoutUserInput
    disconnect?: DivisionsWhereInput | boolean
    delete?: DivisionsWhereInput | boolean
    connect?: DivisionsWhereUniqueInput
    update?: XOR<XOR<DivisionsUpdateToOneWithWhereWithoutUserInput, DivisionsUpdateWithoutUserInput>, DivisionsUncheckedUpdateWithoutUserInput>
  }

  export type socialLinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<socialLinkCreateWithoutUserInput, socialLinkUncheckedCreateWithoutUserInput> | socialLinkCreateWithoutUserInput[] | socialLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutUserInput | socialLinkCreateOrConnectWithoutUserInput[]
    upsert?: socialLinkUpsertWithWhereUniqueWithoutUserInput | socialLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: socialLinkCreateManyUserInputEnvelope
    set?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    disconnect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    delete?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    update?: socialLinkUpdateWithWhereUniqueWithoutUserInput | socialLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: socialLinkUpdateManyWithWhereWithoutUserInput | socialLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: socialLinkScalarWhereInput | socialLinkScalarWhereInput[]
  }

  export type UserSettingUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput
    upsert?: UserSettingUpsertWithoutUserInput
    disconnect?: UserSettingWhereInput | boolean
    delete?: UserSettingWhereInput | boolean
    connect?: UserSettingWhereUniqueInput
    update?: XOR<XOR<UserSettingUpdateToOneWithWhereWithoutUserInput, UserSettingUpdateWithoutUserInput>, UserSettingUncheckedUpdateWithoutUserInput>
  }

  export type BadgesUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgesCreateWithoutUserInput, BadgesUncheckedCreateWithoutUserInput> | BadgesCreateWithoutUserInput[] | BadgesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgesCreateOrConnectWithoutUserInput | BadgesCreateOrConnectWithoutUserInput[]
    upsert?: BadgesUpsertWithWhereUniqueWithoutUserInput | BadgesUpsertWithWhereUniqueWithoutUserInput[]
    set?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    disconnect?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    delete?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    connect?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    update?: BadgesUpdateWithWhereUniqueWithoutUserInput | BadgesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgesUpdateManyWithWhereWithoutUserInput | BadgesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgesScalarWhereInput | BadgesScalarWhereInput[]
  }

  export type EventsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventsCreateWithoutCreatorInput, EventsUncheckedCreateWithoutCreatorInput> | EventsCreateWithoutCreatorInput[] | EventsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutCreatorInput | EventsCreateOrConnectWithoutCreatorInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutCreatorInput | EventsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventsCreateManyCreatorInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutCreatorInput | EventsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutCreatorInput | EventsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type SessionsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SessionsCreateWithoutCreatorInput, SessionsUncheckedCreateWithoutCreatorInput> | SessionsCreateWithoutCreatorInput[] | SessionsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutCreatorInput | SessionsCreateOrConnectWithoutCreatorInput[]
    upsert?: SessionsUpsertWithWhereUniqueWithoutCreatorInput | SessionsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SessionsCreateManyCreatorInputEnvelope
    set?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    disconnect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    delete?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    update?: SessionsUpdateWithWhereUniqueWithoutCreatorInput | SessionsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SessionsUpdateManyWithWhereWithoutCreatorInput | SessionsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
  }

  export type GroupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GroupsCreateWithoutUsersInput, GroupsUncheckedCreateWithoutUsersInput> | GroupsCreateWithoutUsersInput[] | GroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutUsersInput | GroupsCreateOrConnectWithoutUsersInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutUsersInput | GroupsUpsertWithWhereUniqueWithoutUsersInput[]
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutUsersInput | GroupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutUsersInput | GroupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type DivisionsUpdateOneWithoutCurrentHeadNestedInput = {
    create?: XOR<DivisionsCreateWithoutCurrentHeadInput, DivisionsUncheckedCreateWithoutCurrentHeadInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutCurrentHeadInput
    upsert?: DivisionsUpsertWithoutCurrentHeadInput
    disconnect?: DivisionsWhereInput | boolean
    delete?: DivisionsWhereInput | boolean
    connect?: DivisionsWhereUniqueInput
    update?: XOR<XOR<DivisionsUpdateToOneWithWhereWithoutCurrentHeadInput, DivisionsUpdateWithoutCurrentHeadInput>, DivisionsUncheckedUpdateWithoutCurrentHeadInput>
  }

  export type TasksUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TasksCreateWithoutCreatorInput, TasksUncheckedCreateWithoutCreatorInput> | TasksCreateWithoutCreatorInput[] | TasksUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutCreatorInput | TasksCreateOrConnectWithoutCreatorInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutCreatorInput | TasksUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TasksCreateManyCreatorInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutCreatorInput | TasksUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutCreatorInput | TasksUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type TasksUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput> | TasksCreateWithoutAssignedToInput[] | TasksUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput | TasksCreateOrConnectWithoutAssignedToInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutAssignedToInput | TasksUpsertWithWhereUniqueWithoutAssignedToInput[]
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutAssignedToInput | TasksUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutAssignedToInput | TasksUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type EventParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventParticipationCreateWithoutUserInput, EventParticipationUncheckedCreateWithoutUserInput> | EventParticipationCreateWithoutUserInput[] | EventParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutUserInput | EventParticipationCreateOrConnectWithoutUserInput[]
    upsert?: EventParticipationUpsertWithWhereUniqueWithoutUserInput | EventParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventParticipationCreateManyUserInputEnvelope
    set?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    disconnect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    delete?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    update?: EventParticipationUpdateWithWhereUniqueWithoutUserInput | EventParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventParticipationUpdateManyWithWhereWithoutUserInput | EventParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventParticipationScalarWhereInput | EventParticipationScalarWhereInput[]
  }

  export type SessionParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionParticipationCreateWithoutUserInput, SessionParticipationUncheckedCreateWithoutUserInput> | SessionParticipationCreateWithoutUserInput[] | SessionParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutUserInput | SessionParticipationCreateOrConnectWithoutUserInput[]
    upsert?: SessionParticipationUpsertWithWhereUniqueWithoutUserInput | SessionParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionParticipationCreateManyUserInputEnvelope
    set?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    disconnect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    delete?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    update?: SessionParticipationUpdateWithWhereUniqueWithoutUserInput | SessionParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionParticipationUpdateManyWithWhereWithoutUserInput | SessionParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionParticipationScalarWhereInput | SessionParticipationScalarWhereInput[]
  }

  export type TaskParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskParticipationCreateWithoutUserInput, TaskParticipationUncheckedCreateWithoutUserInput> | TaskParticipationCreateWithoutUserInput[] | TaskParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutUserInput | TaskParticipationCreateOrConnectWithoutUserInput[]
    upsert?: TaskParticipationUpsertWithWhereUniqueWithoutUserInput | TaskParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskParticipationCreateManyUserInputEnvelope
    set?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    disconnect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    delete?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    update?: TaskParticipationUpdateWithWhereUniqueWithoutUserInput | TaskParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskParticipationUpdateManyWithWhereWithoutUserInput | TaskParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskParticipationScalarWhereInput | TaskParticipationScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceSummaryUpdateOneWithoutUserNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutUserInput, AttendanceSummaryUncheckedCreateWithoutUserInput>
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutUserInput
    upsert?: AttendanceSummaryUpsertWithoutUserInput
    disconnect?: AttendanceSummaryWhereInput | boolean
    delete?: AttendanceSummaryWhereInput | boolean
    connect?: AttendanceSummaryWhereUniqueInput
    update?: XOR<XOR<AttendanceSummaryUpdateToOneWithWhereWithoutUserInput, AttendanceSummaryUpdateWithoutUserInput>, AttendanceSummaryUncheckedUpdateWithoutUserInput>
  }

  export type HeadsUpUpdateManyWithoutUserNestedInput = {
    create?: XOR<HeadsUpCreateWithoutUserInput, HeadsUpUncheckedCreateWithoutUserInput> | HeadsUpCreateWithoutUserInput[] | HeadsUpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HeadsUpCreateOrConnectWithoutUserInput | HeadsUpCreateOrConnectWithoutUserInput[]
    upsert?: HeadsUpUpsertWithWhereUniqueWithoutUserInput | HeadsUpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HeadsUpCreateManyUserInputEnvelope
    set?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    disconnect?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    delete?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    connect?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    update?: HeadsUpUpdateWithWhereUniqueWithoutUserInput | HeadsUpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HeadsUpUpdateManyWithWhereWithoutUserInput | HeadsUpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HeadsUpScalarWhereInput | HeadsUpScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnouncementCreateWithoutUserInput, AnnouncementUncheckedCreateWithoutUserInput> | AnnouncementCreateWithoutUserInput[] | AnnouncementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutUserInput | AnnouncementCreateOrConnectWithoutUserInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutUserInput | AnnouncementUpsertWithWhereUniqueWithoutUserInput[]
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutUserInput | AnnouncementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutUserInput | AnnouncementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type UniversityInfoUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UniversityInfoCreateWithoutUserInput, UniversityInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UniversityInfoCreateOrConnectWithoutUserInput
    upsert?: UniversityInfoUpsertWithoutUserInput
    disconnect?: UniversityInfoWhereInput | boolean
    delete?: UniversityInfoWhereInput | boolean
    connect?: UniversityInfoWhereUniqueInput
    update?: XOR<XOR<UniversityInfoUpdateToOneWithWhereWithoutUserInput, UniversityInfoUpdateWithoutUserInput>, UniversityInfoUncheckedUpdateWithoutUserInput>
  }

  export type socialLinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<socialLinkCreateWithoutUserInput, socialLinkUncheckedCreateWithoutUserInput> | socialLinkCreateWithoutUserInput[] | socialLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutUserInput | socialLinkCreateOrConnectWithoutUserInput[]
    upsert?: socialLinkUpsertWithWhereUniqueWithoutUserInput | socialLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: socialLinkCreateManyUserInputEnvelope
    set?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    disconnect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    delete?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    update?: socialLinkUpdateWithWhereUniqueWithoutUserInput | socialLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: socialLinkUpdateManyWithWhereWithoutUserInput | socialLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: socialLinkScalarWhereInput | socialLinkScalarWhereInput[]
  }

  export type UserSettingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput
    upsert?: UserSettingUpsertWithoutUserInput
    disconnect?: UserSettingWhereInput | boolean
    delete?: UserSettingWhereInput | boolean
    connect?: UserSettingWhereUniqueInput
    update?: XOR<XOR<UserSettingUpdateToOneWithWhereWithoutUserInput, UserSettingUpdateWithoutUserInput>, UserSettingUncheckedUpdateWithoutUserInput>
  }

  export type BadgesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgesCreateWithoutUserInput, BadgesUncheckedCreateWithoutUserInput> | BadgesCreateWithoutUserInput[] | BadgesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgesCreateOrConnectWithoutUserInput | BadgesCreateOrConnectWithoutUserInput[]
    upsert?: BadgesUpsertWithWhereUniqueWithoutUserInput | BadgesUpsertWithWhereUniqueWithoutUserInput[]
    set?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    disconnect?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    delete?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    connect?: BadgesWhereUniqueInput | BadgesWhereUniqueInput[]
    update?: BadgesUpdateWithWhereUniqueWithoutUserInput | BadgesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgesUpdateManyWithWhereWithoutUserInput | BadgesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgesScalarWhereInput | BadgesScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventsCreateWithoutCreatorInput, EventsUncheckedCreateWithoutCreatorInput> | EventsCreateWithoutCreatorInput[] | EventsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutCreatorInput | EventsCreateOrConnectWithoutCreatorInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutCreatorInput | EventsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventsCreateManyCreatorInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutCreatorInput | EventsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutCreatorInput | EventsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type SessionsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SessionsCreateWithoutCreatorInput, SessionsUncheckedCreateWithoutCreatorInput> | SessionsCreateWithoutCreatorInput[] | SessionsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutCreatorInput | SessionsCreateOrConnectWithoutCreatorInput[]
    upsert?: SessionsUpsertWithWhereUniqueWithoutCreatorInput | SessionsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SessionsCreateManyCreatorInputEnvelope
    set?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    disconnect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    delete?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    update?: SessionsUpdateWithWhereUniqueWithoutCreatorInput | SessionsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SessionsUpdateManyWithWhereWithoutCreatorInput | SessionsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
  }

  export type GroupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GroupsCreateWithoutUsersInput, GroupsUncheckedCreateWithoutUsersInput> | GroupsCreateWithoutUsersInput[] | GroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutUsersInput | GroupsCreateOrConnectWithoutUsersInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutUsersInput | GroupsUpsertWithWhereUniqueWithoutUsersInput[]
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutUsersInput | GroupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutUsersInput | GroupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput = {
    create?: XOR<DivisionsCreateWithoutCurrentHeadInput, DivisionsUncheckedCreateWithoutCurrentHeadInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutCurrentHeadInput
    upsert?: DivisionsUpsertWithoutCurrentHeadInput
    disconnect?: DivisionsWhereInput | boolean
    delete?: DivisionsWhereInput | boolean
    connect?: DivisionsWhereUniqueInput
    update?: XOR<XOR<DivisionsUpdateToOneWithWhereWithoutCurrentHeadInput, DivisionsUpdateWithoutCurrentHeadInput>, DivisionsUncheckedUpdateWithoutCurrentHeadInput>
  }

  export type TasksUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TasksCreateWithoutCreatorInput, TasksUncheckedCreateWithoutCreatorInput> | TasksCreateWithoutCreatorInput[] | TasksUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutCreatorInput | TasksCreateOrConnectWithoutCreatorInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutCreatorInput | TasksUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TasksCreateManyCreatorInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutCreatorInput | TasksUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutCreatorInput | TasksUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type TasksUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput> | TasksCreateWithoutAssignedToInput[] | TasksUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput | TasksCreateOrConnectWithoutAssignedToInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutAssignedToInput | TasksUpsertWithWhereUniqueWithoutAssignedToInput[]
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutAssignedToInput | TasksUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutAssignedToInput | TasksUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type EventParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventParticipationCreateWithoutUserInput, EventParticipationUncheckedCreateWithoutUserInput> | EventParticipationCreateWithoutUserInput[] | EventParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutUserInput | EventParticipationCreateOrConnectWithoutUserInput[]
    upsert?: EventParticipationUpsertWithWhereUniqueWithoutUserInput | EventParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventParticipationCreateManyUserInputEnvelope
    set?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    disconnect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    delete?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    update?: EventParticipationUpdateWithWhereUniqueWithoutUserInput | EventParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventParticipationUpdateManyWithWhereWithoutUserInput | EventParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventParticipationScalarWhereInput | EventParticipationScalarWhereInput[]
  }

  export type SessionParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionParticipationCreateWithoutUserInput, SessionParticipationUncheckedCreateWithoutUserInput> | SessionParticipationCreateWithoutUserInput[] | SessionParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutUserInput | SessionParticipationCreateOrConnectWithoutUserInput[]
    upsert?: SessionParticipationUpsertWithWhereUniqueWithoutUserInput | SessionParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionParticipationCreateManyUserInputEnvelope
    set?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    disconnect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    delete?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    update?: SessionParticipationUpdateWithWhereUniqueWithoutUserInput | SessionParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionParticipationUpdateManyWithWhereWithoutUserInput | SessionParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionParticipationScalarWhereInput | SessionParticipationScalarWhereInput[]
  }

  export type TaskParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskParticipationCreateWithoutUserInput, TaskParticipationUncheckedCreateWithoutUserInput> | TaskParticipationCreateWithoutUserInput[] | TaskParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutUserInput | TaskParticipationCreateOrConnectWithoutUserInput[]
    upsert?: TaskParticipationUpsertWithWhereUniqueWithoutUserInput | TaskParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskParticipationCreateManyUserInputEnvelope
    set?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    disconnect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    delete?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    update?: TaskParticipationUpdateWithWhereUniqueWithoutUserInput | TaskParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskParticipationUpdateManyWithWhereWithoutUserInput | TaskParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskParticipationScalarWhereInput | TaskParticipationScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutUserInput, AttendanceSummaryUncheckedCreateWithoutUserInput>
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutUserInput
    upsert?: AttendanceSummaryUpsertWithoutUserInput
    disconnect?: AttendanceSummaryWhereInput | boolean
    delete?: AttendanceSummaryWhereInput | boolean
    connect?: AttendanceSummaryWhereUniqueInput
    update?: XOR<XOR<AttendanceSummaryUpdateToOneWithWhereWithoutUserInput, AttendanceSummaryUpdateWithoutUserInput>, AttendanceSummaryUncheckedUpdateWithoutUserInput>
  }

  export type HeadsUpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HeadsUpCreateWithoutUserInput, HeadsUpUncheckedCreateWithoutUserInput> | HeadsUpCreateWithoutUserInput[] | HeadsUpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HeadsUpCreateOrConnectWithoutUserInput | HeadsUpCreateOrConnectWithoutUserInput[]
    upsert?: HeadsUpUpsertWithWhereUniqueWithoutUserInput | HeadsUpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HeadsUpCreateManyUserInputEnvelope
    set?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    disconnect?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    delete?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    connect?: HeadsUpWhereUniqueInput | HeadsUpWhereUniqueInput[]
    update?: HeadsUpUpdateWithWhereUniqueWithoutUserInput | HeadsUpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HeadsUpUpdateManyWithWhereWithoutUserInput | HeadsUpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HeadsUpScalarWhereInput | HeadsUpScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnouncementCreateWithoutUserInput, AnnouncementUncheckedCreateWithoutUserInput> | AnnouncementCreateWithoutUserInput[] | AnnouncementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutUserInput | AnnouncementCreateOrConnectWithoutUserInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutUserInput | AnnouncementUpsertWithWhereUniqueWithoutUserInput[]
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutUserInput | AnnouncementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutUserInput | AnnouncementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUniversityInfoInput = {
    create?: XOR<UserCreateWithoutUniversityInfoInput, UserUncheckedCreateWithoutUniversityInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutUniversityInfoInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumUniversityStatusFieldUpdateOperationsInput = {
    set?: $Enums.UniversityStatus
  }

  export type UserUpdateOneWithoutUniversityInfoNestedInput = {
    create?: XOR<UserCreateWithoutUniversityInfoInput, UserUncheckedCreateWithoutUniversityInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutUniversityInfoInput
    upsert?: UserUpsertWithoutUniversityInfoInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUniversityInfoInput, UserUpdateWithoutUniversityInfoInput>, UserUncheckedUpdateWithoutUniversityInfoInput>
  }

  export type UserCreateNestedOneWithoutUserSettingInput = {
    create?: XOR<UserCreateWithoutUserSettingInput, UserUncheckedCreateWithoutUserSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingInput
    connect?: UserWhereUniqueInput
  }

  export type EnumThemeFieldUpdateOperationsInput = {
    set?: $Enums.Theme
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutUserSettingNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingInput, UserUncheckedCreateWithoutUserSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingInput
    upsert?: UserUpsertWithoutUserSettingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingInput, UserUpdateWithoutUserSettingInput>, UserUncheckedUpdateWithoutUserSettingInput>
  }

  export type UserCreateNestedOneWithoutDivisionHeadInput = {
    create?: XOR<UserCreateWithoutDivisionHeadInput, UserUncheckedCreateWithoutDivisionHeadInput>
    connectOrCreate?: UserCreateOrConnectWithoutDivisionHeadInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDivisionsInput = {
    create?: XOR<UserCreateWithoutDivisionsInput, UserUncheckedCreateWithoutDivisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDivisionsInput
    connect?: UserWhereUniqueInput
  }

  export type socialLinkCreateNestedManyWithoutDivisionInput = {
    create?: XOR<socialLinkCreateWithoutDivisionInput, socialLinkUncheckedCreateWithoutDivisionInput> | socialLinkCreateWithoutDivisionInput[] | socialLinkUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutDivisionInput | socialLinkCreateOrConnectWithoutDivisionInput[]
    createMany?: socialLinkCreateManyDivisionInputEnvelope
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
  }

  export type SessionsCreateNestedManyWithoutDivisionInput = {
    create?: XOR<SessionsCreateWithoutDivisionInput, SessionsUncheckedCreateWithoutDivisionInput> | SessionsCreateWithoutDivisionInput[] | SessionsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutDivisionInput | SessionsCreateOrConnectWithoutDivisionInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
  }

  export type GroupsCreateNestedManyWithoutDivisionInput = {
    create?: XOR<GroupsCreateWithoutDivisionInput, GroupsUncheckedCreateWithoutDivisionInput> | GroupsCreateWithoutDivisionInput[] | GroupsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutDivisionInput | GroupsCreateOrConnectWithoutDivisionInput[]
    createMany?: GroupsCreateManyDivisionInputEnvelope
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutDivisionsInput = {
    create?: XOR<UserCreateWithoutDivisionsInput, UserUncheckedCreateWithoutDivisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDivisionsInput
    connect?: UserWhereUniqueInput
  }

  export type socialLinkUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<socialLinkCreateWithoutDivisionInput, socialLinkUncheckedCreateWithoutDivisionInput> | socialLinkCreateWithoutDivisionInput[] | socialLinkUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutDivisionInput | socialLinkCreateOrConnectWithoutDivisionInput[]
    createMany?: socialLinkCreateManyDivisionInputEnvelope
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
  }

  export type SessionsUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<SessionsCreateWithoutDivisionInput, SessionsUncheckedCreateWithoutDivisionInput> | SessionsCreateWithoutDivisionInput[] | SessionsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutDivisionInput | SessionsCreateOrConnectWithoutDivisionInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
  }

  export type GroupsUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<GroupsCreateWithoutDivisionInput, GroupsUncheckedCreateWithoutDivisionInput> | GroupsCreateWithoutDivisionInput[] | GroupsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutDivisionInput | GroupsCreateOrConnectWithoutDivisionInput[]
    createMany?: GroupsCreateManyDivisionInputEnvelope
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutDivisionHeadNestedInput = {
    create?: XOR<UserCreateWithoutDivisionHeadInput, UserUncheckedCreateWithoutDivisionHeadInput>
    connectOrCreate?: UserCreateOrConnectWithoutDivisionHeadInput
    upsert?: UserUpsertWithoutDivisionHeadInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDivisionHeadInput, UserUpdateWithoutDivisionHeadInput>, UserUncheckedUpdateWithoutDivisionHeadInput>
  }

  export type UserUpdateOneWithoutDivisionsNestedInput = {
    create?: XOR<UserCreateWithoutDivisionsInput, UserUncheckedCreateWithoutDivisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDivisionsInput
    upsert?: UserUpsertWithoutDivisionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDivisionsInput, UserUpdateWithoutDivisionsInput>, UserUncheckedUpdateWithoutDivisionsInput>
  }

  export type socialLinkUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<socialLinkCreateWithoutDivisionInput, socialLinkUncheckedCreateWithoutDivisionInput> | socialLinkCreateWithoutDivisionInput[] | socialLinkUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutDivisionInput | socialLinkCreateOrConnectWithoutDivisionInput[]
    upsert?: socialLinkUpsertWithWhereUniqueWithoutDivisionInput | socialLinkUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: socialLinkCreateManyDivisionInputEnvelope
    set?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    disconnect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    delete?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    update?: socialLinkUpdateWithWhereUniqueWithoutDivisionInput | socialLinkUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: socialLinkUpdateManyWithWhereWithoutDivisionInput | socialLinkUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: socialLinkScalarWhereInput | socialLinkScalarWhereInput[]
  }

  export type SessionsUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<SessionsCreateWithoutDivisionInput, SessionsUncheckedCreateWithoutDivisionInput> | SessionsCreateWithoutDivisionInput[] | SessionsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutDivisionInput | SessionsCreateOrConnectWithoutDivisionInput[]
    upsert?: SessionsUpsertWithWhereUniqueWithoutDivisionInput | SessionsUpsertWithWhereUniqueWithoutDivisionInput[]
    set?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    disconnect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    delete?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    update?: SessionsUpdateWithWhereUniqueWithoutDivisionInput | SessionsUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: SessionsUpdateManyWithWhereWithoutDivisionInput | SessionsUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
  }

  export type GroupsUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<GroupsCreateWithoutDivisionInput, GroupsUncheckedCreateWithoutDivisionInput> | GroupsCreateWithoutDivisionInput[] | GroupsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutDivisionInput | GroupsCreateOrConnectWithoutDivisionInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutDivisionInput | GroupsUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: GroupsCreateManyDivisionInputEnvelope
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutDivisionInput | GroupsUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutDivisionInput | GroupsUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutDivisionsNestedInput = {
    create?: XOR<UserCreateWithoutDivisionsInput, UserUncheckedCreateWithoutDivisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDivisionsInput
    upsert?: UserUpsertWithoutDivisionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDivisionsInput, UserUpdateWithoutDivisionsInput>, UserUncheckedUpdateWithoutDivisionsInput>
  }

  export type socialLinkUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<socialLinkCreateWithoutDivisionInput, socialLinkUncheckedCreateWithoutDivisionInput> | socialLinkCreateWithoutDivisionInput[] | socialLinkUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: socialLinkCreateOrConnectWithoutDivisionInput | socialLinkCreateOrConnectWithoutDivisionInput[]
    upsert?: socialLinkUpsertWithWhereUniqueWithoutDivisionInput | socialLinkUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: socialLinkCreateManyDivisionInputEnvelope
    set?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    disconnect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    delete?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    connect?: socialLinkWhereUniqueInput | socialLinkWhereUniqueInput[]
    update?: socialLinkUpdateWithWhereUniqueWithoutDivisionInput | socialLinkUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: socialLinkUpdateManyWithWhereWithoutDivisionInput | socialLinkUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: socialLinkScalarWhereInput | socialLinkScalarWhereInput[]
  }

  export type SessionsUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<SessionsCreateWithoutDivisionInput, SessionsUncheckedCreateWithoutDivisionInput> | SessionsCreateWithoutDivisionInput[] | SessionsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutDivisionInput | SessionsCreateOrConnectWithoutDivisionInput[]
    upsert?: SessionsUpsertWithWhereUniqueWithoutDivisionInput | SessionsUpsertWithWhereUniqueWithoutDivisionInput[]
    set?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    disconnect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    delete?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    update?: SessionsUpdateWithWhereUniqueWithoutDivisionInput | SessionsUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: SessionsUpdateManyWithWhereWithoutDivisionInput | SessionsUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
  }

  export type GroupsUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<GroupsCreateWithoutDivisionInput, GroupsUncheckedCreateWithoutDivisionInput> | GroupsCreateWithoutDivisionInput[] | GroupsUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutDivisionInput | GroupsCreateOrConnectWithoutDivisionInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutDivisionInput | GroupsUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: GroupsCreateManyDivisionInputEnvelope
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutDivisionInput | GroupsUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutDivisionInput | GroupsUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DivisionsCreateNestedOneWithoutGroupsInput = {
    create?: XOR<DivisionsCreateWithoutGroupsInput, DivisionsUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutGroupsInput
    connect?: DivisionsWhereUniqueInput
  }

  export type SessionsCreateNestedManyWithoutTargetGroupsInput = {
    create?: XOR<SessionsCreateWithoutTargetGroupsInput, SessionsUncheckedCreateWithoutTargetGroupsInput> | SessionsCreateWithoutTargetGroupsInput[] | SessionsUncheckedCreateWithoutTargetGroupsInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutTargetGroupsInput | SessionsCreateOrConnectWithoutTargetGroupsInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
  }

  export type EventsCreateNestedManyWithoutGroupsInput = {
    create?: XOR<EventsCreateWithoutGroupsInput, EventsUncheckedCreateWithoutGroupsInput> | EventsCreateWithoutGroupsInput[] | EventsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutGroupsInput | EventsCreateOrConnectWithoutGroupsInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SessionsUncheckedCreateNestedManyWithoutTargetGroupsInput = {
    create?: XOR<SessionsCreateWithoutTargetGroupsInput, SessionsUncheckedCreateWithoutTargetGroupsInput> | SessionsCreateWithoutTargetGroupsInput[] | SessionsUncheckedCreateWithoutTargetGroupsInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutTargetGroupsInput | SessionsCreateOrConnectWithoutTargetGroupsInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<EventsCreateWithoutGroupsInput, EventsUncheckedCreateWithoutGroupsInput> | EventsCreateWithoutGroupsInput[] | EventsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutGroupsInput | EventsCreateOrConnectWithoutGroupsInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DivisionsUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<DivisionsCreateWithoutGroupsInput, DivisionsUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutGroupsInput
    upsert?: DivisionsUpsertWithoutGroupsInput
    disconnect?: DivisionsWhereInput | boolean
    delete?: DivisionsWhereInput | boolean
    connect?: DivisionsWhereUniqueInput
    update?: XOR<XOR<DivisionsUpdateToOneWithWhereWithoutGroupsInput, DivisionsUpdateWithoutGroupsInput>, DivisionsUncheckedUpdateWithoutGroupsInput>
  }

  export type SessionsUpdateManyWithoutTargetGroupsNestedInput = {
    create?: XOR<SessionsCreateWithoutTargetGroupsInput, SessionsUncheckedCreateWithoutTargetGroupsInput> | SessionsCreateWithoutTargetGroupsInput[] | SessionsUncheckedCreateWithoutTargetGroupsInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutTargetGroupsInput | SessionsCreateOrConnectWithoutTargetGroupsInput[]
    upsert?: SessionsUpsertWithWhereUniqueWithoutTargetGroupsInput | SessionsUpsertWithWhereUniqueWithoutTargetGroupsInput[]
    set?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    disconnect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    delete?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    update?: SessionsUpdateWithWhereUniqueWithoutTargetGroupsInput | SessionsUpdateWithWhereUniqueWithoutTargetGroupsInput[]
    updateMany?: SessionsUpdateManyWithWhereWithoutTargetGroupsInput | SessionsUpdateManyWithWhereWithoutTargetGroupsInput[]
    deleteMany?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
  }

  export type EventsUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<EventsCreateWithoutGroupsInput, EventsUncheckedCreateWithoutGroupsInput> | EventsCreateWithoutGroupsInput[] | EventsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutGroupsInput | EventsCreateOrConnectWithoutGroupsInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutGroupsInput | EventsUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutGroupsInput | EventsUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutGroupsInput | EventsUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SessionsUncheckedUpdateManyWithoutTargetGroupsNestedInput = {
    create?: XOR<SessionsCreateWithoutTargetGroupsInput, SessionsUncheckedCreateWithoutTargetGroupsInput> | SessionsCreateWithoutTargetGroupsInput[] | SessionsUncheckedCreateWithoutTargetGroupsInput[]
    connectOrCreate?: SessionsCreateOrConnectWithoutTargetGroupsInput | SessionsCreateOrConnectWithoutTargetGroupsInput[]
    upsert?: SessionsUpsertWithWhereUniqueWithoutTargetGroupsInput | SessionsUpsertWithWhereUniqueWithoutTargetGroupsInput[]
    set?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    disconnect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    delete?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    connect?: SessionsWhereUniqueInput | SessionsWhereUniqueInput[]
    update?: SessionsUpdateWithWhereUniqueWithoutTargetGroupsInput | SessionsUpdateWithWhereUniqueWithoutTargetGroupsInput[]
    updateMany?: SessionsUpdateManyWithWhereWithoutTargetGroupsInput | SessionsUpdateManyWithWhereWithoutTargetGroupsInput[]
    deleteMany?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<EventsCreateWithoutGroupsInput, EventsUncheckedCreateWithoutGroupsInput> | EventsCreateWithoutGroupsInput[] | EventsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutGroupsInput | EventsCreateOrConnectWithoutGroupsInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutGroupsInput | EventsUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutGroupsInput | EventsUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutGroupsInput | EventsUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSocialLinksInput = {
    create?: XOR<UserCreateWithoutSocialLinksInput, UserUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialLinksInput
    connect?: UserWhereUniqueInput
  }

  export type DivisionsCreateNestedOneWithoutSocialLinksInput = {
    create?: XOR<DivisionsCreateWithoutSocialLinksInput, DivisionsUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutSocialLinksInput
    connect?: DivisionsWhereUniqueInput
  }

  export type UserUpdateOneWithoutSocialLinksNestedInput = {
    create?: XOR<UserCreateWithoutSocialLinksInput, UserUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialLinksInput
    upsert?: UserUpsertWithoutSocialLinksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialLinksInput, UserUpdateWithoutSocialLinksInput>, UserUncheckedUpdateWithoutSocialLinksInput>
  }

  export type DivisionsUpdateOneWithoutSocialLinksNestedInput = {
    create?: XOR<DivisionsCreateWithoutSocialLinksInput, DivisionsUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: DivisionsCreateOrConnectWithoutSocialLinksInput
    upsert?: DivisionsUpsertWithoutSocialLinksInput
    disconnect?: DivisionsWhereInput | boolean
    delete?: DivisionsWhereInput | boolean
    connect?: DivisionsWhereUniqueInput
    update?: XOR<XOR<DivisionsUpdateToOneWithWhereWithoutSocialLinksInput, DivisionsUpdateWithoutSocialLinksInput>, DivisionsUncheckedUpdateWithoutSocialLinksInput>
  }

  export type EventsCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<EventsCreateWithoutTimeSlotsInput, EventsUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: EventsCreateOrConnectWithoutTimeSlotsInput
    connect?: EventsWhereUniqueInput
  }

  export type EventsUpdateOneWithoutTimeSlotsNestedInput = {
    create?: XOR<EventsCreateWithoutTimeSlotsInput, EventsUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: EventsCreateOrConnectWithoutTimeSlotsInput
    upsert?: EventsUpsertWithoutTimeSlotsInput
    disconnect?: EventsWhereInput | boolean
    delete?: EventsWhereInput | boolean
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutTimeSlotsInput, EventsUpdateWithoutTimeSlotsInput>, EventsUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type SessionsCreateNestedOneWithoutTimeSlotInput = {
    create?: XOR<SessionsCreateWithoutTimeSlotInput, SessionsUncheckedCreateWithoutTimeSlotInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutTimeSlotInput
    connect?: SessionsWhereUniqueInput
  }

  export type SessionsUpdateOneWithoutTimeSlotNestedInput = {
    create?: XOR<SessionsCreateWithoutTimeSlotInput, SessionsUncheckedCreateWithoutTimeSlotInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutTimeSlotInput
    upsert?: SessionsUpsertWithoutTimeSlotInput
    disconnect?: SessionsWhereInput | boolean
    delete?: SessionsWhereInput | boolean
    connect?: SessionsWhereUniqueInput
    update?: XOR<XOR<SessionsUpdateToOneWithWhereWithoutTimeSlotInput, SessionsUpdateWithoutTimeSlotInput>, SessionsUncheckedUpdateWithoutTimeSlotInput>
  }

  export type EventsCreatetagsInput = {
    set: $Enums.Tag[]
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EventTimeSlotCreateNestedManyWithoutEventInput = {
    create?: XOR<EventTimeSlotCreateWithoutEventInput, EventTimeSlotUncheckedCreateWithoutEventInput> | EventTimeSlotCreateWithoutEventInput[] | EventTimeSlotUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTimeSlotCreateOrConnectWithoutEventInput | EventTimeSlotCreateOrConnectWithoutEventInput[]
    createMany?: EventTimeSlotCreateManyEventInputEnvelope
    connect?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
  }

  export type GroupsCreateNestedManyWithoutEventsInput = {
    create?: XOR<GroupsCreateWithoutEventsInput, GroupsUncheckedCreateWithoutEventsInput> | GroupsCreateWithoutEventsInput[] | GroupsUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutEventsInput | GroupsCreateOrConnectWithoutEventsInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type TasksCreateNestedManyWithoutEventInput = {
    create?: XOR<TasksCreateWithoutEventInput, TasksUncheckedCreateWithoutEventInput> | TasksCreateWithoutEventInput[] | TasksUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutEventInput | TasksCreateOrConnectWithoutEventInput[]
    createMany?: TasksCreateManyEventInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type EventParticipationCreateNestedManyWithoutEventInput = {
    create?: XOR<EventParticipationCreateWithoutEventInput, EventParticipationUncheckedCreateWithoutEventInput> | EventParticipationCreateWithoutEventInput[] | EventParticipationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutEventInput | EventParticipationCreateOrConnectWithoutEventInput[]
    createMany?: EventParticipationCreateManyEventInputEnvelope
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutEventInput = {
    create?: XOR<AttendanceCreateWithoutEventInput, AttendanceUncheckedCreateWithoutEventInput> | AttendanceCreateWithoutEventInput[] | AttendanceUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEventInput | AttendanceCreateOrConnectWithoutEventInput[]
    createMany?: AttendanceCreateManyEventInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EventTimeSlotUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventTimeSlotCreateWithoutEventInput, EventTimeSlotUncheckedCreateWithoutEventInput> | EventTimeSlotCreateWithoutEventInput[] | EventTimeSlotUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTimeSlotCreateOrConnectWithoutEventInput | EventTimeSlotCreateOrConnectWithoutEventInput[]
    createMany?: EventTimeSlotCreateManyEventInputEnvelope
    connect?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
  }

  export type GroupsUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<GroupsCreateWithoutEventsInput, GroupsUncheckedCreateWithoutEventsInput> | GroupsCreateWithoutEventsInput[] | GroupsUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutEventsInput | GroupsCreateOrConnectWithoutEventsInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type TasksUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<TasksCreateWithoutEventInput, TasksUncheckedCreateWithoutEventInput> | TasksCreateWithoutEventInput[] | TasksUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutEventInput | TasksCreateOrConnectWithoutEventInput[]
    createMany?: TasksCreateManyEventInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type EventParticipationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventParticipationCreateWithoutEventInput, EventParticipationUncheckedCreateWithoutEventInput> | EventParticipationCreateWithoutEventInput[] | EventParticipationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutEventInput | EventParticipationCreateOrConnectWithoutEventInput[]
    createMany?: EventParticipationCreateManyEventInputEnvelope
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<AttendanceCreateWithoutEventInput, AttendanceUncheckedCreateWithoutEventInput> | AttendanceCreateWithoutEventInput[] | AttendanceUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEventInput | AttendanceCreateOrConnectWithoutEventInput[]
    createMany?: AttendanceCreateManyEventInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EventsUpdatetagsInput = {
    set?: $Enums.Tag[]
    push?: $Enums.Tag | $Enums.Tag[]
  }

  export type EnumEventVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.EventVisibility
  }

  export type EnumstateFieldUpdateOperationsInput = {
    set?: $Enums.state
  }

  export type UserUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type EventTimeSlotUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventTimeSlotCreateWithoutEventInput, EventTimeSlotUncheckedCreateWithoutEventInput> | EventTimeSlotCreateWithoutEventInput[] | EventTimeSlotUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTimeSlotCreateOrConnectWithoutEventInput | EventTimeSlotCreateOrConnectWithoutEventInput[]
    upsert?: EventTimeSlotUpsertWithWhereUniqueWithoutEventInput | EventTimeSlotUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventTimeSlotCreateManyEventInputEnvelope
    set?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    disconnect?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    delete?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    connect?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    update?: EventTimeSlotUpdateWithWhereUniqueWithoutEventInput | EventTimeSlotUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventTimeSlotUpdateManyWithWhereWithoutEventInput | EventTimeSlotUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventTimeSlotScalarWhereInput | EventTimeSlotScalarWhereInput[]
  }

  export type GroupsUpdateManyWithoutEventsNestedInput = {
    create?: XOR<GroupsCreateWithoutEventsInput, GroupsUncheckedCreateWithoutEventsInput> | GroupsCreateWithoutEventsInput[] | GroupsUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutEventsInput | GroupsCreateOrConnectWithoutEventsInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutEventsInput | GroupsUpsertWithWhereUniqueWithoutEventsInput[]
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutEventsInput | GroupsUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutEventsInput | GroupsUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type TasksUpdateManyWithoutEventNestedInput = {
    create?: XOR<TasksCreateWithoutEventInput, TasksUncheckedCreateWithoutEventInput> | TasksCreateWithoutEventInput[] | TasksUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutEventInput | TasksCreateOrConnectWithoutEventInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutEventInput | TasksUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TasksCreateManyEventInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutEventInput | TasksUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutEventInput | TasksUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type EventParticipationUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventParticipationCreateWithoutEventInput, EventParticipationUncheckedCreateWithoutEventInput> | EventParticipationCreateWithoutEventInput[] | EventParticipationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutEventInput | EventParticipationCreateOrConnectWithoutEventInput[]
    upsert?: EventParticipationUpsertWithWhereUniqueWithoutEventInput | EventParticipationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventParticipationCreateManyEventInputEnvelope
    set?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    disconnect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    delete?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    update?: EventParticipationUpdateWithWhereUniqueWithoutEventInput | EventParticipationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventParticipationUpdateManyWithWhereWithoutEventInput | EventParticipationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventParticipationScalarWhereInput | EventParticipationScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutEventNestedInput = {
    create?: XOR<AttendanceCreateWithoutEventInput, AttendanceUncheckedCreateWithoutEventInput> | AttendanceCreateWithoutEventInput[] | AttendanceUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEventInput | AttendanceCreateOrConnectWithoutEventInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEventInput | AttendanceUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AttendanceCreateManyEventInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEventInput | AttendanceUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEventInput | AttendanceUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventTimeSlotCreateWithoutEventInput, EventTimeSlotUncheckedCreateWithoutEventInput> | EventTimeSlotCreateWithoutEventInput[] | EventTimeSlotUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTimeSlotCreateOrConnectWithoutEventInput | EventTimeSlotCreateOrConnectWithoutEventInput[]
    upsert?: EventTimeSlotUpsertWithWhereUniqueWithoutEventInput | EventTimeSlotUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventTimeSlotCreateManyEventInputEnvelope
    set?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    disconnect?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    delete?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    connect?: EventTimeSlotWhereUniqueInput | EventTimeSlotWhereUniqueInput[]
    update?: EventTimeSlotUpdateWithWhereUniqueWithoutEventInput | EventTimeSlotUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventTimeSlotUpdateManyWithWhereWithoutEventInput | EventTimeSlotUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventTimeSlotScalarWhereInput | EventTimeSlotScalarWhereInput[]
  }

  export type GroupsUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<GroupsCreateWithoutEventsInput, GroupsUncheckedCreateWithoutEventsInput> | GroupsCreateWithoutEventsInput[] | GroupsUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutEventsInput | GroupsCreateOrConnectWithoutEventsInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutEventsInput | GroupsUpsertWithWhereUniqueWithoutEventsInput[]
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutEventsInput | GroupsUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutEventsInput | GroupsUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type TasksUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<TasksCreateWithoutEventInput, TasksUncheckedCreateWithoutEventInput> | TasksCreateWithoutEventInput[] | TasksUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutEventInput | TasksCreateOrConnectWithoutEventInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutEventInput | TasksUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TasksCreateManyEventInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutEventInput | TasksUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutEventInput | TasksUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type EventParticipationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventParticipationCreateWithoutEventInput, EventParticipationUncheckedCreateWithoutEventInput> | EventParticipationCreateWithoutEventInput[] | EventParticipationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventParticipationCreateOrConnectWithoutEventInput | EventParticipationCreateOrConnectWithoutEventInput[]
    upsert?: EventParticipationUpsertWithWhereUniqueWithoutEventInput | EventParticipationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventParticipationCreateManyEventInputEnvelope
    set?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    disconnect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    delete?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    connect?: EventParticipationWhereUniqueInput | EventParticipationWhereUniqueInput[]
    update?: EventParticipationUpdateWithWhereUniqueWithoutEventInput | EventParticipationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventParticipationUpdateManyWithWhereWithoutEventInput | EventParticipationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventParticipationScalarWhereInput | EventParticipationScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<AttendanceCreateWithoutEventInput, AttendanceUncheckedCreateWithoutEventInput> | AttendanceCreateWithoutEventInput[] | AttendanceUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEventInput | AttendanceCreateOrConnectWithoutEventInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEventInput | AttendanceUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AttendanceCreateManyEventInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEventInput | AttendanceUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEventInput | AttendanceUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type SessionsCreatetagsInput = {
    set: $Enums.Tag[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DivisionsCreateNestedManyWithoutSessionsInput = {
    create?: XOR<DivisionsCreateWithoutSessionsInput, DivisionsUncheckedCreateWithoutSessionsInput> | DivisionsCreateWithoutSessionsInput[] | DivisionsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: DivisionsCreateOrConnectWithoutSessionsInput | DivisionsCreateOrConnectWithoutSessionsInput[]
    connect?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
  }

  export type SessionTimeSlotCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTimeSlotCreateWithoutSessionInput, SessionTimeSlotUncheckedCreateWithoutSessionInput> | SessionTimeSlotCreateWithoutSessionInput[] | SessionTimeSlotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTimeSlotCreateOrConnectWithoutSessionInput | SessionTimeSlotCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTimeSlotCreateManySessionInputEnvelope
    connect?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
  }

  export type GroupsCreateNestedManyWithoutSessionsInput = {
    create?: XOR<GroupsCreateWithoutSessionsInput, GroupsUncheckedCreateWithoutSessionsInput> | GroupsCreateWithoutSessionsInput[] | GroupsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutSessionsInput | GroupsCreateOrConnectWithoutSessionsInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type TasksCreateNestedManyWithoutSessionInput = {
    create?: XOR<TasksCreateWithoutSessionInput, TasksUncheckedCreateWithoutSessionInput> | TasksCreateWithoutSessionInput[] | TasksUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutSessionInput | TasksCreateOrConnectWithoutSessionInput[]
    createMany?: TasksCreateManySessionInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type SessionParticipationCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionParticipationCreateWithoutSessionInput, SessionParticipationUncheckedCreateWithoutSessionInput> | SessionParticipationCreateWithoutSessionInput[] | SessionParticipationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutSessionInput | SessionParticipationCreateOrConnectWithoutSessionInput[]
    createMany?: SessionParticipationCreateManySessionInputEnvelope
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type DivisionsUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<DivisionsCreateWithoutSessionsInput, DivisionsUncheckedCreateWithoutSessionsInput> | DivisionsCreateWithoutSessionsInput[] | DivisionsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: DivisionsCreateOrConnectWithoutSessionsInput | DivisionsCreateOrConnectWithoutSessionsInput[]
    connect?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
  }

  export type SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTimeSlotCreateWithoutSessionInput, SessionTimeSlotUncheckedCreateWithoutSessionInput> | SessionTimeSlotCreateWithoutSessionInput[] | SessionTimeSlotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTimeSlotCreateOrConnectWithoutSessionInput | SessionTimeSlotCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTimeSlotCreateManySessionInputEnvelope
    connect?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
  }

  export type GroupsUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<GroupsCreateWithoutSessionsInput, GroupsUncheckedCreateWithoutSessionsInput> | GroupsCreateWithoutSessionsInput[] | GroupsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutSessionsInput | GroupsCreateOrConnectWithoutSessionsInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type TasksUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TasksCreateWithoutSessionInput, TasksUncheckedCreateWithoutSessionInput> | TasksCreateWithoutSessionInput[] | TasksUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutSessionInput | TasksCreateOrConnectWithoutSessionInput[]
    createMany?: TasksCreateManySessionInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type SessionParticipationUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionParticipationCreateWithoutSessionInput, SessionParticipationUncheckedCreateWithoutSessionInput> | SessionParticipationCreateWithoutSessionInput[] | SessionParticipationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutSessionInput | SessionParticipationCreateOrConnectWithoutSessionInput[]
    createMany?: SessionParticipationCreateManySessionInputEnvelope
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type SessionsUpdatetagsInput = {
    set?: $Enums.Tag[]
    push?: $Enums.Tag | $Enums.Tag[]
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type DivisionsUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<DivisionsCreateWithoutSessionsInput, DivisionsUncheckedCreateWithoutSessionsInput> | DivisionsCreateWithoutSessionsInput[] | DivisionsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: DivisionsCreateOrConnectWithoutSessionsInput | DivisionsCreateOrConnectWithoutSessionsInput[]
    upsert?: DivisionsUpsertWithWhereUniqueWithoutSessionsInput | DivisionsUpsertWithWhereUniqueWithoutSessionsInput[]
    set?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    disconnect?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    delete?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    connect?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    update?: DivisionsUpdateWithWhereUniqueWithoutSessionsInput | DivisionsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: DivisionsUpdateManyWithWhereWithoutSessionsInput | DivisionsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: DivisionsScalarWhereInput | DivisionsScalarWhereInput[]
  }

  export type SessionTimeSlotUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTimeSlotCreateWithoutSessionInput, SessionTimeSlotUncheckedCreateWithoutSessionInput> | SessionTimeSlotCreateWithoutSessionInput[] | SessionTimeSlotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTimeSlotCreateOrConnectWithoutSessionInput | SessionTimeSlotCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTimeSlotUpsertWithWhereUniqueWithoutSessionInput | SessionTimeSlotUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTimeSlotCreateManySessionInputEnvelope
    set?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    disconnect?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    delete?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    connect?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    update?: SessionTimeSlotUpdateWithWhereUniqueWithoutSessionInput | SessionTimeSlotUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTimeSlotUpdateManyWithWhereWithoutSessionInput | SessionTimeSlotUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTimeSlotScalarWhereInput | SessionTimeSlotScalarWhereInput[]
  }

  export type GroupsUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<GroupsCreateWithoutSessionsInput, GroupsUncheckedCreateWithoutSessionsInput> | GroupsCreateWithoutSessionsInput[] | GroupsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutSessionsInput | GroupsCreateOrConnectWithoutSessionsInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutSessionsInput | GroupsUpsertWithWhereUniqueWithoutSessionsInput[]
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutSessionsInput | GroupsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutSessionsInput | GroupsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type TasksUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TasksCreateWithoutSessionInput, TasksUncheckedCreateWithoutSessionInput> | TasksCreateWithoutSessionInput[] | TasksUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutSessionInput | TasksCreateOrConnectWithoutSessionInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutSessionInput | TasksUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TasksCreateManySessionInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutSessionInput | TasksUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutSessionInput | TasksUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type SessionParticipationUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionParticipationCreateWithoutSessionInput, SessionParticipationUncheckedCreateWithoutSessionInput> | SessionParticipationCreateWithoutSessionInput[] | SessionParticipationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutSessionInput | SessionParticipationCreateOrConnectWithoutSessionInput[]
    upsert?: SessionParticipationUpsertWithWhereUniqueWithoutSessionInput | SessionParticipationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionParticipationCreateManySessionInputEnvelope
    set?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    disconnect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    delete?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    update?: SessionParticipationUpdateWithWhereUniqueWithoutSessionInput | SessionParticipationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionParticipationUpdateManyWithWhereWithoutSessionInput | SessionParticipationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionParticipationScalarWhereInput | SessionParticipationScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type DivisionsUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<DivisionsCreateWithoutSessionsInput, DivisionsUncheckedCreateWithoutSessionsInput> | DivisionsCreateWithoutSessionsInput[] | DivisionsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: DivisionsCreateOrConnectWithoutSessionsInput | DivisionsCreateOrConnectWithoutSessionsInput[]
    upsert?: DivisionsUpsertWithWhereUniqueWithoutSessionsInput | DivisionsUpsertWithWhereUniqueWithoutSessionsInput[]
    set?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    disconnect?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    delete?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    connect?: DivisionsWhereUniqueInput | DivisionsWhereUniqueInput[]
    update?: DivisionsUpdateWithWhereUniqueWithoutSessionsInput | DivisionsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: DivisionsUpdateManyWithWhereWithoutSessionsInput | DivisionsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: DivisionsScalarWhereInput | DivisionsScalarWhereInput[]
  }

  export type SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTimeSlotCreateWithoutSessionInput, SessionTimeSlotUncheckedCreateWithoutSessionInput> | SessionTimeSlotCreateWithoutSessionInput[] | SessionTimeSlotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTimeSlotCreateOrConnectWithoutSessionInput | SessionTimeSlotCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTimeSlotUpsertWithWhereUniqueWithoutSessionInput | SessionTimeSlotUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTimeSlotCreateManySessionInputEnvelope
    set?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    disconnect?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    delete?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    connect?: SessionTimeSlotWhereUniqueInput | SessionTimeSlotWhereUniqueInput[]
    update?: SessionTimeSlotUpdateWithWhereUniqueWithoutSessionInput | SessionTimeSlotUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTimeSlotUpdateManyWithWhereWithoutSessionInput | SessionTimeSlotUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTimeSlotScalarWhereInput | SessionTimeSlotScalarWhereInput[]
  }

  export type GroupsUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<GroupsCreateWithoutSessionsInput, GroupsUncheckedCreateWithoutSessionsInput> | GroupsCreateWithoutSessionsInput[] | GroupsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutSessionsInput | GroupsCreateOrConnectWithoutSessionsInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutSessionsInput | GroupsUpsertWithWhereUniqueWithoutSessionsInput[]
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutSessionsInput | GroupsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutSessionsInput | GroupsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type TasksUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TasksCreateWithoutSessionInput, TasksUncheckedCreateWithoutSessionInput> | TasksCreateWithoutSessionInput[] | TasksUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutSessionInput | TasksCreateOrConnectWithoutSessionInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutSessionInput | TasksUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TasksCreateManySessionInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutSessionInput | TasksUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutSessionInput | TasksUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionParticipationCreateWithoutSessionInput, SessionParticipationUncheckedCreateWithoutSessionInput> | SessionParticipationCreateWithoutSessionInput[] | SessionParticipationUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipationCreateOrConnectWithoutSessionInput | SessionParticipationCreateOrConnectWithoutSessionInput[]
    upsert?: SessionParticipationUpsertWithWhereUniqueWithoutSessionInput | SessionParticipationUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionParticipationCreateManySessionInputEnvelope
    set?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    disconnect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    delete?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    connect?: SessionParticipationWhereUniqueInput | SessionParticipationWhereUniqueInput[]
    update?: SessionParticipationUpdateWithWhereUniqueWithoutSessionInput | SessionParticipationUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionParticipationUpdateManyWithWhereWithoutSessionInput | SessionParticipationUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionParticipationScalarWhereInput | SessionParticipationScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EventsCreateNestedOneWithoutTasksInput = {
    create?: XOR<EventsCreateWithoutTasksInput, EventsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: EventsCreateOrConnectWithoutTasksInput
    connect?: EventsWhereUniqueInput
  }

  export type SessionsCreateNestedOneWithoutTasksInput = {
    create?: XOR<SessionsCreateWithoutTasksInput, SessionsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutTasksInput
    connect?: SessionsWhereUniqueInput
  }

  export type TaskParticipationCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskParticipationCreateWithoutTaskInput, TaskParticipationUncheckedCreateWithoutTaskInput> | TaskParticipationCreateWithoutTaskInput[] | TaskParticipationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutTaskInput | TaskParticipationCreateOrConnectWithoutTaskInput[]
    createMany?: TaskParticipationCreateManyTaskInputEnvelope
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskParticipationUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskParticipationCreateWithoutTaskInput, TaskParticipationUncheckedCreateWithoutTaskInput> | TaskParticipationCreateWithoutTaskInput[] | TaskParticipationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutTaskInput | TaskParticipationCreateOrConnectWithoutTaskInput[]
    createMany?: TaskParticipationCreateManyTaskInputEnvelope
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type UserUpdateOneRequiredWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateManyWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedTasksInput | UserUpsertWithWhereUniqueWithoutAssignedTasksInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedTasksInput | UserUpdateWithWhereUniqueWithoutAssignedTasksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedTasksInput | UserUpdateManyWithWhereWithoutAssignedTasksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type EventsUpdateOneWithoutTasksNestedInput = {
    create?: XOR<EventsCreateWithoutTasksInput, EventsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: EventsCreateOrConnectWithoutTasksInput
    upsert?: EventsUpsertWithoutTasksInput
    disconnect?: EventsWhereInput | boolean
    delete?: EventsWhereInput | boolean
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutTasksInput, EventsUpdateWithoutTasksInput>, EventsUncheckedUpdateWithoutTasksInput>
  }

  export type SessionsUpdateOneWithoutTasksNestedInput = {
    create?: XOR<SessionsCreateWithoutTasksInput, SessionsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutTasksInput
    upsert?: SessionsUpsertWithoutTasksInput
    disconnect?: SessionsWhereInput | boolean
    delete?: SessionsWhereInput | boolean
    connect?: SessionsWhereUniqueInput
    update?: XOR<XOR<SessionsUpdateToOneWithWhereWithoutTasksInput, SessionsUpdateWithoutTasksInput>, SessionsUncheckedUpdateWithoutTasksInput>
  }

  export type TaskParticipationUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskParticipationCreateWithoutTaskInput, TaskParticipationUncheckedCreateWithoutTaskInput> | TaskParticipationCreateWithoutTaskInput[] | TaskParticipationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutTaskInput | TaskParticipationCreateOrConnectWithoutTaskInput[]
    upsert?: TaskParticipationUpsertWithWhereUniqueWithoutTaskInput | TaskParticipationUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskParticipationCreateManyTaskInputEnvelope
    set?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    disconnect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    delete?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    update?: TaskParticipationUpdateWithWhereUniqueWithoutTaskInput | TaskParticipationUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskParticipationUpdateManyWithWhereWithoutTaskInput | TaskParticipationUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskParticipationScalarWhereInput | TaskParticipationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedTasksInput | UserUpsertWithWhereUniqueWithoutAssignedTasksInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedTasksInput | UserUpdateWithWhereUniqueWithoutAssignedTasksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedTasksInput | UserUpdateManyWithWhereWithoutAssignedTasksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskParticipationUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskParticipationCreateWithoutTaskInput, TaskParticipationUncheckedCreateWithoutTaskInput> | TaskParticipationCreateWithoutTaskInput[] | TaskParticipationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskParticipationCreateOrConnectWithoutTaskInput | TaskParticipationCreateOrConnectWithoutTaskInput[]
    upsert?: TaskParticipationUpsertWithWhereUniqueWithoutTaskInput | TaskParticipationUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskParticipationCreateManyTaskInputEnvelope
    set?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    disconnect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    delete?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    connect?: TaskParticipationWhereUniqueInput | TaskParticipationWhereUniqueInput[]
    update?: TaskParticipationUpdateWithWhereUniqueWithoutTaskInput | TaskParticipationUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskParticipationUpdateManyWithWhereWithoutTaskInput | TaskParticipationUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskParticipationScalarWhereInput | TaskParticipationScalarWhereInput[]
  }

  export type EventsCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<EventsCreateWithoutParticipantsInput, EventsUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EventsCreateOrConnectWithoutParticipantsInput
    connect?: EventsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventParticipationInput = {
    create?: XOR<UserCreateWithoutEventParticipationInput, UserUncheckedCreateWithoutEventParticipationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventParticipationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEventRoleFieldUpdateOperationsInput = {
    set?: $Enums.EventRole
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventsUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<EventsCreateWithoutParticipantsInput, EventsUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EventsCreateOrConnectWithoutParticipantsInput
    upsert?: EventsUpsertWithoutParticipantsInput
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutParticipantsInput, EventsUpdateWithoutParticipantsInput>, EventsUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutEventParticipationNestedInput = {
    create?: XOR<UserCreateWithoutEventParticipationInput, UserUncheckedCreateWithoutEventParticipationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventParticipationInput
    upsert?: UserUpsertWithoutEventParticipationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventParticipationInput, UserUpdateWithoutEventParticipationInput>, UserUncheckedUpdateWithoutEventParticipationInput>
  }

  export type SessionsCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<SessionsCreateWithoutParticipantsInput, SessionsUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutParticipantsInput
    connect?: SessionsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionParticipationInput = {
    create?: XOR<UserCreateWithoutSessionParticipationInput, UserUncheckedCreateWithoutSessionParticipationInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionParticipationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSessionRoleFieldUpdateOperationsInput = {
    set?: $Enums.SessionRole
  }

  export type SessionsUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<SessionsCreateWithoutParticipantsInput, SessionsUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutParticipantsInput
    upsert?: SessionsUpsertWithoutParticipantsInput
    connect?: SessionsWhereUniqueInput
    update?: XOR<XOR<SessionsUpdateToOneWithWhereWithoutParticipantsInput, SessionsUpdateWithoutParticipantsInput>, SessionsUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionParticipationNestedInput = {
    create?: XOR<UserCreateWithoutSessionParticipationInput, UserUncheckedCreateWithoutSessionParticipationInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionParticipationInput
    upsert?: UserUpsertWithoutSessionParticipationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionParticipationInput, UserUpdateWithoutSessionParticipationInput>, UserUncheckedUpdateWithoutSessionParticipationInput>
  }

  export type TasksCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TasksCreateWithoutParticipantsInput, TasksUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutParticipantsInput
    connect?: TasksWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskParticipationInput = {
    create?: XOR<UserCreateWithoutTaskParticipationInput, UserUncheckedCreateWithoutTaskParticipationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskParticipationInput
    connect?: UserWhereUniqueInput
  }

  export type TasksUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TasksCreateWithoutParticipantsInput, TasksUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TasksCreateOrConnectWithoutParticipantsInput
    upsert?: TasksUpsertWithoutParticipantsInput
    connect?: TasksWhereUniqueInput
    update?: XOR<XOR<TasksUpdateToOneWithWhereWithoutParticipantsInput, TasksUpdateWithoutParticipantsInput>, TasksUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskParticipationNestedInput = {
    create?: XOR<UserCreateWithoutTaskParticipationInput, UserUncheckedCreateWithoutTaskParticipationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskParticipationInput
    upsert?: UserUpsertWithoutTaskParticipationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskParticipationInput, UserUpdateWithoutTaskParticipationInput>, UserUncheckedUpdateWithoutTaskParticipationInput>
  }

  export type UserCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type SessionsCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<SessionsCreateWithoutAttendanceInput, SessionsUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutAttendanceInput
    connect?: SessionsWhereUniqueInput
  }

  export type EventsCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<EventsCreateWithoutAttendanceInput, EventsUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EventsCreateOrConnectWithoutAttendanceInput
    connect?: EventsWhereUniqueInput
  }

  export type HeadsUpCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<HeadsUpCreateWithoutAttendanceInput, HeadsUpUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: HeadsUpCreateOrConnectWithoutAttendanceInput
    connect?: HeadsUpWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    upsert?: UserUpsertWithoutAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceInput, UserUpdateWithoutAttendanceInput>, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type SessionsUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<SessionsCreateWithoutAttendanceInput, SessionsUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: SessionsCreateOrConnectWithoutAttendanceInput
    upsert?: SessionsUpsertWithoutAttendanceInput
    disconnect?: SessionsWhereInput | boolean
    delete?: SessionsWhereInput | boolean
    connect?: SessionsWhereUniqueInput
    update?: XOR<XOR<SessionsUpdateToOneWithWhereWithoutAttendanceInput, SessionsUpdateWithoutAttendanceInput>, SessionsUncheckedUpdateWithoutAttendanceInput>
  }

  export type EventsUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<EventsCreateWithoutAttendanceInput, EventsUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EventsCreateOrConnectWithoutAttendanceInput
    upsert?: EventsUpsertWithoutAttendanceInput
    disconnect?: EventsWhereInput | boolean
    delete?: EventsWhereInput | boolean
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutAttendanceInput, EventsUpdateWithoutAttendanceInput>, EventsUncheckedUpdateWithoutAttendanceInput>
  }

  export type HeadsUpUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<HeadsUpCreateWithoutAttendanceInput, HeadsUpUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: HeadsUpCreateOrConnectWithoutAttendanceInput
    upsert?: HeadsUpUpsertWithoutAttendanceInput
    disconnect?: HeadsUpWhereInput | boolean
    delete?: HeadsUpWhereInput | boolean
    connect?: HeadsUpWhereUniqueInput
    update?: XOR<XOR<HeadsUpUpdateToOneWithWhereWithoutAttendanceInput, HeadsUpUpdateWithoutAttendanceInput>, HeadsUpUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserCreateNestedOneWithoutAttendanceSummaryInput = {
    create?: XOR<UserCreateWithoutAttendanceSummaryInput, UserUncheckedCreateWithoutAttendanceSummaryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceSummaryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendanceSummaryNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceSummaryInput, UserUncheckedCreateWithoutAttendanceSummaryInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceSummaryInput
    upsert?: UserUpsertWithoutAttendanceSummaryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceSummaryInput, UserUpdateWithoutAttendanceSummaryInput>, UserUncheckedUpdateWithoutAttendanceSummaryInput>
  }

  export type UserCreateNestedOneWithoutHeadsUpInput = {
    create?: XOR<UserCreateWithoutHeadsUpInput, UserUncheckedCreateWithoutHeadsUpInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadsUpInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceCreateNestedOneWithoutHeadsUpInput = {
    create?: XOR<AttendanceCreateWithoutHeadsUpInput, AttendanceUncheckedCreateWithoutHeadsUpInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutHeadsUpInput
    connect?: AttendanceWhereUniqueInput
  }

  export type AttendanceUncheckedCreateNestedOneWithoutHeadsUpInput = {
    create?: XOR<AttendanceCreateWithoutHeadsUpInput, AttendanceUncheckedCreateWithoutHeadsUpInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutHeadsUpInput
    connect?: AttendanceWhereUniqueInput
  }

  export type EnumHeadsUpTypeFieldUpdateOperationsInput = {
    set?: $Enums.HeadsUpType
  }

  export type UserUpdateOneRequiredWithoutHeadsUpNestedInput = {
    create?: XOR<UserCreateWithoutHeadsUpInput, UserUncheckedCreateWithoutHeadsUpInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadsUpInput
    upsert?: UserUpsertWithoutHeadsUpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHeadsUpInput, UserUpdateWithoutHeadsUpInput>, UserUncheckedUpdateWithoutHeadsUpInput>
  }

  export type AttendanceUpdateOneWithoutHeadsUpNestedInput = {
    create?: XOR<AttendanceCreateWithoutHeadsUpInput, AttendanceUncheckedCreateWithoutHeadsUpInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutHeadsUpInput
    upsert?: AttendanceUpsertWithoutHeadsUpInput
    disconnect?: AttendanceWhereInput | boolean
    delete?: AttendanceWhereInput | boolean
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutHeadsUpInput, AttendanceUpdateWithoutHeadsUpInput>, AttendanceUncheckedUpdateWithoutHeadsUpInput>
  }

  export type AttendanceUncheckedUpdateOneWithoutHeadsUpNestedInput = {
    create?: XOR<AttendanceCreateWithoutHeadsUpInput, AttendanceUncheckedCreateWithoutHeadsUpInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutHeadsUpInput
    upsert?: AttendanceUpsertWithoutHeadsUpInput
    disconnect?: AttendanceWhereInput | boolean
    delete?: AttendanceWhereInput | boolean
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutHeadsUpInput, AttendanceUpdateWithoutHeadsUpInput>, AttendanceUncheckedUpdateWithoutHeadsUpInput>
  }

  export type UserCreateNestedManyWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput> | UserCreateWithoutNotificationInput[] | UserUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput | UserCreateOrConnectWithoutNotificationInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput> | UserCreateWithoutNotificationInput[] | UserUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput | UserCreateOrConnectWithoutNotificationInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput> | UserCreateWithoutNotificationInput[] | UserUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput | UserCreateOrConnectWithoutNotificationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutNotificationInput | UserUpsertWithWhereUniqueWithoutNotificationInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutNotificationInput | UserUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutNotificationInput | UserUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput> | UserCreateWithoutNotificationInput[] | UserUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput | UserCreateOrConnectWithoutNotificationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutNotificationInput | UserUpsertWithWhereUniqueWithoutNotificationInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutNotificationInput | UserUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutNotificationInput | UserUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnnouncementCreateTagsInput = {
    set: $Enums.Tag[]
  }

  export type UserCreateNestedManyWithoutAnnouncementsInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput> | UserCreateWithoutAnnouncementsInput[] | UserUncheckedCreateWithoutAnnouncementsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput | UserCreateOrConnectWithoutAnnouncementsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAnnouncementsInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput> | UserCreateWithoutAnnouncementsInput[] | UserUncheckedCreateWithoutAnnouncementsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput | UserCreateOrConnectWithoutAnnouncementsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumAnnouncementVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.AnnouncementVisibility
  }

  export type AnnouncementUpdateTagsInput = {
    set?: $Enums.Tag[]
    push?: $Enums.Tag | $Enums.Tag[]
  }

  export type EnumAnnouncementTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnnouncementType
  }

  export type UserUpdateManyWithoutAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput> | UserCreateWithoutAnnouncementsInput[] | UserUncheckedCreateWithoutAnnouncementsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput | UserCreateOrConnectWithoutAnnouncementsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAnnouncementsInput | UserUpsertWithWhereUniqueWithoutAnnouncementsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAnnouncementsInput | UserUpdateWithWhereUniqueWithoutAnnouncementsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAnnouncementsInput | UserUpdateManyWithWhereWithoutAnnouncementsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput> | UserCreateWithoutAnnouncementsInput[] | UserUncheckedCreateWithoutAnnouncementsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput | UserCreateOrConnectWithoutAnnouncementsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAnnouncementsInput | UserUpsertWithWhereUniqueWithoutAnnouncementsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAnnouncementsInput | UserUpdateWithWhereUniqueWithoutAnnouncementsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAnnouncementsInput | UserUpdateManyWithWhereWithoutAnnouncementsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type FileCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<FileCreateWithoutCategoriesInput, FileUncheckedCreateWithoutCategoriesInput> | FileCreateWithoutCategoriesInput[] | FileUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCategoriesInput | FileCreateOrConnectWithoutCategoriesInput[]
    createMany?: FileCreateManyCategoriesInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<FileCreateWithoutCategoriesInput, FileUncheckedCreateWithoutCategoriesInput> | FileCreateWithoutCategoriesInput[] | FileUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCategoriesInput | FileCreateOrConnectWithoutCategoriesInput[]
    createMany?: FileCreateManyCategoriesInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<FileCreateWithoutCategoriesInput, FileUncheckedCreateWithoutCategoriesInput> | FileCreateWithoutCategoriesInput[] | FileUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCategoriesInput | FileCreateOrConnectWithoutCategoriesInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutCategoriesInput | FileUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: FileCreateManyCategoriesInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutCategoriesInput | FileUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: FileUpdateManyWithWhereWithoutCategoriesInput | FileUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<FileCreateWithoutCategoriesInput, FileUncheckedCreateWithoutCategoriesInput> | FileCreateWithoutCategoriesInput[] | FileUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: FileCreateOrConnectWithoutCategoriesInput | FileCreateOrConnectWithoutCategoriesInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutCategoriesInput | FileUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: FileCreateManyCategoriesInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutCategoriesInput | FileUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: FileUpdateManyWithWhereWithoutCategoriesInput | FileUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileCategoriesCreateNestedOneWithoutFilesInput = {
    create?: XOR<FileCategoriesCreateWithoutFilesInput, FileCategoriesUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileCategoriesCreateOrConnectWithoutFilesInput
    connect?: FileCategoriesWhereUniqueInput
  }

  export type FileCategoriesUpdateOneWithoutFilesNestedInput = {
    create?: XOR<FileCategoriesCreateWithoutFilesInput, FileCategoriesUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileCategoriesCreateOrConnectWithoutFilesInput
    upsert?: FileCategoriesUpsertWithoutFilesInput
    disconnect?: FileCategoriesWhereInput | boolean
    delete?: FileCategoriesWhereInput | boolean
    connect?: FileCategoriesWhereUniqueInput
    update?: XOR<XOR<FileCategoriesUpdateToOneWithWhereWithoutFilesInput, FileCategoriesUpdateWithoutFilesInput>, FileCategoriesUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedManyWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput> | UserCreateWithoutBadgesInput[] | UserUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput | UserCreateOrConnectWithoutBadgesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput> | UserCreateWithoutBadgesInput[] | UserUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput | UserCreateOrConnectWithoutBadgesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput> | UserCreateWithoutBadgesInput[] | UserUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput | UserCreateOrConnectWithoutBadgesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBadgesInput | UserUpsertWithWhereUniqueWithoutBadgesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBadgesInput | UserUpdateWithWhereUniqueWithoutBadgesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBadgesInput | UserUpdateManyWithWhereWithoutBadgesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput> | UserCreateWithoutBadgesInput[] | UserUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput | UserCreateOrConnectWithoutBadgesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBadgesInput | UserUpsertWithWhereUniqueWithoutBadgesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBadgesInput | UserUpdateWithWhereUniqueWithoutBadgesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBadgesInput | UserUpdateManyWithWhereWithoutBadgesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumClubStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubStatus | EnumClubStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClubStatusNullableFilter<$PrismaModel> | $Enums.ClubStatus | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleType | EnumRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleTypeFilter<$PrismaModel> | $Enums.RoleType
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumClubStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubStatus | EnumClubStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ClubStatus[] | ListEnumClubStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumClubStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ClubStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumClubStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumClubStatusNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleType | EnumRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleType[] | ListEnumRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleTypeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumUniversityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UniversityStatus | EnumUniversityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUniversityStatusFilter<$PrismaModel> | $Enums.UniversityStatus
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUniversityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UniversityStatus | EnumUniversityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UniversityStatus[] | ListEnumUniversityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUniversityStatusWithAggregatesFilter<$PrismaModel> | $Enums.UniversityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUniversityStatusFilter<$PrismaModel>
    _max?: NestedEnumUniversityStatusFilter<$PrismaModel>
  }

  export type NestedEnumThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeFilter<$PrismaModel> | $Enums.Theme
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeWithAggregatesFilter<$PrismaModel> | $Enums.Theme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeFilter<$PrismaModel>
    _max?: NestedEnumThemeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEventVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.EventVisibility | EnumEventVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEventVisibilityFilter<$PrismaModel> | $Enums.EventVisibility
  }

  export type NestedEnumstateFilter<$PrismaModel = never> = {
    equals?: $Enums.state | EnumstateFieldRefInput<$PrismaModel>
    in?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    notIn?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    not?: NestedEnumstateFilter<$PrismaModel> | $Enums.state
  }

  export type NestedEnumEventVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventVisibility | EnumEventVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventVisibility[] | ListEnumEventVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumEventVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.EventVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventVisibilityFilter<$PrismaModel>
    _max?: NestedEnumEventVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumstateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.state | EnumstateFieldRefInput<$PrismaModel>
    in?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    notIn?: $Enums.state[] | ListEnumstateFieldRefInput<$PrismaModel>
    not?: NestedEnumstateWithAggregatesFilter<$PrismaModel> | $Enums.state
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstateFilter<$PrismaModel>
    _max?: NestedEnumstateFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumEventRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRole | EnumEventRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRoleFilter<$PrismaModel> | $Enums.EventRole
  }

  export type NestedEnumEventRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRole | EnumEventRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRole[] | ListEnumEventRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRoleWithAggregatesFilter<$PrismaModel> | $Enums.EventRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventRoleFilter<$PrismaModel>
    _max?: NestedEnumEventRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSessionRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionRole | EnumSessionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionRoleFilter<$PrismaModel> | $Enums.SessionRole
  }

  export type NestedEnumSessionRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionRole | EnumSessionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionRole[] | ListEnumSessionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionRoleWithAggregatesFilter<$PrismaModel> | $Enums.SessionRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionRoleFilter<$PrismaModel>
    _max?: NestedEnumSessionRoleFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumHeadsUpTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HeadsUpType | EnumHeadsUpTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeadsUpTypeFilter<$PrismaModel> | $Enums.HeadsUpType
  }

  export type NestedEnumHeadsUpTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HeadsUpType | EnumHeadsUpTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeadsUpType[] | ListEnumHeadsUpTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeadsUpTypeWithAggregatesFilter<$PrismaModel> | $Enums.HeadsUpType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHeadsUpTypeFilter<$PrismaModel>
    _max?: NestedEnumHeadsUpTypeFilter<$PrismaModel>
  }

  export type NestedEnumAnnouncementVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementVisibility | EnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementVisibilityFilter<$PrismaModel> | $Enums.AnnouncementVisibility
  }

  export type NestedEnumAnnouncementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeFilter<$PrismaModel> | $Enums.AnnouncementType
  }

  export type NestedEnumAnnouncementVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementVisibility | EnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementVisibility[] | ListEnumAnnouncementVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementVisibilityFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumAnnouncementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
  }

  export type UniversityInfoCreateWithoutUserInput = {
    id?: string
    currentYear?: number | null
    expectedGraduationYear?: number | null
    major?: string | null
    universityId?: string | null
    status: $Enums.UniversityStatus
    department?: string | null
  }

  export type UniversityInfoUncheckedCreateWithoutUserInput = {
    id?: string
    currentYear?: number | null
    expectedGraduationYear?: number | null
    major?: string | null
    universityId?: string | null
    status: $Enums.UniversityStatus
    department?: string | null
  }

  export type UniversityInfoCreateOrConnectWithoutUserInput = {
    where: UniversityInfoWhereUniqueInput
    create: XOR<UniversityInfoCreateWithoutUserInput, UniversityInfoUncheckedCreateWithoutUserInput>
  }

  export type DivisionsCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHead?: UserCreateNestedOneWithoutDivisionHeadInput
    socialLinks?: socialLinkCreateNestedManyWithoutDivisionInput
    sessions?: SessionsCreateNestedManyWithoutDivisionInput
    groups?: GroupsCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHeadID?: string | null
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutDivisionInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutDivisionInput
    groups?: GroupsUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsCreateOrConnectWithoutUserInput = {
    where: DivisionsWhereUniqueInput
    create: XOR<DivisionsCreateWithoutUserInput, DivisionsUncheckedCreateWithoutUserInput>
  }

  export type socialLinkCreateWithoutUserInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Division?: DivisionsCreateNestedOneWithoutSocialLinksInput
  }

  export type socialLinkUncheckedCreateWithoutUserInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    DivisionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type socialLinkCreateOrConnectWithoutUserInput = {
    where: socialLinkWhereUniqueInput
    create: XOR<socialLinkCreateWithoutUserInput, socialLinkUncheckedCreateWithoutUserInput>
  }

  export type socialLinkCreateManyUserInputEnvelope = {
    data: socialLinkCreateManyUserInput | socialLinkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingCreateWithoutUserInput = {
    id?: string
    theme?: $Enums.Theme
    phonePublic?: boolean
    authUpdateCalendar?: boolean
  }

  export type UserSettingUncheckedCreateWithoutUserInput = {
    id?: string
    theme?: $Enums.Theme
    phonePublic?: boolean
    authUpdateCalendar?: boolean
  }

  export type UserSettingCreateOrConnectWithoutUserInput = {
    where: UserSettingWhereUniqueInput
    create: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
  }

  export type BadgesCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    criteria?: string | null
    points?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgesUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    criteria?: string | null
    points?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgesCreateOrConnectWithoutUserInput = {
    where: BadgesWhereUniqueInput
    create: XOR<BadgesCreateWithoutUserInput, BadgesUncheckedCreateWithoutUserInput>
  }

  export type EventsCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    timeSlots?: EventTimeSlotCreateNestedManyWithoutEventInput
    groups?: GroupsCreateNestedManyWithoutEventsInput
    tasks?: TasksCreateNestedManyWithoutEventInput
    participants?: EventParticipationCreateNestedManyWithoutEventInput
    attendance?: AttendanceCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    timeSlots?: EventTimeSlotUncheckedCreateNestedManyWithoutEventInput
    groups?: GroupsUncheckedCreateNestedManyWithoutEventsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutEventInput
    participants?: EventParticipationUncheckedCreateNestedManyWithoutEventInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutCreatorInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutCreatorInput, EventsUncheckedCreateWithoutCreatorInput>
  }

  export type EventsCreateManyCreatorInputEnvelope = {
    data: EventsCreateManyCreatorInput | EventsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SessionsCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutCreatorInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutCreatorInput, SessionsUncheckedCreateWithoutCreatorInput>
  }

  export type SessionsCreateManyCreatorInputEnvelope = {
    data: SessionsCreateManyCreatorInput | SessionsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type GroupsCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    division?: DivisionsCreateNestedOneWithoutGroupsInput
    sessions?: SessionsCreateNestedManyWithoutTargetGroupsInput
    events?: EventsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionId?: string | null
    sessions?: SessionsUncheckedCreateNestedManyWithoutTargetGroupsInput
    events?: EventsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutUsersInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutUsersInput, GroupsUncheckedCreateWithoutUsersInput>
  }

  export type DivisionsCreateWithoutCurrentHeadInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkCreateNestedManyWithoutDivisionInput
    sessions?: SessionsCreateNestedManyWithoutDivisionInput
    groups?: GroupsCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUncheckedCreateWithoutCurrentHeadInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutDivisionInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutDivisionInput
    groups?: GroupsUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsCreateOrConnectWithoutCurrentHeadInput = {
    where: DivisionsWhereUniqueInput
    create: XOR<DivisionsCreateWithoutCurrentHeadInput, DivisionsUncheckedCreateWithoutCurrentHeadInput>
  }

  export type TasksCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedManyWithoutAssignedTasksInput
    event?: EventsCreateNestedOneWithoutTasksInput
    session?: SessionsCreateNestedOneWithoutTasksInput
    participants?: TaskParticipationCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventId?: string | null
    sessionId?: string | null
    assignedTo?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
    participants?: TaskParticipationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksCreateOrConnectWithoutCreatorInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutCreatorInput, TasksUncheckedCreateWithoutCreatorInput>
  }

  export type TasksCreateManyCreatorInputEnvelope = {
    data: TasksCreateManyCreatorInput | TasksCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TasksCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    event?: EventsCreateNestedOneWithoutTasksInput
    session?: SessionsCreateNestedOneWithoutTasksInput
    participants?: TaskParticipationCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    eventId?: string | null
    sessionId?: string | null
    participants?: TaskParticipationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksCreateOrConnectWithoutAssignedToInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
  }

  export type EventParticipationCreateWithoutUserInput = {
    id?: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    event: EventsCreateNestedOneWithoutParticipantsInput
  }

  export type EventParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type EventParticipationCreateOrConnectWithoutUserInput = {
    where: EventParticipationWhereUniqueInput
    create: XOR<EventParticipationCreateWithoutUserInput, EventParticipationUncheckedCreateWithoutUserInput>
  }

  export type EventParticipationCreateManyUserInputEnvelope = {
    data: EventParticipationCreateManyUserInput | EventParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionParticipationCreateWithoutUserInput = {
    id?: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    session: SessionsCreateNestedOneWithoutParticipantsInput
  }

  export type SessionParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type SessionParticipationCreateOrConnectWithoutUserInput = {
    where: SessionParticipationWhereUniqueInput
    create: XOR<SessionParticipationCreateWithoutUserInput, SessionParticipationUncheckedCreateWithoutUserInput>
  }

  export type SessionParticipationCreateManyUserInputEnvelope = {
    data: SessionParticipationCreateManyUserInput | SessionParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskParticipationCreateWithoutUserInput = {
    id?: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    task: TasksCreateNestedOneWithoutParticipantsInput
  }

  export type TaskParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type TaskParticipationCreateOrConnectWithoutUserInput = {
    where: TaskParticipationWhereUniqueInput
    create: XOR<TaskParticipationCreateWithoutUserInput, TaskParticipationUncheckedCreateWithoutUserInput>
  }

  export type TaskParticipationCreateManyUserInputEnvelope = {
    data: TaskParticipationCreateManyUserInput | TaskParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    session?: SessionsCreateNestedOneWithoutAttendanceInput
    event?: EventsCreateNestedOneWithoutAttendanceInput
    headsUp?: HeadsUpCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceSummaryCreateWithoutUserInput = {
    id?: string
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryUncheckedCreateWithoutUserInput = {
    id?: string
    totalEvents: number
    totalSessions: number
    totalTasks: number
    totalAttendance: number
    totalHeadsUps: number
    totalPresent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryCreateOrConnectWithoutUserInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutUserInput, AttendanceSummaryUncheckedCreateWithoutUserInput>
  }

  export type HeadsUpCreateWithoutUserInput = {
    id?: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
    attendance?: AttendanceCreateNestedOneWithoutHeadsUpInput
  }

  export type HeadsUpUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedOneWithoutHeadsUpInput
  }

  export type HeadsUpCreateOrConnectWithoutUserInput = {
    where: HeadsUpWhereUniqueInput
    create: XOR<HeadsUpCreateWithoutUserInput, HeadsUpUncheckedCreateWithoutUserInput>
  }

  export type HeadsUpCreateManyUserInputEnvelope = {
    data: HeadsUpCreateManyUserInput | HeadsUpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type AnnouncementCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    visibility: $Enums.AnnouncementVisibility
    Tags?: AnnouncementCreateTagsInput | $Enums.Tag[]
    announcementType: $Enums.AnnouncementType
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    visibility: $Enums.AnnouncementVisibility
    Tags?: AnnouncementCreateTagsInput | $Enums.Tag[]
    announcementType: $Enums.AnnouncementType
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutUserInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutUserInput, AnnouncementUncheckedCreateWithoutUserInput>
  }

  export type UniversityInfoUpsertWithoutUserInput = {
    update: XOR<UniversityInfoUpdateWithoutUserInput, UniversityInfoUncheckedUpdateWithoutUserInput>
    create: XOR<UniversityInfoCreateWithoutUserInput, UniversityInfoUncheckedCreateWithoutUserInput>
    where?: UniversityInfoWhereInput
  }

  export type UniversityInfoUpdateToOneWithWhereWithoutUserInput = {
    where?: UniversityInfoWhereInput
    data: XOR<UniversityInfoUpdateWithoutUserInput, UniversityInfoUncheckedUpdateWithoutUserInput>
  }

  export type UniversityInfoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentYear?: NullableIntFieldUpdateOperationsInput | number | null
    expectedGraduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUniversityStatusFieldUpdateOperationsInput | $Enums.UniversityStatus
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UniversityInfoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentYear?: NullableIntFieldUpdateOperationsInput | number | null
    expectedGraduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUniversityStatusFieldUpdateOperationsInput | $Enums.UniversityStatus
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DivisionsUpsertWithoutUserInput = {
    update: XOR<DivisionsUpdateWithoutUserInput, DivisionsUncheckedUpdateWithoutUserInput>
    create: XOR<DivisionsCreateWithoutUserInput, DivisionsUncheckedCreateWithoutUserInput>
    where?: DivisionsWhereInput
  }

  export type DivisionsUpdateToOneWithWhereWithoutUserInput = {
    where?: DivisionsWhereInput
    data: XOR<DivisionsUpdateWithoutUserInput, DivisionsUncheckedUpdateWithoutUserInput>
  }

  export type DivisionsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHead?: UserUpdateOneWithoutDivisionHeadNestedInput
    socialLinks?: socialLinkUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: socialLinkUncheckedUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type socialLinkUpsertWithWhereUniqueWithoutUserInput = {
    where: socialLinkWhereUniqueInput
    update: XOR<socialLinkUpdateWithoutUserInput, socialLinkUncheckedUpdateWithoutUserInput>
    create: XOR<socialLinkCreateWithoutUserInput, socialLinkUncheckedCreateWithoutUserInput>
  }

  export type socialLinkUpdateWithWhereUniqueWithoutUserInput = {
    where: socialLinkWhereUniqueInput
    data: XOR<socialLinkUpdateWithoutUserInput, socialLinkUncheckedUpdateWithoutUserInput>
  }

  export type socialLinkUpdateManyWithWhereWithoutUserInput = {
    where: socialLinkScalarWhereInput
    data: XOR<socialLinkUpdateManyMutationInput, socialLinkUncheckedUpdateManyWithoutUserInput>
  }

  export type socialLinkScalarWhereInput = {
    AND?: socialLinkScalarWhereInput | socialLinkScalarWhereInput[]
    OR?: socialLinkScalarWhereInput[]
    NOT?: socialLinkScalarWhereInput | socialLinkScalarWhereInput[]
    id?: UuidFilter<"socialLink"> | string
    socialLinkName?: StringFilter<"socialLink"> | string
    socialLinkUrl?: StringFilter<"socialLink"> | string
    userId?: UuidNullableFilter<"socialLink"> | string | null
    DivisionId?: UuidNullableFilter<"socialLink"> | string | null
    createdAt?: DateTimeFilter<"socialLink"> | Date | string
    updatedAt?: DateTimeFilter<"socialLink"> | Date | string
  }

  export type UserSettingUpsertWithoutUserInput = {
    update: XOR<UserSettingUpdateWithoutUserInput, UserSettingUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
    where?: UserSettingWhereInput
  }

  export type UserSettingUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingWhereInput
    data: XOR<UserSettingUpdateWithoutUserInput, UserSettingUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    phonePublic?: BoolFieldUpdateOperationsInput | boolean
    authUpdateCalendar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSettingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    phonePublic?: BoolFieldUpdateOperationsInput | boolean
    authUpdateCalendar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BadgesUpsertWithWhereUniqueWithoutUserInput = {
    where: BadgesWhereUniqueInput
    update: XOR<BadgesUpdateWithoutUserInput, BadgesUncheckedUpdateWithoutUserInput>
    create: XOR<BadgesCreateWithoutUserInput, BadgesUncheckedCreateWithoutUserInput>
  }

  export type BadgesUpdateWithWhereUniqueWithoutUserInput = {
    where: BadgesWhereUniqueInput
    data: XOR<BadgesUpdateWithoutUserInput, BadgesUncheckedUpdateWithoutUserInput>
  }

  export type BadgesUpdateManyWithWhereWithoutUserInput = {
    where: BadgesScalarWhereInput
    data: XOR<BadgesUpdateManyMutationInput, BadgesUncheckedUpdateManyWithoutUserInput>
  }

  export type BadgesScalarWhereInput = {
    AND?: BadgesScalarWhereInput | BadgesScalarWhereInput[]
    OR?: BadgesScalarWhereInput[]
    NOT?: BadgesScalarWhereInput | BadgesScalarWhereInput[]
    id?: UuidFilter<"Badges"> | string
    name?: StringFilter<"Badges"> | string
    description?: StringNullableFilter<"Badges"> | string | null
    imageUrl?: StringNullableFilter<"Badges"> | string | null
    criteria?: StringNullableFilter<"Badges"> | string | null
    points?: IntNullableFilter<"Badges"> | number | null
    createdAt?: DateTimeFilter<"Badges"> | Date | string
    updatedAt?: DateTimeFilter<"Badges"> | Date | string
  }

  export type EventsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutCreatorInput, EventsUncheckedUpdateWithoutCreatorInput>
    create: XOR<EventsCreateWithoutCreatorInput, EventsUncheckedCreateWithoutCreatorInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutCreatorInput, EventsUncheckedUpdateWithoutCreatorInput>
  }

  export type EventsUpdateManyWithWhereWithoutCreatorInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EventsScalarWhereInput = {
    AND?: EventsScalarWhereInput | EventsScalarWhereInput[]
    OR?: EventsScalarWhereInput[]
    NOT?: EventsScalarWhereInput | EventsScalarWhereInput[]
    id?: UuidFilter<"Events"> | string
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    startDate?: DateTimeFilter<"Events"> | Date | string
    startTime?: DateTimeFilter<"Events"> | Date | string
    endTime?: DateTimeFilter<"Events"> | Date | string
    location?: StringNullableFilter<"Events"> | string | null
    tags?: EnumTagNullableListFilter<"Events">
    visibility?: EnumEventVisibilityFilter<"Events"> | $Enums.EventVisibility
    state?: EnumstateFilter<"Events"> | $Enums.state
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
    creatorId?: UuidFilter<"Events"> | string
  }

  export type SessionsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SessionsWhereUniqueInput
    update: XOR<SessionsUpdateWithoutCreatorInput, SessionsUncheckedUpdateWithoutCreatorInput>
    create: XOR<SessionsCreateWithoutCreatorInput, SessionsUncheckedCreateWithoutCreatorInput>
  }

  export type SessionsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SessionsWhereUniqueInput
    data: XOR<SessionsUpdateWithoutCreatorInput, SessionsUncheckedUpdateWithoutCreatorInput>
  }

  export type SessionsUpdateManyWithWhereWithoutCreatorInput = {
    where: SessionsScalarWhereInput
    data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SessionsScalarWhereInput = {
    AND?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
    OR?: SessionsScalarWhereInput[]
    NOT?: SessionsScalarWhereInput | SessionsScalarWhereInput[]
    id?: UuidFilter<"Sessions"> | string
    title?: StringFilter<"Sessions"> | string
    description?: StringNullableFilter<"Sessions"> | string | null
    startMonth?: DateTimeFilter<"Sessions"> | Date | string
    endTMonth?: DateTimeFilter<"Sessions"> | Date | string
    location?: StringNullableFilter<"Sessions"> | string | null
    tags?: EnumTagNullableListFilter<"Sessions">
    state?: EnumstateFilter<"Sessions"> | $Enums.state
    createdAt?: DateTimeFilter<"Sessions"> | Date | string
    updatedAt?: DateTimeFilter<"Sessions"> | Date | string
    creatorId?: UuidFilter<"Sessions"> | string
  }

  export type GroupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: GroupsWhereUniqueInput
    update: XOR<GroupsUpdateWithoutUsersInput, GroupsUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupsCreateWithoutUsersInput, GroupsUncheckedCreateWithoutUsersInput>
  }

  export type GroupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: GroupsWhereUniqueInput
    data: XOR<GroupsUpdateWithoutUsersInput, GroupsUncheckedUpdateWithoutUsersInput>
  }

  export type GroupsUpdateManyWithWhereWithoutUsersInput = {
    where: GroupsScalarWhereInput
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyWithoutUsersInput>
  }

  export type GroupsScalarWhereInput = {
    AND?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
    OR?: GroupsScalarWhereInput[]
    NOT?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
    id?: UuidFilter<"Groups"> | string
    name?: StringFilter<"Groups"> | string
    description?: StringNullableFilter<"Groups"> | string | null
    createdAt?: DateTimeFilter<"Groups"> | Date | string
    updatedAt?: DateTimeFilter<"Groups"> | Date | string
    divisionId?: UuidNullableFilter<"Groups"> | string | null
  }

  export type DivisionsUpsertWithoutCurrentHeadInput = {
    update: XOR<DivisionsUpdateWithoutCurrentHeadInput, DivisionsUncheckedUpdateWithoutCurrentHeadInput>
    create: XOR<DivisionsCreateWithoutCurrentHeadInput, DivisionsUncheckedCreateWithoutCurrentHeadInput>
    where?: DivisionsWhereInput
  }

  export type DivisionsUpdateToOneWithWhereWithoutCurrentHeadInput = {
    where?: DivisionsWhereInput
    data: XOR<DivisionsUpdateWithoutCurrentHeadInput, DivisionsUncheckedUpdateWithoutCurrentHeadInput>
  }

  export type DivisionsUpdateWithoutCurrentHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateWithoutCurrentHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type TasksUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutCreatorInput, TasksUncheckedUpdateWithoutCreatorInput>
    create: XOR<TasksCreateWithoutCreatorInput, TasksUncheckedCreateWithoutCreatorInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutCreatorInput, TasksUncheckedUpdateWithoutCreatorInput>
  }

  export type TasksUpdateManyWithWhereWithoutCreatorInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TasksScalarWhereInput = {
    AND?: TasksScalarWhereInput | TasksScalarWhereInput[]
    OR?: TasksScalarWhereInput[]
    NOT?: TasksScalarWhereInput | TasksScalarWhereInput[]
    id?: UuidFilter<"Tasks"> | string
    title?: StringFilter<"Tasks"> | string
    description?: StringNullableFilter<"Tasks"> | string | null
    dueDate?: DateTimeFilter<"Tasks"> | Date | string
    status?: EnumTaskStatusFilter<"Tasks"> | $Enums.TaskStatus
    completedNotes?: StringNullableFilter<"Tasks"> | string | null
    approvedAt?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    createdAt?: DateTimeFilter<"Tasks"> | Date | string
    updatedAt?: DateTimeFilter<"Tasks"> | Date | string
    creatorId?: UuidFilter<"Tasks"> | string
    eventId?: UuidNullableFilter<"Tasks"> | string | null
    sessionId?: UuidNullableFilter<"Tasks"> | string | null
  }

  export type TasksUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutAssignedToInput, TasksUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutAssignedToInput, TasksUncheckedUpdateWithoutAssignedToInput>
  }

  export type TasksUpdateManyWithWhereWithoutAssignedToInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type EventParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: EventParticipationWhereUniqueInput
    update: XOR<EventParticipationUpdateWithoutUserInput, EventParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<EventParticipationCreateWithoutUserInput, EventParticipationUncheckedCreateWithoutUserInput>
  }

  export type EventParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: EventParticipationWhereUniqueInput
    data: XOR<EventParticipationUpdateWithoutUserInput, EventParticipationUncheckedUpdateWithoutUserInput>
  }

  export type EventParticipationUpdateManyWithWhereWithoutUserInput = {
    where: EventParticipationScalarWhereInput
    data: XOR<EventParticipationUpdateManyMutationInput, EventParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type EventParticipationScalarWhereInput = {
    AND?: EventParticipationScalarWhereInput | EventParticipationScalarWhereInput[]
    OR?: EventParticipationScalarWhereInput[]
    NOT?: EventParticipationScalarWhereInput | EventParticipationScalarWhereInput[]
    id?: UuidFilter<"EventParticipation"> | string
    eventId?: UuidFilter<"EventParticipation"> | string
    userId?: UuidFilter<"EventParticipation"> | string
    role?: EnumEventRoleFilter<"EventParticipation"> | $Enums.EventRole
    score?: IntFilter<"EventParticipation"> | number
    feedback?: StringNullableFilter<"EventParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"EventParticipation"> | number | null
    createdAt?: DateTimeFilter<"EventParticipation"> | Date | string
  }

  export type SessionParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionParticipationWhereUniqueInput
    update: XOR<SessionParticipationUpdateWithoutUserInput, SessionParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<SessionParticipationCreateWithoutUserInput, SessionParticipationUncheckedCreateWithoutUserInput>
  }

  export type SessionParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionParticipationWhereUniqueInput
    data: XOR<SessionParticipationUpdateWithoutUserInput, SessionParticipationUncheckedUpdateWithoutUserInput>
  }

  export type SessionParticipationUpdateManyWithWhereWithoutUserInput = {
    where: SessionParticipationScalarWhereInput
    data: XOR<SessionParticipationUpdateManyMutationInput, SessionParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionParticipationScalarWhereInput = {
    AND?: SessionParticipationScalarWhereInput | SessionParticipationScalarWhereInput[]
    OR?: SessionParticipationScalarWhereInput[]
    NOT?: SessionParticipationScalarWhereInput | SessionParticipationScalarWhereInput[]
    id?: UuidFilter<"SessionParticipation"> | string
    sessionId?: UuidFilter<"SessionParticipation"> | string
    userId?: UuidFilter<"SessionParticipation"> | string
    role?: EnumSessionRoleFilter<"SessionParticipation"> | $Enums.SessionRole
    score?: IntFilter<"SessionParticipation"> | number
    feedback?: StringNullableFilter<"SessionParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"SessionParticipation"> | number | null
    createdAt?: DateTimeFilter<"SessionParticipation"> | Date | string
  }

  export type TaskParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskParticipationWhereUniqueInput
    update: XOR<TaskParticipationUpdateWithoutUserInput, TaskParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<TaskParticipationCreateWithoutUserInput, TaskParticipationUncheckedCreateWithoutUserInput>
  }

  export type TaskParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskParticipationWhereUniqueInput
    data: XOR<TaskParticipationUpdateWithoutUserInput, TaskParticipationUncheckedUpdateWithoutUserInput>
  }

  export type TaskParticipationUpdateManyWithWhereWithoutUserInput = {
    where: TaskParticipationScalarWhereInput
    data: XOR<TaskParticipationUpdateManyMutationInput, TaskParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskParticipationScalarWhereInput = {
    AND?: TaskParticipationScalarWhereInput | TaskParticipationScalarWhereInput[]
    OR?: TaskParticipationScalarWhereInput[]
    NOT?: TaskParticipationScalarWhereInput | TaskParticipationScalarWhereInput[]
    id?: UuidFilter<"TaskParticipation"> | string
    taskId?: StringFilter<"TaskParticipation"> | string
    userId?: StringFilter<"TaskParticipation"> | string
    role?: StringFilter<"TaskParticipation"> | string
    score?: IntFilter<"TaskParticipation"> | number
    feedback?: StringNullableFilter<"TaskParticipation"> | string | null
    feedbackScore?: IntNullableFilter<"TaskParticipation"> | number | null
    createdAt?: DateTimeFilter<"TaskParticipation"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: UuidFilter<"Attendance"> | string
    userId?: UuidFilter<"Attendance"> | string
    sessionId?: UuidNullableFilter<"Attendance"> | string | null
    eventId?: UuidNullableFilter<"Attendance"> | string | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    timestamp?: DateTimeFilter<"Attendance"> | Date | string
    headsUpId?: UuidNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type AttendanceSummaryUpsertWithoutUserInput = {
    update: XOR<AttendanceSummaryUpdateWithoutUserInput, AttendanceSummaryUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceSummaryCreateWithoutUserInput, AttendanceSummaryUncheckedCreateWithoutUserInput>
    where?: AttendanceSummaryWhereInput
  }

  export type AttendanceSummaryUpdateToOneWithWhereWithoutUserInput = {
    where?: AttendanceSummaryWhereInput
    data: XOR<AttendanceSummaryUpdateWithoutUserInput, AttendanceSummaryUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceSummaryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    totalAttendance?: IntFieldUpdateOperationsInput | number
    totalHeadsUps?: IntFieldUpdateOperationsInput | number
    totalPresent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalSessions?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    totalAttendance?: IntFieldUpdateOperationsInput | number
    totalHeadsUps?: IntFieldUpdateOperationsInput | number
    totalPresent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeadsUpUpsertWithWhereUniqueWithoutUserInput = {
    where: HeadsUpWhereUniqueInput
    update: XOR<HeadsUpUpdateWithoutUserInput, HeadsUpUncheckedUpdateWithoutUserInput>
    create: XOR<HeadsUpCreateWithoutUserInput, HeadsUpUncheckedCreateWithoutUserInput>
  }

  export type HeadsUpUpdateWithWhereUniqueWithoutUserInput = {
    where: HeadsUpWhereUniqueInput
    data: XOR<HeadsUpUpdateWithoutUserInput, HeadsUpUncheckedUpdateWithoutUserInput>
  }

  export type HeadsUpUpdateManyWithWhereWithoutUserInput = {
    where: HeadsUpScalarWhereInput
    data: XOR<HeadsUpUpdateManyMutationInput, HeadsUpUncheckedUpdateManyWithoutUserInput>
  }

  export type HeadsUpScalarWhereInput = {
    AND?: HeadsUpScalarWhereInput | HeadsUpScalarWhereInput[]
    OR?: HeadsUpScalarWhereInput[]
    NOT?: HeadsUpScalarWhereInput | HeadsUpScalarWhereInput[]
    id?: UuidFilter<"HeadsUp"> | string
    userId?: StringFilter<"HeadsUp"> | string
    type?: EnumHeadsUpTypeFilter<"HeadsUp"> | $Enums.HeadsUpType
    body?: StringFilter<"HeadsUp"> | string
    sentAt?: DateTimeFilter<"HeadsUp"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutUserInput, AnnouncementUncheckedUpdateWithoutUserInput>
    create: XOR<AnnouncementCreateWithoutUserInput, AnnouncementUncheckedCreateWithoutUserInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutUserInput, AnnouncementUncheckedUpdateWithoutUserInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutUserInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutUserInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: UuidFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    description?: StringNullableFilter<"Announcement"> | string | null
    visibility?: EnumAnnouncementVisibilityFilter<"Announcement"> | $Enums.AnnouncementVisibility
    Tags?: EnumTagNullableListFilter<"Announcement">
    announcementType?: EnumAnnouncementTypeFilter<"Announcement"> | $Enums.AnnouncementType
    sourceId?: UuidNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type UserCreateWithoutUniversityInfoInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUniversityInfoInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUniversityInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUniversityInfoInput, UserUncheckedCreateWithoutUniversityInfoInput>
  }

  export type UserUpsertWithoutUniversityInfoInput = {
    update: XOR<UserUpdateWithoutUniversityInfoInput, UserUncheckedUpdateWithoutUniversityInfoInput>
    create: XOR<UserCreateWithoutUniversityInfoInput, UserUncheckedCreateWithoutUniversityInfoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUniversityInfoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUniversityInfoInput, UserUncheckedUpdateWithoutUniversityInfoInput>
  }

  export type UserUpdateWithoutUniversityInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUniversityInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserSettingInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingInput, UserUncheckedCreateWithoutUserSettingInput>
  }

  export type UserUpsertWithoutUserSettingInput = {
    update: XOR<UserUpdateWithoutUserSettingInput, UserUncheckedUpdateWithoutUserSettingInput>
    create: XOR<UserCreateWithoutUserSettingInput, UserUncheckedCreateWithoutUserSettingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingInput, UserUncheckedUpdateWithoutUserSettingInput>
  }

  export type UserUpdateWithoutUserSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDivisionHeadInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDivisionHeadInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDivisionHeadInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDivisionHeadInput, UserUncheckedCreateWithoutDivisionHeadInput>
  }

  export type UserCreateWithoutDivisionsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDivisionsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDivisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDivisionsInput, UserUncheckedCreateWithoutDivisionsInput>
  }

  export type socialLinkCreateWithoutDivisionInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSocialLinksInput
  }

  export type socialLinkUncheckedCreateWithoutDivisionInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type socialLinkCreateOrConnectWithoutDivisionInput = {
    where: socialLinkWhereUniqueInput
    create: XOR<socialLinkCreateWithoutDivisionInput, socialLinkUncheckedCreateWithoutDivisionInput>
  }

  export type socialLinkCreateManyDivisionInputEnvelope = {
    data: socialLinkCreateManyDivisionInput | socialLinkCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type SessionsCreateWithoutDivisionInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutDivisionInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutDivisionInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutDivisionInput, SessionsUncheckedCreateWithoutDivisionInput>
  }

  export type GroupsCreateWithoutDivisionInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutGroupsInput
    sessions?: SessionsCreateNestedManyWithoutTargetGroupsInput
    events?: EventsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutDivisionInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutTargetGroupsInput
    events?: EventsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutDivisionInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutDivisionInput, GroupsUncheckedCreateWithoutDivisionInput>
  }

  export type GroupsCreateManyDivisionInputEnvelope = {
    data: GroupsCreateManyDivisionInput | GroupsCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDivisionHeadInput = {
    update: XOR<UserUpdateWithoutDivisionHeadInput, UserUncheckedUpdateWithoutDivisionHeadInput>
    create: XOR<UserCreateWithoutDivisionHeadInput, UserUncheckedCreateWithoutDivisionHeadInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDivisionHeadInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDivisionHeadInput, UserUncheckedUpdateWithoutDivisionHeadInput>
  }

  export type UserUpdateWithoutDivisionHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDivisionHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDivisionsInput = {
    update: XOR<UserUpdateWithoutDivisionsInput, UserUncheckedUpdateWithoutDivisionsInput>
    create: XOR<UserCreateWithoutDivisionsInput, UserUncheckedCreateWithoutDivisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDivisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDivisionsInput, UserUncheckedUpdateWithoutDivisionsInput>
  }

  export type UserUpdateWithoutDivisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDivisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type socialLinkUpsertWithWhereUniqueWithoutDivisionInput = {
    where: socialLinkWhereUniqueInput
    update: XOR<socialLinkUpdateWithoutDivisionInput, socialLinkUncheckedUpdateWithoutDivisionInput>
    create: XOR<socialLinkCreateWithoutDivisionInput, socialLinkUncheckedCreateWithoutDivisionInput>
  }

  export type socialLinkUpdateWithWhereUniqueWithoutDivisionInput = {
    where: socialLinkWhereUniqueInput
    data: XOR<socialLinkUpdateWithoutDivisionInput, socialLinkUncheckedUpdateWithoutDivisionInput>
  }

  export type socialLinkUpdateManyWithWhereWithoutDivisionInput = {
    where: socialLinkScalarWhereInput
    data: XOR<socialLinkUpdateManyMutationInput, socialLinkUncheckedUpdateManyWithoutDivisionInput>
  }

  export type SessionsUpsertWithWhereUniqueWithoutDivisionInput = {
    where: SessionsWhereUniqueInput
    update: XOR<SessionsUpdateWithoutDivisionInput, SessionsUncheckedUpdateWithoutDivisionInput>
    create: XOR<SessionsCreateWithoutDivisionInput, SessionsUncheckedCreateWithoutDivisionInput>
  }

  export type SessionsUpdateWithWhereUniqueWithoutDivisionInput = {
    where: SessionsWhereUniqueInput
    data: XOR<SessionsUpdateWithoutDivisionInput, SessionsUncheckedUpdateWithoutDivisionInput>
  }

  export type SessionsUpdateManyWithWhereWithoutDivisionInput = {
    where: SessionsScalarWhereInput
    data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyWithoutDivisionInput>
  }

  export type GroupsUpsertWithWhereUniqueWithoutDivisionInput = {
    where: GroupsWhereUniqueInput
    update: XOR<GroupsUpdateWithoutDivisionInput, GroupsUncheckedUpdateWithoutDivisionInput>
    create: XOR<GroupsCreateWithoutDivisionInput, GroupsUncheckedCreateWithoutDivisionInput>
  }

  export type GroupsUpdateWithWhereUniqueWithoutDivisionInput = {
    where: GroupsWhereUniqueInput
    data: XOR<GroupsUpdateWithoutDivisionInput, GroupsUncheckedUpdateWithoutDivisionInput>
  }

  export type GroupsUpdateManyWithWhereWithoutDivisionInput = {
    where: GroupsScalarWhereInput
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyWithoutDivisionInput>
  }

  export type UserCreateWithoutGroupsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type DivisionsCreateWithoutGroupsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHead?: UserCreateNestedOneWithoutDivisionHeadInput
    user?: UserCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkCreateNestedManyWithoutDivisionInput
    sessions?: SessionsCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUncheckedCreateWithoutGroupsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHeadID?: string | null
    user?: UserUncheckedCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutDivisionInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsCreateOrConnectWithoutGroupsInput = {
    where: DivisionsWhereUniqueInput
    create: XOR<DivisionsCreateWithoutGroupsInput, DivisionsUncheckedCreateWithoutGroupsInput>
  }

  export type SessionsCreateWithoutTargetGroupsInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutTargetGroupsInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutTargetGroupsInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutTargetGroupsInput, SessionsUncheckedCreateWithoutTargetGroupsInput>
  }

  export type EventsCreateWithoutGroupsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutEventsInput
    timeSlots?: EventTimeSlotCreateNestedManyWithoutEventInput
    tasks?: TasksCreateNestedManyWithoutEventInput
    participants?: EventParticipationCreateNestedManyWithoutEventInput
    attendance?: AttendanceCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutGroupsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    timeSlots?: EventTimeSlotUncheckedCreateNestedManyWithoutEventInput
    tasks?: TasksUncheckedCreateNestedManyWithoutEventInput
    participants?: EventParticipationUncheckedCreateNestedManyWithoutEventInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutGroupsInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutGroupsInput, EventsUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type UserUpdateManyWithWhereWithoutGroupsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: UuidFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phone_number?: StringNullableFilter<"User"> | string | null
    telegramUserName?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    berthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    clubStatus?: EnumClubStatusNullableFilter<"User"> | $Enums.ClubStatus | null
    specialty?: StringNullableFilter<"User"> | string | null
    cvUrl?: StringNullableFilter<"User"> | string | null
    lastSeen?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleTypeFilter<"User"> | $Enums.RoleType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    DivisionId?: UuidNullableFilter<"User"> | string | null
    UserSettingId?: UuidNullableFilter<"User"> | string | null
    DivisionHeadID?: UuidNullableFilter<"User"> | string | null
    AttendanceSummaryId?: UuidNullableFilter<"User"> | string | null
  }

  export type DivisionsUpsertWithoutGroupsInput = {
    update: XOR<DivisionsUpdateWithoutGroupsInput, DivisionsUncheckedUpdateWithoutGroupsInput>
    create: XOR<DivisionsCreateWithoutGroupsInput, DivisionsUncheckedCreateWithoutGroupsInput>
    where?: DivisionsWhereInput
  }

  export type DivisionsUpdateToOneWithWhereWithoutGroupsInput = {
    where?: DivisionsWhereInput
    data: XOR<DivisionsUpdateWithoutGroupsInput, DivisionsUncheckedUpdateWithoutGroupsInput>
  }

  export type DivisionsUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHead?: UserUpdateOneWithoutDivisionHeadNestedInput
    user?: UserUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutDivisionNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type SessionsUpsertWithWhereUniqueWithoutTargetGroupsInput = {
    where: SessionsWhereUniqueInput
    update: XOR<SessionsUpdateWithoutTargetGroupsInput, SessionsUncheckedUpdateWithoutTargetGroupsInput>
    create: XOR<SessionsCreateWithoutTargetGroupsInput, SessionsUncheckedCreateWithoutTargetGroupsInput>
  }

  export type SessionsUpdateWithWhereUniqueWithoutTargetGroupsInput = {
    where: SessionsWhereUniqueInput
    data: XOR<SessionsUpdateWithoutTargetGroupsInput, SessionsUncheckedUpdateWithoutTargetGroupsInput>
  }

  export type SessionsUpdateManyWithWhereWithoutTargetGroupsInput = {
    where: SessionsScalarWhereInput
    data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyWithoutTargetGroupsInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutGroupsInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutGroupsInput, EventsUncheckedUpdateWithoutGroupsInput>
    create: XOR<EventsCreateWithoutGroupsInput, EventsUncheckedCreateWithoutGroupsInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutGroupsInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutGroupsInput, EventsUncheckedUpdateWithoutGroupsInput>
  }

  export type EventsUpdateManyWithWhereWithoutGroupsInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserCreateWithoutSocialLinksInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocialLinksInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocialLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialLinksInput, UserUncheckedCreateWithoutSocialLinksInput>
  }

  export type DivisionsCreateWithoutSocialLinksInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHead?: UserCreateNestedOneWithoutDivisionHeadInput
    user?: UserCreateNestedOneWithoutDivisionsInput
    sessions?: SessionsCreateNestedManyWithoutDivisionInput
    groups?: GroupsCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUncheckedCreateWithoutSocialLinksInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHeadID?: string | null
    user?: UserUncheckedCreateNestedOneWithoutDivisionsInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutDivisionInput
    groups?: GroupsUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsCreateOrConnectWithoutSocialLinksInput = {
    where: DivisionsWhereUniqueInput
    create: XOR<DivisionsCreateWithoutSocialLinksInput, DivisionsUncheckedCreateWithoutSocialLinksInput>
  }

  export type UserUpsertWithoutSocialLinksInput = {
    update: XOR<UserUpdateWithoutSocialLinksInput, UserUncheckedUpdateWithoutSocialLinksInput>
    create: XOR<UserCreateWithoutSocialLinksInput, UserUncheckedCreateWithoutSocialLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialLinksInput, UserUncheckedUpdateWithoutSocialLinksInput>
  }

  export type UserUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DivisionsUpsertWithoutSocialLinksInput = {
    update: XOR<DivisionsUpdateWithoutSocialLinksInput, DivisionsUncheckedUpdateWithoutSocialLinksInput>
    create: XOR<DivisionsCreateWithoutSocialLinksInput, DivisionsUncheckedCreateWithoutSocialLinksInput>
    where?: DivisionsWhereInput
  }

  export type DivisionsUpdateToOneWithWhereWithoutSocialLinksInput = {
    where?: DivisionsWhereInput
    data: XOR<DivisionsUpdateWithoutSocialLinksInput, DivisionsUncheckedUpdateWithoutSocialLinksInput>
  }

  export type DivisionsUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHead?: UserUpdateOneWithoutDivisionHeadNestedInput
    user?: UserUpdateOneWithoutDivisionsNestedInput
    sessions?: SessionsUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutDivisionsNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type EventsCreateWithoutTimeSlotsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutEventsInput
    groups?: GroupsCreateNestedManyWithoutEventsInput
    tasks?: TasksCreateNestedManyWithoutEventInput
    participants?: EventParticipationCreateNestedManyWithoutEventInput
    attendance?: AttendanceCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutTimeSlotsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    groups?: GroupsUncheckedCreateNestedManyWithoutEventsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutEventInput
    participants?: EventParticipationUncheckedCreateNestedManyWithoutEventInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutTimeSlotsInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutTimeSlotsInput, EventsUncheckedCreateWithoutTimeSlotsInput>
  }

  export type EventsUpsertWithoutTimeSlotsInput = {
    update: XOR<EventsUpdateWithoutTimeSlotsInput, EventsUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<EventsCreateWithoutTimeSlotsInput, EventsUncheckedCreateWithoutTimeSlotsInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutTimeSlotsInput, EventsUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type EventsUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutEventsNestedInput
    groups?: GroupsUpdateManyWithoutEventsNestedInput
    tasks?: TasksUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groups?: GroupsUncheckedUpdateManyWithoutEventsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUncheckedUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutEventNestedInput
  }

  export type SessionsCreateWithoutTimeSlotInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutTimeSlotInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutTimeSlotInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutTimeSlotInput, SessionsUncheckedCreateWithoutTimeSlotInput>
  }

  export type SessionsUpsertWithoutTimeSlotInput = {
    update: XOR<SessionsUpdateWithoutTimeSlotInput, SessionsUncheckedUpdateWithoutTimeSlotInput>
    create: XOR<SessionsCreateWithoutTimeSlotInput, SessionsUncheckedCreateWithoutTimeSlotInput>
    where?: SessionsWhereInput
  }

  export type SessionsUpdateToOneWithWhereWithoutTimeSlotInput = {
    where?: SessionsWhereInput
    data: XOR<SessionsUpdateWithoutTimeSlotInput, SessionsUncheckedUpdateWithoutTimeSlotInput>
  }

  export type SessionsUpdateWithoutTimeSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutTimeSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutEventsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type EventTimeSlotCreateWithoutEventInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
  }

  export type EventTimeSlotUncheckedCreateWithoutEventInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
  }

  export type EventTimeSlotCreateOrConnectWithoutEventInput = {
    where: EventTimeSlotWhereUniqueInput
    create: XOR<EventTimeSlotCreateWithoutEventInput, EventTimeSlotUncheckedCreateWithoutEventInput>
  }

  export type EventTimeSlotCreateManyEventInputEnvelope = {
    data: EventTimeSlotCreateManyEventInput | EventTimeSlotCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type GroupsCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutGroupsInput
    division?: DivisionsCreateNestedOneWithoutGroupsInput
    sessions?: SessionsCreateNestedManyWithoutTargetGroupsInput
  }

  export type GroupsUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutTargetGroupsInput
  }

  export type GroupsCreateOrConnectWithoutEventsInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutEventsInput, GroupsUncheckedCreateWithoutEventsInput>
  }

  export type TasksCreateWithoutEventInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    assignedTo?: UserCreateNestedManyWithoutAssignedTasksInput
    session?: SessionsCreateNestedOneWithoutTasksInput
    participants?: TaskParticipationCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateWithoutEventInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    sessionId?: string | null
    assignedTo?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
    participants?: TaskParticipationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksCreateOrConnectWithoutEventInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutEventInput, TasksUncheckedCreateWithoutEventInput>
  }

  export type TasksCreateManyEventInputEnvelope = {
    data: TasksCreateManyEventInput | TasksCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventParticipationCreateWithoutEventInput = {
    id?: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventParticipationInput
  }

  export type EventParticipationUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type EventParticipationCreateOrConnectWithoutEventInput = {
    where: EventParticipationWhereUniqueInput
    create: XOR<EventParticipationCreateWithoutEventInput, EventParticipationUncheckedCreateWithoutEventInput>
  }

  export type EventParticipationCreateManyEventInputEnvelope = {
    data: EventParticipationCreateManyEventInput | EventParticipationCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutEventInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
    session?: SessionsCreateNestedOneWithoutAttendanceInput
    headsUp?: HeadsUpCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    sessionId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutEventInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEventInput, AttendanceUncheckedCreateWithoutEventInput>
  }

  export type AttendanceCreateManyEventInputEnvelope = {
    data: AttendanceCreateManyEventInput | AttendanceCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventTimeSlotUpsertWithWhereUniqueWithoutEventInput = {
    where: EventTimeSlotWhereUniqueInput
    update: XOR<EventTimeSlotUpdateWithoutEventInput, EventTimeSlotUncheckedUpdateWithoutEventInput>
    create: XOR<EventTimeSlotCreateWithoutEventInput, EventTimeSlotUncheckedCreateWithoutEventInput>
  }

  export type EventTimeSlotUpdateWithWhereUniqueWithoutEventInput = {
    where: EventTimeSlotWhereUniqueInput
    data: XOR<EventTimeSlotUpdateWithoutEventInput, EventTimeSlotUncheckedUpdateWithoutEventInput>
  }

  export type EventTimeSlotUpdateManyWithWhereWithoutEventInput = {
    where: EventTimeSlotScalarWhereInput
    data: XOR<EventTimeSlotUpdateManyMutationInput, EventTimeSlotUncheckedUpdateManyWithoutEventInput>
  }

  export type EventTimeSlotScalarWhereInput = {
    AND?: EventTimeSlotScalarWhereInput | EventTimeSlotScalarWhereInput[]
    OR?: EventTimeSlotScalarWhereInput[]
    NOT?: EventTimeSlotScalarWhereInput | EventTimeSlotScalarWhereInput[]
    id?: UuidFilter<"EventTimeSlot"> | string
    eventId?: UuidNullableFilter<"EventTimeSlot"> | string | null
    startTime?: DateTimeFilter<"EventTimeSlot"> | Date | string
    endTime?: DateTimeFilter<"EventTimeSlot"> | Date | string
  }

  export type GroupsUpsertWithWhereUniqueWithoutEventsInput = {
    where: GroupsWhereUniqueInput
    update: XOR<GroupsUpdateWithoutEventsInput, GroupsUncheckedUpdateWithoutEventsInput>
    create: XOR<GroupsCreateWithoutEventsInput, GroupsUncheckedCreateWithoutEventsInput>
  }

  export type GroupsUpdateWithWhereUniqueWithoutEventsInput = {
    where: GroupsWhereUniqueInput
    data: XOR<GroupsUpdateWithoutEventsInput, GroupsUncheckedUpdateWithoutEventsInput>
  }

  export type GroupsUpdateManyWithWhereWithoutEventsInput = {
    where: GroupsScalarWhereInput
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyWithoutEventsInput>
  }

  export type TasksUpsertWithWhereUniqueWithoutEventInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutEventInput, TasksUncheckedUpdateWithoutEventInput>
    create: XOR<TasksCreateWithoutEventInput, TasksUncheckedCreateWithoutEventInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutEventInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutEventInput, TasksUncheckedUpdateWithoutEventInput>
  }

  export type TasksUpdateManyWithWhereWithoutEventInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutEventInput>
  }

  export type EventParticipationUpsertWithWhereUniqueWithoutEventInput = {
    where: EventParticipationWhereUniqueInput
    update: XOR<EventParticipationUpdateWithoutEventInput, EventParticipationUncheckedUpdateWithoutEventInput>
    create: XOR<EventParticipationCreateWithoutEventInput, EventParticipationUncheckedCreateWithoutEventInput>
  }

  export type EventParticipationUpdateWithWhereUniqueWithoutEventInput = {
    where: EventParticipationWhereUniqueInput
    data: XOR<EventParticipationUpdateWithoutEventInput, EventParticipationUncheckedUpdateWithoutEventInput>
  }

  export type EventParticipationUpdateManyWithWhereWithoutEventInput = {
    where: EventParticipationScalarWhereInput
    data: XOR<EventParticipationUpdateManyMutationInput, EventParticipationUncheckedUpdateManyWithoutEventInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEventInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEventInput, AttendanceUncheckedUpdateWithoutEventInput>
    create: XOR<AttendanceCreateWithoutEventInput, AttendanceUncheckedCreateWithoutEventInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEventInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEventInput, AttendanceUncheckedUpdateWithoutEventInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEventInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutEventInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type DivisionsCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHead?: UserCreateNestedOneWithoutDivisionHeadInput
    user?: UserCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkCreateNestedManyWithoutDivisionInput
    groups?: GroupsCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    establishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentHeadID?: string | null
    user?: UserUncheckedCreateNestedOneWithoutDivisionsInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutDivisionInput
    groups?: GroupsUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionsCreateOrConnectWithoutSessionsInput = {
    where: DivisionsWhereUniqueInput
    create: XOR<DivisionsCreateWithoutSessionsInput, DivisionsUncheckedCreateWithoutSessionsInput>
  }

  export type SessionTimeSlotCreateWithoutSessionInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
  }

  export type SessionTimeSlotUncheckedCreateWithoutSessionInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
  }

  export type SessionTimeSlotCreateOrConnectWithoutSessionInput = {
    where: SessionTimeSlotWhereUniqueInput
    create: XOR<SessionTimeSlotCreateWithoutSessionInput, SessionTimeSlotUncheckedCreateWithoutSessionInput>
  }

  export type SessionTimeSlotCreateManySessionInputEnvelope = {
    data: SessionTimeSlotCreateManySessionInput | SessionTimeSlotCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type GroupsCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutGroupsInput
    division?: DivisionsCreateNestedOneWithoutGroupsInput
    events?: EventsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
    events?: EventsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutSessionsInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutSessionsInput, GroupsUncheckedCreateWithoutSessionsInput>
  }

  export type TasksCreateWithoutSessionInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    assignedTo?: UserCreateNestedManyWithoutAssignedTasksInput
    event?: EventsCreateNestedOneWithoutTasksInput
    participants?: TaskParticipationCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateWithoutSessionInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    eventId?: string | null
    assignedTo?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
    participants?: TaskParticipationUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksCreateOrConnectWithoutSessionInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutSessionInput, TasksUncheckedCreateWithoutSessionInput>
  }

  export type TasksCreateManySessionInputEnvelope = {
    data: TasksCreateManySessionInput | TasksCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionParticipationCreateWithoutSessionInput = {
    id?: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionParticipationInput
  }

  export type SessionParticipationUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type SessionParticipationCreateOrConnectWithoutSessionInput = {
    where: SessionParticipationWhereUniqueInput
    create: XOR<SessionParticipationCreateWithoutSessionInput, SessionParticipationUncheckedCreateWithoutSessionInput>
  }

  export type SessionParticipationCreateManySessionInputEnvelope = {
    data: SessionParticipationCreateManySessionInput | SessionParticipationCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutSessionInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
    event?: EventsCreateNestedOneWithoutAttendanceInput
    headsUp?: HeadsUpCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceCreateManySessionInputEnvelope = {
    data: AttendanceCreateManySessionInput | AttendanceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DivisionsUpsertWithWhereUniqueWithoutSessionsInput = {
    where: DivisionsWhereUniqueInput
    update: XOR<DivisionsUpdateWithoutSessionsInput, DivisionsUncheckedUpdateWithoutSessionsInput>
    create: XOR<DivisionsCreateWithoutSessionsInput, DivisionsUncheckedCreateWithoutSessionsInput>
  }

  export type DivisionsUpdateWithWhereUniqueWithoutSessionsInput = {
    where: DivisionsWhereUniqueInput
    data: XOR<DivisionsUpdateWithoutSessionsInput, DivisionsUncheckedUpdateWithoutSessionsInput>
  }

  export type DivisionsUpdateManyWithWhereWithoutSessionsInput = {
    where: DivisionsScalarWhereInput
    data: XOR<DivisionsUpdateManyMutationInput, DivisionsUncheckedUpdateManyWithoutSessionsInput>
  }

  export type DivisionsScalarWhereInput = {
    AND?: DivisionsScalarWhereInput | DivisionsScalarWhereInput[]
    OR?: DivisionsScalarWhereInput[]
    NOT?: DivisionsScalarWhereInput | DivisionsScalarWhereInput[]
    id?: UuidFilter<"Divisions"> | string
    name?: StringFilter<"Divisions"> | string
    description?: StringNullableFilter<"Divisions"> | string | null
    imageUrl?: StringNullableFilter<"Divisions"> | string | null
    establishedAt?: DateTimeNullableFilter<"Divisions"> | Date | string | null
    createdAt?: DateTimeFilter<"Divisions"> | Date | string
    updatedAt?: DateTimeFilter<"Divisions"> | Date | string
    currentHeadID?: UuidNullableFilter<"Divisions"> | string | null
  }

  export type SessionTimeSlotUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionTimeSlotWhereUniqueInput
    update: XOR<SessionTimeSlotUpdateWithoutSessionInput, SessionTimeSlotUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionTimeSlotCreateWithoutSessionInput, SessionTimeSlotUncheckedCreateWithoutSessionInput>
  }

  export type SessionTimeSlotUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionTimeSlotWhereUniqueInput
    data: XOR<SessionTimeSlotUpdateWithoutSessionInput, SessionTimeSlotUncheckedUpdateWithoutSessionInput>
  }

  export type SessionTimeSlotUpdateManyWithWhereWithoutSessionInput = {
    where: SessionTimeSlotScalarWhereInput
    data: XOR<SessionTimeSlotUpdateManyMutationInput, SessionTimeSlotUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionTimeSlotScalarWhereInput = {
    AND?: SessionTimeSlotScalarWhereInput | SessionTimeSlotScalarWhereInput[]
    OR?: SessionTimeSlotScalarWhereInput[]
    NOT?: SessionTimeSlotScalarWhereInput | SessionTimeSlotScalarWhereInput[]
    id?: UuidFilter<"SessionTimeSlot"> | string
    sessionId?: UuidNullableFilter<"SessionTimeSlot"> | string | null
    startTime?: DateTimeFilter<"SessionTimeSlot"> | Date | string
    endTime?: DateTimeFilter<"SessionTimeSlot"> | Date | string
  }

  export type GroupsUpsertWithWhereUniqueWithoutSessionsInput = {
    where: GroupsWhereUniqueInput
    update: XOR<GroupsUpdateWithoutSessionsInput, GroupsUncheckedUpdateWithoutSessionsInput>
    create: XOR<GroupsCreateWithoutSessionsInput, GroupsUncheckedCreateWithoutSessionsInput>
  }

  export type GroupsUpdateWithWhereUniqueWithoutSessionsInput = {
    where: GroupsWhereUniqueInput
    data: XOR<GroupsUpdateWithoutSessionsInput, GroupsUncheckedUpdateWithoutSessionsInput>
  }

  export type GroupsUpdateManyWithWhereWithoutSessionsInput = {
    where: GroupsScalarWhereInput
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyWithoutSessionsInput>
  }

  export type TasksUpsertWithWhereUniqueWithoutSessionInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutSessionInput, TasksUncheckedUpdateWithoutSessionInput>
    create: XOR<TasksCreateWithoutSessionInput, TasksUncheckedCreateWithoutSessionInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutSessionInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutSessionInput, TasksUncheckedUpdateWithoutSessionInput>
  }

  export type TasksUpdateManyWithWhereWithoutSessionInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionParticipationUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionParticipationWhereUniqueInput
    update: XOR<SessionParticipationUpdateWithoutSessionInput, SessionParticipationUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionParticipationCreateWithoutSessionInput, SessionParticipationUncheckedCreateWithoutSessionInput>
  }

  export type SessionParticipationUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionParticipationWhereUniqueInput
    data: XOR<SessionParticipationUpdateWithoutSessionInput, SessionParticipationUncheckedUpdateWithoutSessionInput>
  }

  export type SessionParticipationUpdateManyWithWhereWithoutSessionInput = {
    where: SessionParticipationScalarWhereInput
    data: XOR<SessionParticipationUpdateManyMutationInput, SessionParticipationUncheckedUpdateManyWithoutSessionInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutSessionInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutSessionInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type UserCreateWithoutAssignedTasksInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type EventsCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutEventsInput
    timeSlots?: EventTimeSlotCreateNestedManyWithoutEventInput
    groups?: GroupsCreateNestedManyWithoutEventsInput
    participants?: EventParticipationCreateNestedManyWithoutEventInput
    attendance?: AttendanceCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    timeSlots?: EventTimeSlotUncheckedCreateNestedManyWithoutEventInput
    groups?: GroupsUncheckedCreateNestedManyWithoutEventsInput
    participants?: EventParticipationUncheckedCreateNestedManyWithoutEventInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutTasksInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutTasksInput, EventsUncheckedCreateWithoutTasksInput>
  }

  export type SessionsCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutTasksInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutTasksInput, SessionsUncheckedCreateWithoutTasksInput>
  }

  export type TaskParticipationCreateWithoutTaskInput = {
    id?: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTaskParticipationInput
  }

  export type TaskParticipationUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type TaskParticipationCreateOrConnectWithoutTaskInput = {
    where: TaskParticipationWhereUniqueInput
    create: XOR<TaskParticipationCreateWithoutTaskInput, TaskParticipationUncheckedCreateWithoutTaskInput>
  }

  export type TaskParticipationCreateManyTaskInputEnvelope = {
    data: TaskParticipationCreateManyTaskInput | TaskParticipationCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedTasksInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedTasksInput>
  }

  export type EventsUpsertWithoutTasksInput = {
    update: XOR<EventsUpdateWithoutTasksInput, EventsUncheckedUpdateWithoutTasksInput>
    create: XOR<EventsCreateWithoutTasksInput, EventsUncheckedCreateWithoutTasksInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutTasksInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutTasksInput, EventsUncheckedUpdateWithoutTasksInput>
  }

  export type EventsUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutEventsNestedInput
    timeSlots?: EventTimeSlotUpdateManyWithoutEventNestedInput
    groups?: GroupsUpdateManyWithoutEventsNestedInput
    participants?: EventParticipationUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    timeSlots?: EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutEventsNestedInput
    participants?: EventParticipationUncheckedUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutEventNestedInput
  }

  export type SessionsUpsertWithoutTasksInput = {
    update: XOR<SessionsUpdateWithoutTasksInput, SessionsUncheckedUpdateWithoutTasksInput>
    create: XOR<SessionsCreateWithoutTasksInput, SessionsUncheckedCreateWithoutTasksInput>
    where?: SessionsWhereInput
  }

  export type SessionsUpdateToOneWithWhereWithoutTasksInput = {
    where?: SessionsWhereInput
    data: XOR<SessionsUpdateWithoutTasksInput, SessionsUncheckedUpdateWithoutTasksInput>
  }

  export type SessionsUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TaskParticipationUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskParticipationWhereUniqueInput
    update: XOR<TaskParticipationUpdateWithoutTaskInput, TaskParticipationUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskParticipationCreateWithoutTaskInput, TaskParticipationUncheckedCreateWithoutTaskInput>
  }

  export type TaskParticipationUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskParticipationWhereUniqueInput
    data: XOR<TaskParticipationUpdateWithoutTaskInput, TaskParticipationUncheckedUpdateWithoutTaskInput>
  }

  export type TaskParticipationUpdateManyWithWhereWithoutTaskInput = {
    where: TaskParticipationScalarWhereInput
    data: XOR<TaskParticipationUpdateManyMutationInput, TaskParticipationUncheckedUpdateManyWithoutTaskInput>
  }

  export type EventsCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutEventsInput
    timeSlots?: EventTimeSlotCreateNestedManyWithoutEventInput
    groups?: GroupsCreateNestedManyWithoutEventsInput
    tasks?: TasksCreateNestedManyWithoutEventInput
    attendance?: AttendanceCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    timeSlots?: EventTimeSlotUncheckedCreateNestedManyWithoutEventInput
    groups?: GroupsUncheckedCreateNestedManyWithoutEventsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutEventInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutParticipantsInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutParticipantsInput, EventsUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutEventParticipationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventParticipationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventParticipationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventParticipationInput, UserUncheckedCreateWithoutEventParticipationInput>
  }

  export type EventsUpsertWithoutParticipantsInput = {
    update: XOR<EventsUpdateWithoutParticipantsInput, EventsUncheckedUpdateWithoutParticipantsInput>
    create: XOR<EventsCreateWithoutParticipantsInput, EventsUncheckedCreateWithoutParticipantsInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutParticipantsInput, EventsUncheckedUpdateWithoutParticipantsInput>
  }

  export type EventsUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutEventsNestedInput
    timeSlots?: EventTimeSlotUpdateManyWithoutEventNestedInput
    groups?: GroupsUpdateManyWithoutEventsNestedInput
    tasks?: TasksUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    timeSlots?: EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutEventsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutEventParticipationInput = {
    update: XOR<UserUpdateWithoutEventParticipationInput, UserUncheckedUpdateWithoutEventParticipationInput>
    create: XOR<UserCreateWithoutEventParticipationInput, UserUncheckedCreateWithoutEventParticipationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventParticipationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventParticipationInput, UserUncheckedUpdateWithoutEventParticipationInput>
  }

  export type UserUpdateWithoutEventParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionsCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutParticipantsInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutParticipantsInput, SessionsUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutSessionParticipationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionParticipationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionParticipationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionParticipationInput, UserUncheckedCreateWithoutSessionParticipationInput>
  }

  export type SessionsUpsertWithoutParticipantsInput = {
    update: XOR<SessionsUpdateWithoutParticipantsInput, SessionsUncheckedUpdateWithoutParticipantsInput>
    create: XOR<SessionsCreateWithoutParticipantsInput, SessionsUncheckedCreateWithoutParticipantsInput>
    where?: SessionsWhereInput
  }

  export type SessionsUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: SessionsWhereInput
    data: XOR<SessionsUpdateWithoutParticipantsInput, SessionsUncheckedUpdateWithoutParticipantsInput>
  }

  export type SessionsUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutSessionParticipationInput = {
    update: XOR<UserUpdateWithoutSessionParticipationInput, UserUncheckedUpdateWithoutSessionParticipationInput>
    create: XOR<UserCreateWithoutSessionParticipationInput, UserUncheckedCreateWithoutSessionParticipationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionParticipationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionParticipationInput, UserUncheckedUpdateWithoutSessionParticipationInput>
  }

  export type UserUpdateWithoutSessionParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    assignedTo?: UserCreateNestedManyWithoutAssignedTasksInput
    event?: EventsCreateNestedOneWithoutTasksInput
    session?: SessionsCreateNestedOneWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    eventId?: string | null
    sessionId?: string | null
    assignedTo?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TasksCreateOrConnectWithoutParticipantsInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutParticipantsInput, TasksUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTaskParticipationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskParticipationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskParticipationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskParticipationInput, UserUncheckedCreateWithoutTaskParticipationInput>
  }

  export type TasksUpsertWithoutParticipantsInput = {
    update: XOR<TasksUpdateWithoutParticipantsInput, TasksUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TasksCreateWithoutParticipantsInput, TasksUncheckedCreateWithoutParticipantsInput>
    where?: TasksWhereInput
  }

  export type TasksUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TasksWhereInput
    data: XOR<TasksUpdateWithoutParticipantsInput, TasksUncheckedUpdateWithoutParticipantsInput>
  }

  export type TasksUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignedTo?: UserUpdateManyWithoutAssignedTasksNestedInput
    event?: EventsUpdateOneWithoutTasksNestedInput
    session?: SessionsUpdateOneWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type UserUpsertWithoutTaskParticipationInput = {
    update: XOR<UserUpdateWithoutTaskParticipationInput, UserUncheckedUpdateWithoutTaskParticipationInput>
    create: XOR<UserCreateWithoutTaskParticipationInput, UserUncheckedCreateWithoutTaskParticipationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskParticipationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskParticipationInput, UserUncheckedUpdateWithoutTaskParticipationInput>
  }

  export type UserUpdateWithoutTaskParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAttendanceInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
  }

  export type SessionsCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSessionsInput
    division?: DivisionsCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsCreateNestedManyWithoutSessionsInput
    tasks?: TasksCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationCreateNestedManyWithoutSessionInput
  }

  export type SessionsUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    division?: DivisionsUncheckedCreateNestedManyWithoutSessionsInput
    timeSlot?: SessionTimeSlotUncheckedCreateNestedManyWithoutSessionInput
    targetGroups?: GroupsUncheckedCreateNestedManyWithoutSessionsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutSessionInput
    participants?: SessionParticipationUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionsCreateOrConnectWithoutAttendanceInput = {
    where: SessionsWhereUniqueInput
    create: XOR<SessionsCreateWithoutAttendanceInput, SessionsUncheckedCreateWithoutAttendanceInput>
  }

  export type EventsCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutEventsInput
    timeSlots?: EventTimeSlotCreateNestedManyWithoutEventInput
    groups?: GroupsCreateNestedManyWithoutEventsInput
    tasks?: TasksCreateNestedManyWithoutEventInput
    participants?: EventParticipationCreateNestedManyWithoutEventInput
  }

  export type EventsUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    timeSlots?: EventTimeSlotUncheckedCreateNestedManyWithoutEventInput
    groups?: GroupsUncheckedCreateNestedManyWithoutEventsInput
    tasks?: TasksUncheckedCreateNestedManyWithoutEventInput
    participants?: EventParticipationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventsCreateOrConnectWithoutAttendanceInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutAttendanceInput, EventsUncheckedCreateWithoutAttendanceInput>
  }

  export type HeadsUpCreateWithoutAttendanceInput = {
    id?: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
    user: UserCreateNestedOneWithoutHeadsUpInput
  }

  export type HeadsUpUncheckedCreateWithoutAttendanceInput = {
    id?: string
    userId: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
  }

  export type HeadsUpCreateOrConnectWithoutAttendanceInput = {
    where: HeadsUpWhereUniqueInput
    create: XOR<HeadsUpCreateWithoutAttendanceInput, HeadsUpUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutAttendanceInput = {
    update: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionsUpsertWithoutAttendanceInput = {
    update: XOR<SessionsUpdateWithoutAttendanceInput, SessionsUncheckedUpdateWithoutAttendanceInput>
    create: XOR<SessionsCreateWithoutAttendanceInput, SessionsUncheckedCreateWithoutAttendanceInput>
    where?: SessionsWhereInput
  }

  export type SessionsUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: SessionsWhereInput
    data: XOR<SessionsUpdateWithoutAttendanceInput, SessionsUncheckedUpdateWithoutAttendanceInput>
  }

  export type SessionsUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type EventsUpsertWithoutAttendanceInput = {
    update: XOR<EventsUpdateWithoutAttendanceInput, EventsUncheckedUpdateWithoutAttendanceInput>
    create: XOR<EventsCreateWithoutAttendanceInput, EventsUncheckedCreateWithoutAttendanceInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutAttendanceInput, EventsUncheckedUpdateWithoutAttendanceInput>
  }

  export type EventsUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutEventsNestedInput
    timeSlots?: EventTimeSlotUpdateManyWithoutEventNestedInput
    groups?: GroupsUpdateManyWithoutEventsNestedInput
    tasks?: TasksUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    timeSlots?: EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutEventsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type HeadsUpUpsertWithoutAttendanceInput = {
    update: XOR<HeadsUpUpdateWithoutAttendanceInput, HeadsUpUncheckedUpdateWithoutAttendanceInput>
    create: XOR<HeadsUpCreateWithoutAttendanceInput, HeadsUpUncheckedCreateWithoutAttendanceInput>
    where?: HeadsUpWhereInput
  }

  export type HeadsUpUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: HeadsUpWhereInput
    data: XOR<HeadsUpUpdateWithoutAttendanceInput, HeadsUpUncheckedUpdateWithoutAttendanceInput>
  }

  export type HeadsUpUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHeadsUpNestedInput
  }

  export type HeadsUpUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAttendanceSummaryInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceSummaryInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceSummaryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceSummaryInput, UserUncheckedCreateWithoutAttendanceSummaryInput>
  }

  export type UserUpsertWithoutAttendanceSummaryInput = {
    update: XOR<UserUpdateWithoutAttendanceSummaryInput, UserUncheckedUpdateWithoutAttendanceSummaryInput>
    create: XOR<UserCreateWithoutAttendanceSummaryInput, UserUncheckedCreateWithoutAttendanceSummaryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceSummaryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceSummaryInput, UserUncheckedUpdateWithoutAttendanceSummaryInput>
  }

  export type UserUpdateWithoutAttendanceSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHeadsUpInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHeadsUpInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHeadsUpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHeadsUpInput, UserUncheckedCreateWithoutHeadsUpInput>
  }

  export type AttendanceCreateWithoutHeadsUpInput = {
    id?: string
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
    session?: SessionsCreateNestedOneWithoutAttendanceInput
    event?: EventsCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutHeadsUpInput = {
    id?: string
    userId: string
    sessionId?: string | null
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutHeadsUpInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutHeadsUpInput, AttendanceUncheckedCreateWithoutHeadsUpInput>
  }

  export type UserUpsertWithoutHeadsUpInput = {
    update: XOR<UserUpdateWithoutHeadsUpInput, UserUncheckedUpdateWithoutHeadsUpInput>
    create: XOR<UserCreateWithoutHeadsUpInput, UserUncheckedCreateWithoutHeadsUpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHeadsUpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHeadsUpInput, UserUncheckedUpdateWithoutHeadsUpInput>
  }

  export type UserUpdateWithoutHeadsUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHeadsUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttendanceUpsertWithoutHeadsUpInput = {
    update: XOR<AttendanceUpdateWithoutHeadsUpInput, AttendanceUncheckedUpdateWithoutHeadsUpInput>
    create: XOR<AttendanceCreateWithoutHeadsUpInput, AttendanceUncheckedCreateWithoutHeadsUpInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutHeadsUpInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutHeadsUpInput, AttendanceUncheckedUpdateWithoutHeadsUpInput>
  }

  export type AttendanceUpdateWithoutHeadsUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
    session?: SessionsUpdateOneWithoutAttendanceNestedInput
    event?: EventsUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutHeadsUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithWhereUniqueWithoutNotificationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutNotificationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateManyWithWhereWithoutNotificationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutNotificationInput>
  }

  export type UserCreateWithoutAnnouncementsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    Badges?: BadgesCreateNestedManyWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    Badges?: BadgesUncheckedCreateNestedManyWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateManyWithWhereWithoutAnnouncementsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAnnouncementsInput>
  }

  export type FileCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    tag?: string | null
    size: number
    fileUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    tag?: string | null
    size: number
    fileUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutCategoriesInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutCategoriesInput, FileUncheckedCreateWithoutCategoriesInput>
  }

  export type FileCreateManyCategoriesInputEnvelope = {
    data: FileCreateManyCategoriesInput | FileCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type FileUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutCategoriesInput, FileUncheckedUpdateWithoutCategoriesInput>
    create: XOR<FileCreateWithoutCategoriesInput, FileUncheckedCreateWithoutCategoriesInput>
  }

  export type FileUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutCategoriesInput, FileUncheckedUpdateWithoutCategoriesInput>
  }

  export type FileUpdateManyWithWhereWithoutCategoriesInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: UuidFilter<"File"> | string
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    type?: StringFilter<"File"> | string
    tag?: StringNullableFilter<"File"> | string | null
    size?: IntFilter<"File"> | number
    fileUrl?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    categoryId?: UuidNullableFilter<"File"> | string | null
  }

  export type FileCategoriesCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCategoriesUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCategoriesCreateOrConnectWithoutFilesInput = {
    where: FileCategoriesWhereUniqueInput
    create: XOR<FileCategoriesCreateWithoutFilesInput, FileCategoriesUncheckedCreateWithoutFilesInput>
  }

  export type FileCategoriesUpsertWithoutFilesInput = {
    update: XOR<FileCategoriesUpdateWithoutFilesInput, FileCategoriesUncheckedUpdateWithoutFilesInput>
    create: XOR<FileCategoriesCreateWithoutFilesInput, FileCategoriesUncheckedCreateWithoutFilesInput>
    where?: FileCategoriesWhereInput
  }

  export type FileCategoriesUpdateToOneWithWhereWithoutFilesInput = {
    where?: FileCategoriesWhereInput
    data: XOR<FileCategoriesUpdateWithoutFilesInput, FileCategoriesUncheckedUpdateWithoutFilesInput>
  }

  export type FileCategoriesUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCategoriesUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoCreateNestedOneWithoutUserInput
    Divisions?: DivisionsCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingCreateNestedOneWithoutUserInput
    events?: EventsCreateNestedManyWithoutCreatorInput
    sessions?: SessionsCreateNestedManyWithoutCreatorInput
    groups?: GroupsCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender
    email?: string | null
    password?: string | null
    phone_number?: string | null
    telegramUserName?: string | null
    bio?: string | null
    berthDate?: Date | string | null
    profileImageUrl?: string | null
    clubStatus?: $Enums.ClubStatus | null
    specialty?: string | null
    cvUrl?: string | null
    lastSeen: Date | string
    role?: $Enums.RoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    DivisionId?: string | null
    UserSettingId?: string | null
    DivisionHeadID?: string | null
    AttendanceSummaryId?: string | null
    universityInfo?: UniversityInfoUncheckedCreateNestedOneWithoutUserInput
    socialLinks?: socialLinkUncheckedCreateNestedManyWithoutUserInput
    UserSetting?: UserSettingUncheckedCreateNestedOneWithoutUserInput
    events?: EventsUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionsUncheckedCreateNestedManyWithoutCreatorInput
    groups?: GroupsUncheckedCreateNestedManyWithoutUsersInput
    DivisionHead?: DivisionsUncheckedCreateNestedOneWithoutCurrentHeadInput
    TasksCreated?: TasksUncheckedCreateNestedManyWithoutCreatorInput
    AssignedTasks?: TasksUncheckedCreateNestedManyWithoutAssignedToInput
    EventParticipation?: EventParticipationUncheckedCreateNestedManyWithoutUserInput
    SessionParticipation?: SessionParticipationUncheckedCreateNestedManyWithoutUserInput
    TaskParticipation?: TaskParticipationUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    AttendanceSummary?: AttendanceSummaryUncheckedCreateNestedOneWithoutUserInput
    HeadsUp?: HeadsUpUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Announcements?: AnnouncementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBadgesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBadgesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateManyWithWhereWithoutBadgesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBadgesInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: $Enums.RoleType
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    role: $Enums.RoleType
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    role?: EnumRoleTypeFilter<"RolePermission"> | $Enums.RoleType
    permissionId?: IntFilter<"RolePermission"> | number
  }

  export type PermissionCreateWithoutRolesInput = {
    key: string
    label: string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: number
    key: string
    label: string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
  }

  export type socialLinkCreateManyUserInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    DivisionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    tags?: EventsCreatetagsInput | $Enums.Tag[]
    visibility: $Enums.EventVisibility
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionsCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startMonth: Date | string
    endTMonth: Date | string
    location?: string | null
    tags?: SessionsCreatetagsInput | $Enums.Tag[]
    state: $Enums.state
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TasksCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventId?: string | null
    sessionId?: string | null
  }

  export type EventParticipationCreateManyUserInput = {
    id?: string
    eventId: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type SessionParticipationCreateManyUserInput = {
    id?: string
    sessionId: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type TaskParticipationCreateManyUserInput = {
    id?: string
    taskId: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    sessionId?: string | null
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeadsUpCreateManyUserInput = {
    id?: string
    type: $Enums.HeadsUpType
    body: string
    sentAt?: Date | string
  }

  export type socialLinkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Division?: DivisionsUpdateOneWithoutSocialLinksNestedInput
  }

  export type socialLinkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type socialLinkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlots?: EventTimeSlotUpdateManyWithoutEventNestedInput
    groups?: GroupsUpdateManyWithoutEventsNestedInput
    tasks?: TasksUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlots?: EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutEventsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUncheckedUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: DivisionsUpdateOneWithoutGroupsNestedInput
    sessions?: SessionsUpdateManyWithoutTargetGroupsNestedInput
    events?: EventsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionsUncheckedUpdateManyWithoutTargetGroupsNestedInput
    events?: EventsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TasksUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateManyWithoutAssignedTasksNestedInput
    event?: EventsUpdateOneWithoutTasksNestedInput
    session?: SessionsUpdateOneWithoutTasksNestedInput
    participants?: TaskParticipationUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
    participants?: TaskParticipationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TasksUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    event?: EventsUpdateOneWithoutTasksNestedInput
    session?: SessionsUpdateOneWithoutTasksNestedInput
    participants?: TaskParticipationUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: TaskParticipationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventsUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type EventParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionsUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type SessionParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TasksUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type TaskParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionsUpdateOneWithoutAttendanceNestedInput
    event?: EventsUpdateOneWithoutAttendanceNestedInput
    headsUp?: HeadsUpUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeadsUpUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateOneWithoutHeadsUpNestedInput
  }

  export type HeadsUpUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateOneWithoutHeadsUpNestedInput
  }

  export type HeadsUpUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHeadsUpTypeFieldUpdateOperationsInput | $Enums.HeadsUpType
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumAnnouncementVisibilityFieldUpdateOperationsInput | $Enums.AnnouncementVisibility
    Tags?: AnnouncementUpdateTagsInput | $Enums.Tag[]
    announcementType?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type socialLinkCreateManyDivisionInput = {
    id?: string
    socialLinkName: string
    socialLinkUrl: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupsCreateManyDivisionInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type socialLinkUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSocialLinksNestedInput
  }

  export type socialLinkUncheckedUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type socialLinkUncheckedUpdateManyWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    socialLinkName?: StringFieldUpdateOperationsInput | string
    socialLinkUrl?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionsUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    targetGroups?: GroupsUncheckedUpdateManyWithoutSessionsNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateManyWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupsUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutGroupsNestedInput
    sessions?: SessionsUpdateManyWithoutTargetGroupsNestedInput
    events?: EventsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutTargetGroupsNestedInput
    events?: EventsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateManyWithoutDivisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionsUpdateWithoutTargetGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSessionsNestedInput
    division?: DivisionsUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUpdateManyWithoutSessionNestedInput
    tasks?: TasksUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateWithoutTargetGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    division?: DivisionsUncheckedUpdateManyWithoutSessionsNestedInput
    timeSlot?: SessionTimeSlotUncheckedUpdateManyWithoutSessionNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutSessionNestedInput
    participants?: SessionParticipationUncheckedUpdateManyWithoutSessionNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionsUncheckedUpdateManyWithoutTargetGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    endTMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SessionsUpdatetagsInput | $Enums.Tag[]
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type EventsUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutEventsNestedInput
    timeSlots?: EventTimeSlotUpdateManyWithoutEventNestedInput
    tasks?: TasksUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    timeSlots?: EventTimeSlotUncheckedUpdateManyWithoutEventNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutEventNestedInput
    participants?: EventParticipationUncheckedUpdateManyWithoutEventNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: EventsUpdatetagsInput | $Enums.Tag[]
    visibility?: EnumEventVisibilityFieldUpdateOperationsInput | $Enums.EventVisibility
    state?: EnumstateFieldUpdateOperationsInput | $Enums.state
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type EventTimeSlotCreateManyEventInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
  }

  export type TasksCreateManyEventInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    sessionId?: string | null
  }

  export type EventParticipationCreateManyEventInput = {
    id?: string
    userId: string
    role: $Enums.EventRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyEventInput = {
    id?: string
    userId: string
    sessionId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTimeSlotUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTimeSlotUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTimeSlotUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupsUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutGroupsNestedInput
    division?: DivisionsUpdateOneWithoutGroupsNestedInput
    sessions?: SessionsUpdateManyWithoutTargetGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutTargetGroupsNestedInput
  }

  export type GroupsUncheckedUpdateManyWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TasksUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignedTo?: UserUpdateManyWithoutAssignedTasksNestedInput
    session?: SessionsUpdateOneWithoutTasksNestedInput
    participants?: TaskParticipationUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
    participants?: TaskParticipationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventParticipationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventParticipationNestedInput
  }

  export type EventParticipationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventParticipationUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumEventRoleFieldUpdateOperationsInput | $Enums.EventRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
    session?: SessionsUpdateOneWithoutAttendanceNestedInput
    headsUp?: HeadsUpUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionTimeSlotCreateManySessionInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
  }

  export type TasksCreateManySessionInput = {
    id?: string
    title: string
    description?: string | null
    dueDate: Date | string
    status?: $Enums.TaskStatus
    completedNotes?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    eventId?: string | null
  }

  export type SessionParticipationCreateManySessionInput = {
    id?: string
    userId: string
    role: $Enums.SessionRole
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManySessionInput = {
    id?: string
    userId: string
    eventId?: string | null
    status?: $Enums.AttendanceStatus
    timestamp?: Date | string
    headsUpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DivisionsUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHead?: UserUpdateOneWithoutDivisionHeadNestedInput
    user?: UserUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutDivisionsNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutDivisionNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionsUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    establishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHeadID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionTimeSlotUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionTimeSlotUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionTimeSlotUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupsUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutGroupsNestedInput
    division?: DivisionsUpdateOneWithoutGroupsNestedInput
    events?: EventsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    events?: EventsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TasksUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    assignedTo?: UserUpdateManyWithoutAssignedTasksNestedInput
    event?: EventsUpdateOneWithoutTasksNestedInput
    participants?: TaskParticipationUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
    participants?: TaskParticipationUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    completedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionParticipationUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionParticipationNestedInput
  }

  export type SessionParticipationUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipationUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumSessionRoleFieldUpdateOperationsInput | $Enums.SessionRole
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
    event?: EventsUpdateOneWithoutAttendanceNestedInput
    headsUp?: HeadsUpUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    headsUpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationCreateManyTaskInput = {
    id?: string
    userId: string
    role: string
    score?: number
    feedback?: string | null
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskParticipationUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskParticipationNestedInput
  }

  export type TaskParticipationUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskParticipationUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    Badges?: BadgesUpdateManyWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    Badges?: BadgesUncheckedUpdateManyWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    tag?: string | null
    size: number
    fileUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUpdateOneWithoutUserNestedInput
    Divisions?: DivisionsUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUpdateOneWithoutUserNestedInput
    events?: EventsUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
    universityInfo?: UniversityInfoUncheckedUpdateOneWithoutUserNestedInput
    socialLinks?: socialLinkUncheckedUpdateManyWithoutUserNestedInput
    UserSetting?: UserSettingUncheckedUpdateOneWithoutUserNestedInput
    events?: EventsUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionsUncheckedUpdateManyWithoutCreatorNestedInput
    groups?: GroupsUncheckedUpdateManyWithoutUsersNestedInput
    DivisionHead?: DivisionsUncheckedUpdateOneWithoutCurrentHeadNestedInput
    TasksCreated?: TasksUncheckedUpdateManyWithoutCreatorNestedInput
    AssignedTasks?: TasksUncheckedUpdateManyWithoutAssignedToNestedInput
    EventParticipation?: EventParticipationUncheckedUpdateManyWithoutUserNestedInput
    SessionParticipation?: SessionParticipationUncheckedUpdateManyWithoutUserNestedInput
    TaskParticipation?: TaskParticipationUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    AttendanceSummary?: AttendanceSummaryUncheckedUpdateOneWithoutUserNestedInput
    HeadsUp?: HeadsUpUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Announcements?: AnnouncementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    telegramUserName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    berthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clubStatus?: NullableEnumClubStatusFieldUpdateOperationsInput | $Enums.ClubStatus | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    cvUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DivisionId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSettingId?: NullableStringFieldUpdateOperationsInput | string | null
    DivisionHeadID?: NullableStringFieldUpdateOperationsInput | string | null
    AttendanceSummaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: number
    role: $Enums.RoleType
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleTypeFieldUpdateOperationsInput | $Enums.RoleType
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}